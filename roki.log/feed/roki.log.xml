<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>roki.log</title>
    <link href="https://roki.dev/roki.log/feed/roki.log.xml" rel="self" />
    <link href="https://roki.dev/roki.log" />
    <id>https://roki.dev/roki.log/feed/roki.log.xml</id>
    <author>
        <name>Roki</name>
        <email>falgon53@yahoo.co.jp</email>
    </author>
    <updated>2022-04-10T09:05:34Z</updated>
    <entry>
    <title>簡易認証, 指定時間実行可能な LINE Bot の自作</title>
    <link href="https://roki.dev/roki.log/2022/04/10/LineBotDevelopment/index.html" />
    <id>https://roki.dev/roki.log/2022/04/10/LineBotDevelopment/index.html</id>
    <published>2022-04-10T09:05:34Z</published>
    <updated>2022-04-10T09:05:34Z</updated>
    <summary type="html"><![CDATA[<p>普段業務外では LINE 株式会社 (以下 LINE 社) が提供する LINE というメッセンジャーアプリ上でやり取りをすることが多いので, そのインタフェース上で色々と動かせたりするとそれなりに便利かもと最近思い始めた. そこで, 筆者の考える基本的な機能を備えた LINE Bot を一旦作ってみることとした. 本エントリはその備忘録である. 下記のリポジトリに成果物を公開している.</p>
<div class="has-text-centered mt-2 mb-2">
<p><i class="fab fa-github fa-fw"></i> <a href="https://github.com/falgon/line-bot-kiirotori">falgon/line-bot-kiirotori - My LINE Bot </a></p>
</div>
<h2 id="基本構成">基本構成</h2>
<p>今回は個人利用/小規模であり, 特別な費用を発生させたくなかったので <a href="https://www.oracle.com/cloud/">Oracle Cloud Infrastructure</a> (以下 OCI) の Always Free 枠である Ubuntu インスタンス上にサーバを構成した<a href="/roki.log/2022/04/10/LineBotDevelopment/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. 同インスタンス上では Jitsi Meet<a href="/roki.log/2022/04/10/LineBotDevelopment/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> という別のウェブサービスを nginx を用いて運用していたので, それをそのままリバースプロキシとしても利用し, Bot サーバへの通信を HTTPS 化した. これらはサブドメインに従ってリクエストを振り分けているが, それぞれの SSL 証明書を作成するのは手間がかかるので, 今回は (let’s encrypt の) ワイルドカード証明書で管理することとした. ドメイン管理には Google Domains を使っているが, TXT レコードを随時更新する API が用意されておらず, 現状手動更新が必須となっている. これは追々なんとかしたい<a href="/roki.log/2022/04/10/LineBotDevelopment/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<!--more-->
<h2 id="line-bot-の実装">LINE Bot の実装</h2>
<p>LINE Bot を実装するにあたって, 特徴的ないくつかのトピックについて取り上げる.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-1" aria-hidden="true"></a>$ <span class="ex">line-bot-kiirotori</span> --help</span>
<span id="cb1-2"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-2" aria-hidden="true"></a><span class="ex">Usage</span>: line-bot-kiirotori [--version] [-c<span class="kw">|</span><span class="ex">--config</span> <span class="op">&lt;</span>config file path<span class="op">&gt;</span>] </span>
<span id="cb1-3"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-3" aria-hidden="true"></a>                          [<span class="ex">-s</span><span class="kw">|</span><span class="ex">--cron-schedule</span> <span class="op">&lt;</span>cron-schedule file path<span class="op">&gt;</span>] </span>
<span id="cb1-4"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-4" aria-hidden="true"></a>                          [<span class="ex">-q</span><span class="kw">|</span><span class="ex">--quiet</span>] COMMAND</span>
<span id="cb1-5"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-5" aria-hidden="true"></a>  <span class="ex">line-bot-kiirotori</span></span>
<span id="cb1-6"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-7" aria-hidden="true"></a><span class="ex">Available</span> options:</span>
<span id="cb1-8"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-8" aria-hidden="true"></a>  <span class="ex">-h</span>,--help                Show this help text</span>
<span id="cb1-9"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-9" aria-hidden="true"></a>  <span class="ex">--version</span>                Prints the line-bot-kiirotori suite version</span>
<span id="cb1-10"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-10" aria-hidden="true"></a>  <span class="ex">-q</span>,--quiet               Quiet log output</span>
<span id="cb1-11"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-11" aria-hidden="true"></a></span>
<span id="cb1-12"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-12" aria-hidden="true"></a><span class="ex">Available</span> commands:</span>
<span id="cb1-13"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-13" aria-hidden="true"></a>  <span class="ex">serve</span>                    boot server</span>
<span id="cb1-14"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-14" aria-hidden="true"></a>$ <span class="ex">line-bot-kiirotori</span> --version</span>
<span id="cb1-15"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-15" aria-hidden="true"></a>　　　　 Ｖ</span>
<span id="cb1-16"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-16" aria-hidden="true"></a>　　 ／￣￣￣＼　/<span class="kw">|</span></span>
<span id="cb1-17"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-17" aria-hidden="true"></a>　　 　●＿＿●  Ｖ <span class="kw">|</span>     <span class="ex">__</span>   _ _            __             _</span>
<span id="cb1-18"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-18" aria-hidden="true"></a>　 ｜　 <span class="kw">(</span>･＿･<span class="kw">)</span>　 ノ    <span class="ex">/</span> /__(_<span class="kw">|</span><span class="ex">_</span>)<span class="ex">________</span>  / /_____  _____(_)</span>
<span id="cb1-19"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-19" aria-hidden="true"></a>　 /　　 ヽノ　 ｜    <span class="ex">/</span> //_/ / / ___/ __ \/ __/ __ \/ ___/ /</span>
<span id="cb1-20"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-20" aria-hidden="true"></a>　<span class="kw">(</span><span class="ex">_</span>ノ　　　　　ﾉ    / ,<span class="op">&lt;</span> / / / /  / /_/ / /_/ /_/ / /  / /</span>
<span id="cb1-21"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-21" aria-hidden="true"></a>　　＼＿＿＿＿／    <span class="ex">/_</span>/<span class="kw">|</span><span class="ex">_/_/_/_/</span>   \____/\__/\____/_/  /_/</span>
<span id="cb1-22"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-22" aria-hidden="true"></a>　　　 ｜　｜</span>
<span id="cb1-23"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-23" aria-hidden="true"></a>　　　 个　个</span>
<span id="cb1-24"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-24" aria-hidden="true"></a></span>
<span id="cb1-25"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-25" aria-hidden="true"></a></span>
<span id="cb1-26"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-26" aria-hidden="true"></a><span class="ex">version</span>: 0.1.0.0</span>
<span id="cb1-27"><a href="/roki.log/2022/04/10/LineBotDevelopment/#cb1-27" aria-hidden="true"></a><span class="ex">built</span> commit hash: 6efc35754150917de47bdf5ef3a56e4d81322098</span></code></pre></div>
<h3 id="チャネルアクセストークン-v2.1-の発行と管理">チャネルアクセストークン v2.1 の発行と管理</h3>
<p>LINE Bot を作成するのには LINE 社の提供する <a href="https://developers.line.biz/ja/docs/messaging-api/">Messaging API</a> を利用する. LINE Messaging API を利用したボットは, LINE プラットフォームから送信される Webhook イベントに対して LINE プラットフォームへ応答する必要がある.</p>
<figure>
<img src="/roki.log/2022/04/10/LineBotDevelopment/messaging-api-architecture.f40bffbb.png" alt /><figcaption>LINE Messaging API の仕組み, <a href="https://developers.line.biz/ja/docs/messaging-api/overview/#how-messaging-api-works">LINE Developers</a> から引用</figcaption>
</figure>
<p>この LINE プラットフォーム間のやりとりでは, 通信している相手がサービスの利用権限を持つ本人であることを証明するために, LINE 社の提供する<a href="https://developers.line.biz/ja/docs/messaging-api/channel-access-tokens/#what-are-channel-access-tokens">チャネルアクセストークン</a>を用いた認証プロセスを経る. チャネルアクセストークンには, 任意の有効期限が指定できるチャネルアクセストークン v2.1, 短期のチャネルアクセストークン, 長期のチャネルアクセストークンという 3 つの種類がある. これらの中でも LINE 社はチャネルアクセストークン v2.1 を推奨しており, その特徴として発行に JSON Web Token (以下 JWT) 使用し, 期限を任意 (最大 30 日) に指定できる点が挙げられる. 今回は個人利用ではあるものの, 期限を<i>良い感じ</i>に短くしたアクセストークンを使って<i>無駄に</i>セキュリティを強化したいところであったので, チャネルアクセストークン v2.1 を使用することとした<a href="/roki.log/2022/04/10/LineBotDevelopment/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<p>チャネルアクセストークン v2.1 の発行方法/概要は<a href="https://developers.line.biz/ja/docs/messaging-api/generate-json-web-token/#create-an-assertion-signing-key">ドキュメント</a>を参照頂くとして, まずは Haskell での JWT の生成例から順に示す. Haskell で行う場合, <a href="https://hackage.haskell.org/package/jose">jose</a> パッケージを利用すると楽である. <a href="https://developers.line.biz/ja/docs/messaging-api/generate-json-web-token/#generate-jwt">ドキュメント</a>の要請するオブジェクトに従うと, ヘッダーとペイロードは, 例えば以下のように定義できる.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2F31b9cdbcdbe19b821406966320378b68a82a0184%2Fsrc%2FLBKiirotori%2FAccessToken%2FJWT.hs%23L38-L62&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>これとアサーション署名キー<a href="/roki.log/2022/04/10/LineBotDevelopment/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>の秘密鍵を使って署名してやれば, JWT が出来上がる.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2Fc0c766a480e3ecd117be2c3e4045b80382dd5cd7%2Fsrc%2FLBKiirotori%2FAccessToken%2FJWT.hs%23L63-L82&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>指定のエンドポイントへ 生成した JWT を使って以下のようなリクエストを投げれば, チャネルアクセストークンが発行される.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2Fc0c766a480e3ecd117be2c3e4045b80382dd5cd7%2Fsrc%2FLBKiirotori%2FAccessToken%2FCore.hs%23L73-L83&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p><a href="https://developers.line.biz/ja/reference/messaging-api/#issue-channel-access-token-v2.1-response">レスポンス</a>には発行されたチャネルアクセストークンの他にキー ID や有効期限が切れるまでの秒数等が含まれている. 本実装においては, 予め有効期限を時刻に変換したりキー ID を含めたり等して Redis に保存するようにしている. アクセストークンを使用する際は, 有効なアクセストークンが保管できている場合そのキーを流用し, そうでなければ再度取得する. 概ね, ドキュメント記載の下図の構造となっている.</p>
<figure>
<img src="/roki.log/2022/04/10/LineBotDevelopment/using_keyID_procedure_01.75272508.png" alt /><figcaption>チャネルアクセストークンの管理, <a href="https://developers.line.biz/ja/docs/messaging-api/generate-json-web-token/#issue_a_channel_access_token_v2_1">LINE Developers</a> から引用</figcaption>
</figure>
<h3 id="生のリクエストボディを-servant-で扱う">生のリクエストボディを Servant で扱う</h3>
<p>リクエストが LINE プラットフォームから送信されたことを検証するためには, チャネルシークレットを秘密鍵とした HMAC-SHA256 アルゴリズムによるリクエストボディのダイジェスト値を Base64 エンコードした値と, リクエストヘッダーに含まれる <code>x-line-signature</code> の値を比較する<a href="/roki.log/2022/04/10/LineBotDevelopment/#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. 今回 Bot の WEB API 開発に <a href="https://hackage.haskell.org/package/servant">servant</a> というライブラリを用いているが, 便利なことに API の定義で <code>ReqBody '[JSON] B.ByteString</code> とすると, データ型に落とし込まれた状態でリクエストボディを扱うことができる. しかし, 今回のように<strong>生のリクエストボディを扱いたい</strong>場合は余計なお世話であったので, 以下のように生のリクエストボディを扱うための型を新たに定義して使用した.</p>
<div class="mt-2 mb-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2F43bb4c381b8c86520866af68ac50eecf0806e761%2Fsrc%2FLBKiirotori%2FWebhook%2FCore.hs%23L85-L110&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p><a href="https://stackoverflow.com/a/67912095/8345717">SO に同様の Q.A. がある</a>がこの回答には具体的な実装例が記載されていなかったので, 上述のとおり記載することとした.</p>
<h3 id="起動と停止の制御">起動と停止の制御</h3>
<p>ボットの動作は下記のように systemd ユニットとして管理することとした.</p>
<div class="mt-2 mb-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2Fmain%2Fetc%2Fsystemd%2Fline-bot-kiirotori.service&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>nginx の再起動や <code>sites-available</code>, <code>sites-enable</code> への一連の処理も含めてしまうことでサービスとしての管理を簡素なものとして完結させることができる. 欲をいうと, LINE Developers コンソールの Webhook 設定画面では Webhook 利用のオン/オフを切り替えることができるようになっているが, 例えばこれに対する WEB API でもあれば, 起動時に API を叩いてオン, 停止時に API を叩いてオフというふうにしたかったところであるが, 現状 LINE 社はこれに対する API 提供しているか, 定かでなかった.</p>
<blockquote class="twitter-tweet tw-align-center">
<p lang="ja" dir="ltr">
LINE Messagin API, Webhook URL を設定する API はあるんだけど, Webhook の有効/無効を切り替える API はないのかな
</p>
— Roki (@530506) <a href="https://twitter.com/530506/status/1474654997212430340?ref_src=twsrc%5Etfw">December 25, 2021</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h2 id="簡易認証">簡易認証</h2>
<p><a href="https://www.linebiz.com/jp/service/line-official-account/account-type/">LINE 公式アカウントのアカウント種別</a>に記載があるように, 未認証アカウントは LINE アプリ内の検索結果に露出されることはない. 従って, 認証しない限り勝手に検索された上で使われるといったことは起こらない. しかし, 同じグループ内に所属して友達追加し, 他のグループに招待するといった使い方で他ユーザが勝手に使用することはできてしまう. よって, 特定グループ内のみで使用できるよう制限するためには何らかの認証の仕組みが必要である. これに伴い, 今回は 1 対 1 のトークルーム, グループ, ルーム (<span class="math inline">\fallingdotseq</span> グループ<a href="/roki.log/2022/04/10/LineBotDevelopment/#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>) のいずれにおいてもまず第一に認証に成功しなければボットの全ての機能を利用できない仕組みをつくった. といってもその仕組みは一定間隔でランダムに文字列を生成, redis に書き込み, その文字列と合致するか否かで認証判定するという非常に簡素なものである. 以下にその認証文字列の生成機構の部分を抜粋して記載する.</p>
<div id="tabs" class="tabs is-toggle is-boxed is-centered mb-0">
<ul>
<li class="is-active" data-tab="1">
<a> <span class="icon is-small"><i class="fas fa-file-code fa-fw"></i></span> <span>line-bot-kiirotori/docker/redis/Dockerfile</span> </a>
</li>
<li data-tab="2">
<a> <span class="icon is-small"><i class="fas fa-file-code fa-fw"></i></span> <span>line-bot-kiirotori/docker/redis/crontab</span> </a>
</li>
<li data-tab="3">
<a> <span class="icon is-small"><i class="fas fa-file-code fa-fw"></i></span> <span>line-bot-kiirotori/docker/redis/get-pin-code.sh</span> </a>
</li>
<li data-tab="4">
<a> <span class="icon is-small"><i class="fas fa-file-code fa-fw"></i></span> <span>line-bot-kiirotori/docker/redis/set-pin-code.sh</span> </a>
</li>
<li data-tab="5">
<a> <span class="icon is-small"><i class="fas fa-file-code fa-fw"></i></span> <span>line-bot-kiirotori/docker/redis/start.sh</span> </a>
</li>
</ul>
</div>
<div id="tab-content" class="mb-2" style="max-height: 400px; overflow-y: scroll;">
<div class="is-active acontent" data-content="1">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2F62a6c47072dbeb9a5897c486ee3d081465412d07%2Fdocker%2Fredis%2FDockerfile&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<div class="acontent" data-content="2">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2F62a6c47072dbeb9a5897c486ee3d081465412d07%2Fdocker%2Fredis%2Fcrontab&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<div class="acontent" data-content="3">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2F62a6c47072dbeb9a5897c486ee3d081465412d07%2Fdocker%2Fredis%2Fget-pin-code.sh&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<div class="acontent" data-content="4">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2F62a6c47072dbeb9a5897c486ee3d081465412d07%2Fdocker%2Fredis%2Fset-pin-code.sh&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<div class="acontent" data-content="5">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2F62a6c47072dbeb9a5897c486ee3d081465412d07%2Fdocker%2Fredis%2Fstart.sh&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
</div>
<script type="text/javascript" src="/js/uniq_tab.js"></script>
<p>この仕組み上 redis が動いているホストに SSH 接続できなければ生成されるランダム文字列を取得できないので, ボット機能の使用可否は SSH 認証が担保することとなる.</p>
<h2 id="指定時間実行">指定時間実行</h2>
<p>指定時間に決まったプッシュメッセージを送りたいといったことは割とあるので, それを実現する機能についても実装してみた. 実行内容は, 下記のように crontab の亜種のような形式でファイルに記載して定義する.</p>
<div class="mt-2 mb-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2F6efc35754150917de47bdf5ef3a56e4d81322098%2FREADME.md%3Fplain%3D1%23L78-L80&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>この定義には crontab のように変数を使用することもできる. 実装は, <a href="https://hackage.haskell.org/package/cron">cron パッケージ</a>により提供されているパーサと, パーサコンビネータの組み合わせにより成っている.</p>
<div class="mt-2 mb-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fline-bot-kiirotori%2Fblob%2F6efc35754150917de47bdf5ef3a56e4d81322098%2Fsrc%2FLBKiirotori%2FSchedule%2FParser.hs%23L178-L190&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<h2 id="結">結</h2>
<p>基盤作りはできたので, 追って色々と Bot として便利そうな機能を追加していきたい.</p>
<figure>
<img src="/roki.log/2022/04/10/LineBotDevelopment/ss.jpg" title="自作LINE Botの基本動作の様子" width="280" alt /><figcaption>自作 LINE Bot の基本動作の様子</figcaption>
</figure>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Bot 自体の話題とは逸れてしまうが, OCI 無料枠のインスタンスにつくグローバル IP アドレスは静的にできないようであった (要検証ー) ので, <a href="https://ddns.kuku.lu/">DDNS Now</a> をつかっていたが, ふと契約済みである Google Domains をよく確認してみると, DDNS の機能もついていたことを知った. 適当に更新のためのシェルスクリプトを書こうと考えていたが, <a href="https://github.com/ddclient/ddclient">ddclient</a> という便利なツールを発見したので, こちらを利用することとした.<a href="/roki.log/2022/04/10/LineBotDevelopment/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://meet.jit.si/" class="uri">https://meet.jit.si/</a><a href="/roki.log/2022/04/10/LineBotDevelopment/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><code>_acme-challenge</code> の問い合わせだけ手元に用意した DNS に向けて, その DNS を更新するようにし, 指定した TXT レコードを返せば良さそう<a href="/roki.log/2022/04/10/LineBotDevelopment/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>現在は 10 分としている<a href="/roki.log/2022/04/10/LineBotDevelopment/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>今回は <a href="https://github.com/lestrrat-go/jwx">jwx</a> というツールを使ってアサーション署名キーのキー (JSON Web Key, 以下 JWK) ペアを生成し, その秘密キーを適当な設定ファイル (toml) から読み込むようにした<a href="/roki.log/2022/04/10/LineBotDevelopment/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>LINE プラットフォームから送信されたということをさらに強固なものとするために, IP アドレスで制限でもかけられぬものかと見てみていたが, <a href="https://developers.line.biz/ja/faq/#what-is-ip-address-of-line-platform">そういったものの公開はしていない</a>とのことであった.<a href="/roki.log/2022/04/10/LineBotDevelopment/#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>LINE のルーム (複数人トーク) はグループトークに統合されている. c.f. <a href="https://guide.line.me/ja/friends-and-groups/create-groups.html" class="uri">https://guide.line.me/ja/friends-and-groups/create-groups.html</a><a href="/roki.log/2022/04/10/LineBotDevelopment/#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>技術書典 11 にて Git (一部) を自作する記事を執筆した</title>
    <link href="https://roki.dev/roki.log/2021/07/10/SelfMadeTinyGit/index.html" />
    <id>https://roki.dev/roki.log/2021/07/10/SelfMadeTinyGit/index.html</id>
    <published>2021-07-10T16:14:17Z</published>
    <updated>2021-07-10T16:14:17Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://techbookfest.org/event/tbf11">技術書典 11</a> に出展の <a href="https://techbookfest.org/product/6185615265628160">KLab Tech Book Vol.8</a> 第七章にて『ミニマル Git を自作しよう』という記事を執筆した. <br /> 技術書典 11 オンラインマーケットから電子 + 物理本セットは 1000 円, 電子版のみは無料で頒布されている.</p>
<figure>
<img src="/roki.log/2021/07/10/SelfMadeTinyGit/tbf11.png" width="250" alt /><figcaption><a href="https://techbookfest.org/product/6185615265628160">KLab Tech Book Vol.8</a></figcaption>
</figure>
<p>この本に関する公式的な案内は『<a href="https://www.klab.com/jp/blog/tech/2021/tbf11.html">技術書典11で同人誌を頒布します &amp; 既刊PDFダウンロードページ</a>』にて掲載中である. 本記事は, その記事執筆に関するレポートである.<br></p>
<!--more-->
<p>なお, このブログは個人ブログであり, また注意書きとして, 既にサイトトップ部分で</p>
<blockquote>
<p>All opinions expressed by Author on this blog is solely Author’s opinions and do not reflect the opinions of the company to which I belong.</p>
</blockquote>
<p>と示しているので言うまでもないことではあるのだが, 記事の特性上, 社名が文章内に含まれることとなるため, ここにあらためて明示する. <strong>ここに示された意見や感想等は, 私個人のものであり, 所属する組織を代表するものではない.</strong></p>
<h2 id="内容について">内容について</h2>
<p>大雑把に言えば, これを読むと, Git の内部構造 (Git オブジェクトモデル, インデックス, データ構造) を理解し, インデックス化からコミットまでの主要コマンド 8 つ (<code>add</code>, <code>cat-file</code>, <code>diff</code>, <code>hash-object</code>, <code>init</code>, <code>ls-files</code>, <code>status</code>, <code>commit</code>) を実装できるようになるはず (?) の内容となっている. Git にまつわる各種概念や用語, 仕様等の紹介を通じて, 概形を把握し, その後, 詳細な実装に立ち入っていく. 実装例の説明自体には Haskell を用いているが, それほど技巧的なことはしていないつもりであるので, 拒絶反応をせずに, むしろ, それなりに簡素な作りで実際に動かすことができるという点に着目していただけると嬉しい.</p>
<div class="has-text-centered mt-3 mb-3">
<p><i class="fab fa-github fa-fw"></i> <a href="https://github.com/falgon/hmgit">falgon/hmgit - HMGit (Haskell Minimal Git)</a></p>
</div>
<p>実行例やオプション等の説明はすべて README に載っている. 実装をもし読む場合は, その参考になればと <a href="https://falgon.github.io/hmgit/">Haddock</a> も一応生成しておいた. コードや設計についてはとくにここで新たに述べることもないので, 上記 KLab Tech Book Vol.8 やリポジトリの中身を確認してほしい.</p>
<blockquote class="twitter-tweet" data-align="center">
<p lang="ja" dir="ltr">
無駄にこんな感じで遊べます <a href="https://t.co/L0vtu8fOpy">pic.twitter.com/L0vtu8fOpy</a>
</p>
— Roki (@530506) <a href="https://twitter.com/530506/status/1413741996783534083?ref_src=twsrc%5Etfw">July 10, 2021</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>私の書いた記事では, 出来る限り図を挿入し, Git にまつわる各種概念やコミット, ブランチ, リファレンスの関係を視覚的に捉えられるよう意識した. これは (文字情報だけでも Git について理解することはできるのだろうが), それら概念の関係図を頭の中で描いてみようとするときに発生するコストを抑えられるはずなので, 積極的に行った. また, 記事の執筆過程での下調べ中に知った Git に関する細かい経緯や, 実装するにあたって若干ハマるかもしれないファイルモード等に関する話題等, 所々にニッチ (?) な内容のコラムを挿入するようにした. 書かれているコマンドについては, ページの進みにあわせて実行していくことができるようになっているはずである.</p>
<h2 id="結">結</h2>
<p>このような発出をしていくことは個人的にも好きなので, またの機会があれば続けていきたい. 個人的にはぜひ一読いただき, なにかリアクション等いただけると嬉しい. そして, サンプル実装や文章構成への改善案, また, もし間違い等に気付いた場合についても指摘をいただけると嬉しい.<br> 最後に, このような機会を設けてくださった各所関係者の皆様や, 私の文章の校生, レビュー等に関わってくださった共著者のみなさまへ, 改めてこの場を借りて感謝の念を表したい.</p>
<h2 id="関連">関連</h2>
<ul>
<li><a href="https://www.klab.com/jp/blog/tech/2021/20211209-techbook8-git.html">KLab Tech Book Vol. 8 で Git (一部) を自作する章を書きました - KLablog</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>C++ テンプレートメタプログラミングによるコンパイル時 Lazy K インタプリタ</title>
    <link href="https://roki.dev/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/index.html" />
    <id>https://roki.dev/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/index.html</id>
    <published>2020-12-16T00:00:00Z</published>
    <updated>2020-12-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>※1. この記事は「<a href="https://qiita.com/advent-calendar/2020/klab">KLab Engineer Advent Calendar 2020</a>」の 16 日目にエントリしています<br> ※2. 普段のこのブログの文体は常体ですが, 本記事においては Advent Calendar 用に敬体を使用します</p>
<figure>
<img src="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/11721476176_991181199b_w.jpg" alt /><figcaption>Yellow duck Christmas ornament - <a href="https://www.flickr.com/photos/39908901@N06/">m01229</a>, <a href="https://creativecommons.org/licenses/by/2.0/">Attribution 2.0 Generic (CC BY 2.0)</a></figcaption>
</figure>
<h2 id="はじめに">はじめに</h2>
<p>この記事の公開日の 1 日前<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>に, プログラミング言語 C++ の新バージョン ISO/IEC 14882:2020, 通称 C++20 が国際標準として公開されました. これにより, いくつかの新しい言語機能や標準ライブラリが追加されます. その中でも, とくにコンセプトという言語機能は, テンプレートメタプログラミングが話題として盛んであった時代<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>から待望されていた言語機能のうちの 1 つなのではないでしょうか. この標準化によって, C++17 までで行う必要のあった多くの型制約のためのテンプレートメタプログラミングは, よりそれ専用の言語機能であるコンセプトを使う形に置き換えられるであろうと思われます. そのようなわけで, 今後徐々に出番を失っていくであろうテンプレートメタプログラミングを将来懐かしめるよう (?), テンプレートメタプログラミングによってコンパイル時に Lazy K ソースコードをパースして評価するインタプリタのようなものを書いてみました. 本記事では, これに関する実装と理論について紹介します. (型無し <span class="math inline">\lambda</span> 計算について既知のものとします)</p>
<!--more-->
<h2 id="lazy-k-とは">Lazy K とは</h2>
<p>そもそも Lazy K がどのような言語であるかについては, 既にインターネット上に数多くの説明がありますので, ここでは簡潔に取り上げることとします (<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#ref-7">参考文献 7</a>). この説明には <span class="math inline">\lambda</span> 式が使われますので, 先に本記事で扱われる <span class="math inline">\lambda</span> 式の定義を以下の BN 式で与えることとします.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span class="math inline">\lambda</span> 式
</p>
</header>
<div class="m-def-content">
<p><span class="math display">\begin{array}{ccc}
\langle\text{変数}\rangle&amp;::=&amp;v_n\\
\langle\lambda\text{式}\rangle&amp;::=&amp;\langle\text{変数}\rangle\mid\left(\langle\lambda\text{式}\rangle\langle\lambda\text{式}\rangle\right)\mid\left(\lambda\langle\text{変数}\rangle .\langle\lambda\text{式}\rangle\right)
\end{array}</span></p>
</div>
</div>
<p>ここで, 以下の略記法について許可するものとします. 任意の <span class="math inline">\lambda</span> 式 <span class="math inline">M_n</span> について</p>
<p><span class="math display">\begin{array}{ccc}
M_1M_2M_3\cdots M_n&amp;:=&amp;\left(\left(\cdots\left(\left(M_1M_2\right)M_3\right)\cdots\right)M_n\right)\\
\lambda v_1v_2\cdots v_n.M&amp;:=&amp;\lambda v_1.\left(\lambda v_2.\left(\cdots\left(\lambda v_n.M\right)\cdots\right)\right)
\end{array}</span></p>
<p>Lazy K は入力として自然数のリストを受け取り, 以下に定義される <span class="math inline">\lambda</span> 式 <span class="math inline">\mathrm{S},\mathrm{K},\mathrm{I}</span> の組み合わせ/計算によって自然数のリストを返すプログラム言語のことです.</p>
<p><span class="math display">\begin{array}{lcl}
\mathrm{S}&amp;:=&amp;\lambda v_1v_2v_3.(v_1v_3)(v_2v_3)\\
\mathrm{K}&amp;:=&amp;\lambda v_1v_2.v_1\\
\mathrm{I}&amp;:=&amp;\lambda v_1.v_1
\end{array}</span></p>
<p>上記の通り Lazy K のソースコードは 1 つの <span class="math inline">\lambda</span> 式そのものです. “通常の” <span class="math inline">\lambda</span> 計算では束縛変数を使って <span class="math inline">\lambda</span> 抽象を定義するのに対し, 上記に定義された <span class="math inline">\mathrm{S},\mathrm{K},\mathrm{I}</span> のみによって束縛変数を使わずに <span class="math inline">\lambda</span> 抽象と同等の仕組みを実現する, コンビネータ理論という体系があります. Lazy K はこのコンビネータ理論の計算機構を使って記述するチューリング完全な参照透過性を持つ関数型言語です. このコンビネータ理論が <span class="math inline">\lambda</span> 抽象と同等の仕組みを実現できることに関する証明についてここでは省略しますが, その方法の 1 つとしては, 例えばコンビネータ理論が扱う式の構造に関する帰納法によるもので可能であることがわかっています.</p>
<h2 id="lazy-k-の処理系の設計">Lazy K の処理系の設計</h2>
<p>Lazy K のプログラムを実行するときの大まかな処理の内容は, 以下のような流れになります.</p>
<ol type="1">
<li>入力文字列 <span class="math inline">V</span> をチャーチ数のリスト <span class="math inline">V'</span> に変換する</li>
<li>ソースコードを <span class="math inline">\lambda</span> 式 <span class="math inline">E</span> として解釈する</li>
<li><span class="math inline">EV'</span> から得られる新たな <span class="math inline">\lambda</span> 式 <span class="math inline">E'</span> を得る</li>
<li><span class="math inline">E'</span> をチャーチ数のリストと見なし, 文字列に変換, 出力する</li>
</ol>
<p>今回行った実装では, この一連の流れを C++ テンプレートのインスタンス化によって行うために, まず <span class="math inline">\lambda</span> 計算を抽象構文木として扱うためのノードについて, 以下のように定義しています.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fmpl-lazyk%2Fblob%2Fabe9289af6b781b5556b010f98c78d9207db2af8%2Fapp%2Fcombinators.hpp%23L8-L31&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p><span class="math inline">\lambda</span> 式の計算体系には <span class="math inline">\alpha</span> 変換と呼ばれる変換規則が定められていますが, 入力されたソースコードから成る変数の名前 (すなわち文字) に対して この <span class="math inline">\alpha</span> 変換の処理を愚直に行っていくのは少々大変そうです. そこで, これを避けるために, <span class="math inline">\lambda</span> 式内の変数を自然数 (変数が自然数のある位置から何番目の <span class="math inline">\lambda</span> によって束縛されているか, どれだけ離れているか) で表現するようにします. これを <span class="math inline">\lambda</span> 式の de Bruijn index 化といい, それによって表される項を名無し項, もしくは de Bruijn index 項といいます<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. 以下は, 先に定義した <span class="math inline">\mathrm{S},\mathrm{K},\mathrm{I}</span> による例です. プログラムでの扱いを容易にするため, <span class="math inline">0</span> からのカウントによって表記しています.</p>
<p><span class="math display">\begin{array}{lcl}
\mathrm{S}&amp;\xrightarrow{\text{de Bruijn index}}&amp;\lambda\lambda\lambda2\ 0(1\ 0) \\
\mathrm{K}&amp;\xrightarrow{\text{de Bruijn index}}&amp;\lambda\lambda 1 \\
\mathrm{I}&amp;\xrightarrow{\text{de Bruijn index}}&amp;\lambda 0
\end{array}</span></p>
<p>これらは, それぞれ先に定義した型を用いて下記のように定義しています.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fmpl-lazyk%2Fblob%2Fabe9289af6b781b5556b010f98c78d9207db2af8%2Fapp%2Fcombinators.hpp%23L33-L38&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>続いて, 名無し項の <span class="math inline">\beta</span> 簡約について考えてみます. 例えば <span class="math inline">\left(\lambda\lambda 3\ 1\left(\lambda 0\ 2\right)\right)M</span> の <span class="math inline">\beta</span> 簡約について, 置換対象を <span class="math inline">\Box_n</span> として表記すると, <span class="math inline">\left(\lambda\lambda 3\Box_1\left(\lambda 0\Box_2\right)\right)M</span> になります. de Bruijn index の性質上, <span class="math inline">M</span> の内部の自由変数の index は, 置換対象からの <span class="math inline">\lambda</span> 式のネスト分追加されていなければなりません. いま, <span class="math inline">M=\left(\lambda 4\ 0\right)</span> としたとき, <span class="math inline">\Box_1</span> への置換結果は, <span class="math inline">\Box_1</span> の束縛位置から 1 つの <span class="math inline">\lambda</span> 式の下にあるため <span class="math inline">\left(\lambda 5\ 0\right)</span>, <span class="math inline">\Box_2</span> への置換結果は, <span class="math inline">\Box_2</span> の束縛位置から 2 つの <span class="math inline">\lambda</span> 式の下にあるため <span class="math inline">\left(\lambda 6\ 0\right)</span> となります (先に index のカウントを <span class="math inline">0</span> から始めるようにしたため, 置換対象の変数の index を <span class="math inline">n</span> としたとき, 置き換える側の <span class="math inline">\lambda</span> 式内のすべての自由変数の index へ単に <span class="math inline">n</span> を加えれば良くなっています).</p>
<p>また, <span class="math inline">M</span> への置き換えによって <span class="math inline">\lambda</span> のネストが一段なくなるので, 適用される <span class="math inline">\lambda</span> 式の自由変数はデクリメントされなければなりません. よって <span class="math inline">\lambda 2\Box_1\left(\lambda 0\Box_2\right)</span> という形になり, 結果として以下を得ます.</p>
<p><span class="math display">
\left(\lambda\lambda 3\ 1\left(\lambda 0\ 2\right)\right)\left(\lambda 4\ 0\right)\to_\beta
\lambda 2\left(\lambda 5\ 0\right)\left(\lambda 0\left(\lambda 6\ 0\right)\right)
</span></p>
<p>以上で行った自由変数のインデックスに対する操作をシフトといいます. 上記では, <span class="math inline">\lambda</span> 式を視覚的に捉えることで <span class="math inline">\beta</span> 簡約しましたが (プログラムでの扱いを容易とするため) これをより形式的に定義することを考えます. これには, まず項の内部のどの変数が自由変数であるかを識別する必要がありますが, 束縛変数は常に項の最小のインデックスを構成する<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>ので, この性質を利用することとします.</p>
<p>いま, 自由変数が持つ可能性のある最小のインデックスを <span class="math inline">c</span> とし, シフトを以下の関数によって定義します (<span class="math inline">c</span> はしばしばカットオフといわれます).</p>
<div class="m-def">
<header class="m-def-title">
<p>
シフト関数
</p>
</header>
<div class="m-def-content">
<p><span class="math display">\begin{array}{lcl}
\uparrow^d_c(i)&amp;=&amp;\begin{cases}i&amp;\left(i\lt c\right)\\ i+d&amp;\left(\text{otherwise}\right)\end{cases}\\
\uparrow^d_c(\lambda t)&amp;=&amp;\lambda \uparrow^d_{c+1}(t)\\
\uparrow^d_c(t_1\ t_2)&amp;=&amp;\uparrow^d_c(t_1)\uparrow^d_c(t_2)
\end{array}</span> ここで <span class="math display">\uparrow^d(t):=\uparrow^d_0(t)</span></p>
</div>
</div>
<p><span class="math inline">c</span> によって, 束縛子による深さをカウントアップしていますが, 任意の項 <span class="math inline">t</span> の内部における任意の識別子 <span class="math inline">i</span> について, de Bruijn index の定義から <span class="math inline">i\lt c</span> となるものは束縛されていると分かります. よって, それ以外のものは自由変数なので, (<span class="math inline">d</span> を加えることで) インデックスを操作します. シフトが定義できたので, 項 <span class="math inline">i</span> の識別子 <span class="math inline">j</span> の項 <span class="math inline">t</span> への置換 <span class="math inline">\left[j\mapsto t\right]i</span> を以下のように定義できます.</p>
<div class="m-def">
<header class="m-def-title">
<p>
置換
</p>
</header>
<div class="m-def-content">
<p><span class="math display">\begin{array}{lcl}
\left[j\mapsto t\right]i&amp;=&amp;\begin{cases}t&amp;\left(i=j\right)\\ i&amp;\left(\text{otherwise}\right)\end{cases}\\
\left[j\mapsto t\right]\lambda t'&amp;=&amp;\lambda\left[j+1\mapsto\uparrow^1(t)\right]t'\\
\left[j\mapsto t\right]t_1\ t_2&amp;=&amp;\left[j\mapsto t\right]t_1\ \left[j\mapsto t\right]t_2
\end{array}</span></p>
</div>
</div>
<p>束縛子を通る度に元の置き換え対象はその内側で 1 つシフトされているはずで, また, 置かれる項は, それが置かれる項の束縛子の個数分シフトされていなければなりません. これらの手続きをしつつ, それが置き換える対象そのものであったときに置き換えます. 以上の定義を使って, 以下に名無し項の <span class="math inline">\beta</span> 簡約を定義します.</p>
<div class="m-def">
<header class="m-def-title">
<p>
名無し項の <span class="math inline">\beta</span> 簡約
</p>
</header>
<div class="m-def-content">
<p><span class="math display">(\lambda t_1)t_2 =\uparrow^{-1}\left(\left[0\mapsto\uparrow^1(t_2)\right]t_1\right)</span></p>
</div>
</div>
<p><span class="math inline">t_1</span> に対して置換する前に, 置換される <span class="math inline">t_2</span> は <span class="math inline">t_1</span> の内部にくる関係上, <span class="math inline">\lambda</span> のネストが 1 つ増加されるため, 1 を加えるシフトを行う必要があります (<span class="math inline">t_1</span> は <span class="math inline">t_2</span> よりもより大きな文脈で定義されているため, とも言えます). また, 先に直感的に <span class="math inline">\beta</span> 簡約をした際にも考慮したように, 置換によって <span class="math inline">\lambda</span> のネストがなくなりますので, その分の負のシフトをします. 例えば, 先に直感的に求めた <span class="math inline">\left(\lambda\lambda 3\ 1\left(\lambda 0\ 2\right)\right)\left(\lambda 4\ 0\right)</span> の <span class="math inline">\beta</span> 簡約は以下のように計算できます.</p>
<p><span class="math display">\begin{array}{lcl}
\left(\lambda\lambda 3\ 1\left(\lambda 0\ 2\right)\right)\left(\lambda 4\ 0\right)&amp;\to_\beta&amp;\uparrow^{-1}\left(\left[0\mapsto\uparrow^1\left(\lambda 4\ 0\right)\right]\lambda 3\ 1\left(\lambda 0\ 2\right)\right)\\
&amp;=&amp;\uparrow^{-1}\left(\left[0\mapsto(\lambda 5\ 0)\right]\lambda 3\ 1\left(\lambda 0\ 2\right)\right)\\
&amp;=&amp;\uparrow^{-1}\left(\lambda\left[1\mapsto\left(\lambda 6\ 0\right)\right]3\ 1\left(\lambda 0\ 2\right)\right)\\
&amp;=&amp;\uparrow^{-1}\left(\lambda\left[1\mapsto\left(\lambda 6\ 0\right)\right]3\ \left[1\mapsto\left(\lambda 6\ 0\right)\right]1\ \left(\lambda 0\ 2\right)\right)\\
&amp;=&amp;\uparrow^{-1}\left(\lambda 3\left(\left[1\mapsto\left(\lambda 6\ 0\right)\right]1\ \left[1\mapsto\left(\lambda 6\ 0\right)\right]\left(\lambda 0\ 2\right)\right)\right)\\
&amp;=&amp;\uparrow^{-1}\left(\lambda 3\left(\lambda 6\ 0\right)\left(\lambda\left[2\mapsto\left(\lambda 7\ 0\right)\right]0\ 2\right)\right)\\
&amp;=&amp;\uparrow^{-1}\left(\lambda 3\left(\lambda 6\ 0\right)\left(\lambda\left[2\mapsto\left(\lambda 7\ 0\right)\right]0\ \left[2\mapsto\left(\lambda 7\ 0\right)\right]2\right)\right)\\
&amp;=&amp;\uparrow^{-1}\left(\lambda 3\left(\lambda 6\ 0\right)\left(\lambda 0\ \left(\lambda 7\ 0\right)\right)\right)\\
&amp;=&amp;\lambda 2\left(\lambda 5\ 0\right)\left(\lambda 0\left(\lambda 6\ 0\right)\right)
\end{array}</span></p>
<p>以上が, 名無し項の <span class="math inline">\beta</span> 簡約に関する形式的な定義となります. また, 今回の処理系全体の実装としては, 以下のようになっています.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fmpl-lazyk%2Fblob%2Fabe9289af6b781b5556b010f98c78d9207db2af8%2Fapp%2Fevaluate.hpp&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<h2 id="パーサコンビネータ">パーサコンビネータ</h2>
<p>ここからは, パーサの実装の話題に移ります. 構文解析の有名な手法の 1 つとしては, モナディックなパーサコンビネータをつくるといったことが挙げられます. 単純なパーサコンビネータの最低限必要な機能を考えると, 未処理の入力文字列の状態と, その入力文字列に対する異常性を管理できればよいでしょう. このように考えると, 状態モナド変換子と Either モナドを合成することでうまく扱えそうです. これに従い, 今回の実装では <code>state_transformer</code> と <code>either</code> を実装し, それらの合成をラップする形で必要最低限のパーサーコンビネータを作っています (mpl-lazyk/mlk/text/parsec.hpp). mpl-lazyk/tests/text/parsec.cpp は, この実装に対するユニットテストですが, その使用例として見ることもできるので, そのような意図で下記に掲載します.</p>
<div id="tabs" class="tabs is-toggle is-boxed is-centered mb-0">
<ul>
<li class="is-active" data-tab="1">
<a> <span class="icon is-small"><i class="fas fa-file-code fa-fw"></i></span> <span>mpl-lazyk/mlk/text/parsec.hpp</span> </a>
</li>
<li data-tab="2">
<a> <span class="icon is-small"><i class="fas fa-file-code fa-fw"></i></span> <span>mpl-lazyk/tests/text/parsec.cpp</span> </a>
</li>
</ul>
</div>
<div id="tab-content" class="mb-3" style="height: 400px; overflow-y: scroll;">
<div class="is-active acontent" data-content="1">
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fmpl-lazyk%2Fblob%2Fabe9289af6b781b5556b010f98c78d9207db2af8%2Fmlk%2Ftext%2Fparsec.hpp&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
</div>
<div class="acontent" data-content="2">
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fmpl-lazyk%2Fblob%2Fabe9289af6b781b5556b010f98c78d9207db2af8%2Ftests%2Ftext%2Fparsec.cpp&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
</div>
</div>
<script type="text/javascript" src="/js/uniq_tab.js"></script>
<p><code>state_transformer</code> と <code>either</code> の合成はモナドなので, スコープ解決演算子 <code>::</code> でメソッドチェインのように記述できます. 2 つのアクションを順番に実行し, 最初のアクションで生成された値を 2 番目のアクションに渡す <code>bind</code>, <code>bind</code> と同様ですが, 最初のアクションの値を捨てる <code>dbind</code>, モナドの型に値を包む <code>eta</code> を基本として, その他パーサを容易に記述するための“便利な型”をいくつか定義しています. ここで, <code>bind</code>, <code>dbind</code>, <code>eta</code> 以外のそれら“便利な型”は, 最初のアクションの値を捨てるという動作で統一しています. つまり, 以下のテストで示されるように, <code>::dbind&lt;便利な型&gt;</code> と <code>::便利な型</code> は等価な関係にあります.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fmpl-lazyk%2Fblob%2Fabe9289af6b781b5556b010f98c78d9207db2af8%2Ftests%2Ftext%2Fparsec.cpp%23L467-L503&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>なお, 実装における各命名については, Haskell や圏論にインスパイアされた形式をとっています (例えば, <code>eta</code> は圏論の <span class="math inline">\eta</span> など).</p>
<h2 id="c-テンプレートと遅延評価">C++ テンプレートと遅延評価</h2>
<p>C++ テンプレートはチューリング完全な純粋関数型言語<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>であり, うまくテンプレートのインスタンス化のタイミングを制御することで, いわゆる遅延評価的な評価戦略によって計算させることができます. 例を 1 つ挙げましょう. 説明の便宜上, まず以下のようなモノを定義します.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb1-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;</span>
<span id="cb1-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb1-2" aria-hidden="true"></a><span class="kw">struct</span> <span class="dt">def_type</span> : <span class="bu">std::</span>enable_if&lt;<span class="kw">true</span>, T&gt; {};</span>
<span id="cb1-3"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb1-4" aria-hidden="true"></a><span class="kw">struct</span> left;</span>
<span id="cb1-5"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb1-5" aria-hidden="true"></a><span class="kw">struct</span> right;</span>
<span id="cb1-6"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb1-6" aria-hidden="true"></a><span class="kw">struct</span> nothing;</span></code></pre></div>
<p>ここで, あるコンパイル時定数 <code>value</code> が参照可能な 2 つのメタ関数についての論理和, すなわち左辺が真のときに <code>left</code>, 右辺が真のときに <code>right</code>, どちらも真でないときに <code>nothing</code> を返す 2 項メタ関数 <code>lor</code> を考えます. インスタンス化のタイミングに関して何の考慮もしていない実装は, 例えば, 以下のようなものが挙げられるでしょう.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;</span>
<span id="cb2-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-2" aria-hidden="true"></a><span class="kw">struct</span> lor</span>
<span id="cb2-3"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-3" aria-hidden="true"></a>    : <span class="bu">std::</span>conditional&lt;</span>
<span id="cb2-4"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-4" aria-hidden="true"></a>        Lhs::value,</span>
<span id="cb2-5"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-5" aria-hidden="true"></a>        left,</span>
<span id="cb2-6"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-6" aria-hidden="true"></a>        <span class="bu">std::</span>conditional_t&lt;</span>
<span id="cb2-7"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-7" aria-hidden="true"></a>            Rhs::value,</span>
<span id="cb2-8"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-8" aria-hidden="true"></a>            right,</span>
<span id="cb2-9"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-9" aria-hidden="true"></a>            nothing</span>
<span id="cb2-10"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-10" aria-hidden="true"></a>        &gt;</span>
<span id="cb2-11"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-11" aria-hidden="true"></a>    &gt; {};</span>
<span id="cb2-12"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-12" aria-hidden="true"></a></span>
<span id="cb2-13"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-13" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;</span>
<span id="cb2-14"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb2-14" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">lor_t</span> = <span class="kw">typename</span> lor&lt;Lhs, Rhs&gt;::type;</span></code></pre></div>
<p>これでも問題はなさそうです. 実際, 以下のようにテストしてみると, うまくいっているように見えます.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb3-1" aria-hidden="true"></a><span class="kw">static_assert</span>(</span>
<span id="cb3-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb3-2" aria-hidden="true"></a>    <span class="bu">std::</span>conjunction_v&lt;</span>
<span id="cb3-3"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb3-3" aria-hidden="true"></a>        <span class="bu">std::</span>is_same&lt;<span class="dt">lor_t</span>&lt;<span class="bu">std::</span>true_type, <span class="bu">std::</span>true_type&gt;, left&gt;,      <span class="co">// OK</span></span>
<span id="cb3-4"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb3-4" aria-hidden="true"></a>        <span class="bu">std::</span>is_same&lt;<span class="dt">lor_t</span>&lt;<span class="bu">std::</span>false_type, <span class="bu">std::</span>true_type&gt;, right&gt;,    <span class="co">// OK</span></span>
<span id="cb3-5"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb3-5" aria-hidden="true"></a>        <span class="bu">std::</span>is_same&lt;<span class="dt">lor_t</span>&lt;<span class="bu">std::</span>false_type, <span class="bu">std::</span>false_type&gt;, nothing&gt;  <span class="co">// OK</span></span>
<span id="cb3-6"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb3-6" aria-hidden="true"></a>    &gt;</span>
<span id="cb3-7"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb3-7" aria-hidden="true"></a>);</span></code></pre></div>
<p>では, ここで, このメタ関数 <code>lor</code> に与える引数を以下のように変更するとどうなるでしょうか.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb4-1" aria-hidden="true"></a><span class="kw">struct</span> X;</span>
<span id="cb4-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb4-2" aria-hidden="true"></a><span class="kw">static_assert</span>(<span class="bu">std::</span>is_same_v&lt;<span class="dt">lor_t</span>&lt;<span class="bu">std::</span>true_type, X&gt;, left&gt;); <span class="co">// NG</span></span></code></pre></div>
<p>残念ながら, これはコンパイルに失敗します. <code>X</code> が定義されていないからです. 不完全なクラス型に関する言及, N4659 § 17.7.1:</p>
<blockquote>
<p>If a class template has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type ([basic.types]).</p>
</blockquote>
<p>直感的には, 左辺が真である時点でもう右辺の評価をする必要はないので, <code>X</code> がどうであろうと, ここでは <code>left</code> が返ってきてほしいところですが, <code>std::conditional</code> では, 普通のプログラミング言語で行われるような論理演算に関する short circuit 的な評価は行われません. 与えられた引数はすべて積極評価されます. この問題は, 左辺の状態に関わらず右辺の <code>::type</code> を参照してしまうこと, すなわち, 右辺のクラス型の完全性がプログラムのセマンティックスに影響を与えるよう, 実装してしまっていることに起因します. クラス型の完全性に関する言及, N4659 § 17.7.1:</p>
<blockquote>
<p>Unless a class template specialization has been explicitly instantiated or explicitly specialized, the class template specialization is implicitly instantiated when the specialization is referenced in a context that requires a completely-defined object type or when the completeness of the class type affects the semantics of the program.</p>
</blockquote>
<p>したがって, それを回避するために, テンプレートの特殊化, SFINAE を利用して, 段階的にインスタンス化を実行させるようにします<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;</span>
<span id="cb5-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-2" aria-hidden="true"></a><span class="kw">class</span> lor {</span>
<span id="cb5-3"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-3" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span>, <span class="kw">class</span> = <span class="dt">void</span>&gt;</span>
<span id="cb5-4"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-4" aria-hidden="true"></a>    <span class="kw">struct</span> lor_base2 : <span class="dt">def_type</span>&lt;nothing&gt; {};</span>
<span id="cb5-5"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-5" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span> R&gt;</span>
<span id="cb5-6"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-6" aria-hidden="true"></a>    <span class="kw">struct</span> lor_base2&lt;R, <span class="bu">std::</span>enable_if_t&lt;R::value&gt;&gt; : <span class="dt">def_type</span>&lt;right&gt; {};</span>
<span id="cb5-7"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-7" aria-hidden="true"></a></span>
<span id="cb5-8"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-8" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span>, <span class="kw">class</span> R, <span class="kw">class</span> = <span class="dt">void</span>&gt;</span>
<span id="cb5-9"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-9" aria-hidden="true"></a>    <span class="kw">struct</span> lor_base1 : lor_base2&lt;R&gt; {};</span>
<span id="cb5-10"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-10" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span> L, <span class="kw">class</span> R&gt;</span>
<span id="cb5-11"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-11" aria-hidden="true"></a>    <span class="kw">struct</span> lor_base1&lt;L, R, <span class="bu">std::</span>enable_if_t&lt;L::value&gt;&gt; : <span class="dt">def_type</span>&lt;left&gt; {};</span>
<span id="cb5-12"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-12" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb5-13"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-13" aria-hidden="true"></a>    <span class="kw">typedef</span> <span class="kw">typename</span> lor_base1&lt;Lhs, Rhs&gt;::type type;</span>
<span id="cb5-14"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-14" aria-hidden="true"></a>};</span>
<span id="cb5-15"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-15" aria-hidden="true"></a></span>
<span id="cb5-16"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-16" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;</span>
<span id="cb5-17"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-17" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">lor_t</span> = <span class="kw">typename</span> lor&lt;Lhs, Rhs&gt;::type;</span>
<span id="cb5-18"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-18" aria-hidden="true"></a></span>
<span id="cb5-19"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-19" aria-hidden="true"></a><span class="kw">struct</span> X;</span>
<span id="cb5-20"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-20" aria-hidden="true"></a><span class="kw">static_assert</span>(</span>
<span id="cb5-21"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-21" aria-hidden="true"></a>    <span class="bu">std::</span>conjunction_v&lt;</span>
<span id="cb5-22"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-22" aria-hidden="true"></a>        <span class="bu">std::</span>is_same&lt;<span class="dt">lor_t</span>&lt;<span class="bu">std::</span>true_type, X&gt;, left&gt;,       <span class="co">// OK</span></span>
<span id="cb5-23"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-23" aria-hidden="true"></a>        <span class="bu">std::</span>is_same&lt;<span class="dt">lor_t</span>&lt;<span class="bu">std::</span>false_type, X&gt;, nothing&gt;,   <span class="co">// OK</span></span>
<span id="cb5-24"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-24" aria-hidden="true"></a>        <span class="bu">std::</span>is_same&lt;<span class="dt">lor_t</span>&lt;X, <span class="bu">std::</span>true_type&gt;, right&gt;,      <span class="co">// OK</span></span>
<span id="cb5-25"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-25" aria-hidden="true"></a>        <span class="bu">std::</span>is_same&lt;<span class="dt">lor_t</span>&lt;X, <span class="bu">std::</span>false_type&gt;, nothing&gt;,   <span class="co">// OK</span></span>
<span id="cb5-26"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-26" aria-hidden="true"></a>        <span class="bu">std::</span>is_same&lt;<span class="dt">lor_t</span>&lt;X, X&gt;, nothing&gt;                  <span class="co">// OK</span></span>
<span id="cb5-27"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-27" aria-hidden="true"></a>    &gt;</span>
<span id="cb5-28"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb5-28" aria-hidden="true"></a>);</span></code></pre></div>
<p>ここで上記の実装は, 以下のようなより一般的な遅延評価版 <code>conditional</code> メタ関数を用意してやることで, 全体として少し直感的な実装にできます.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">class</span> B, <span class="kw">class</span> L, <span class="kw">class</span> R&gt;</span>
<span id="cb6-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-2" aria-hidden="true"></a><span class="kw">class</span> conditional {</span>
<span id="cb6-3"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-3" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span>, <span class="kw">class</span>, <span class="kw">class</span> RR, <span class="kw">class</span> = <span class="dt">void</span>&gt;</span>
<span id="cb6-4"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-4" aria-hidden="true"></a>    <span class="kw">struct</span> conditional_base : <span class="dt">def_type</span>&lt;RR&gt; {};   </span>
<span id="cb6-5"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-5" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span> BB, <span class="kw">class</span> LL, <span class="kw">class</span> RR&gt;</span>
<span id="cb6-6"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-6" aria-hidden="true"></a>    <span class="kw">struct</span> conditional_base&lt;BB, LL, RR, <span class="bu">std::</span>enable_if_t&lt;BB::value&gt;&gt; : <span class="dt">def_type</span>&lt;LL&gt; {};</span>
<span id="cb6-7"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-7" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb6-8"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-8" aria-hidden="true"></a>    <span class="kw">typedef</span> <span class="kw">typename</span> conditional_base&lt;B, L, R&gt;::type type;</span>
<span id="cb6-9"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-9" aria-hidden="true"></a>};</span>
<span id="cb6-10"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-10" aria-hidden="true"></a></span>
<span id="cb6-11"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-11" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">class</span> B, <span class="kw">class</span> L, <span class="kw">class</span> R&gt;</span>
<span id="cb6-12"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-12" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">conditional_t</span> = <span class="kw">typename</span> conditional&lt;B, L, R&gt;::type;</span>
<span id="cb6-13"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-13" aria-hidden="true"></a></span>
<span id="cb6-14"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-14" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;</span>
<span id="cb6-15"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-15" aria-hidden="true"></a><span class="kw">struct</span> lor</span>
<span id="cb6-16"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-16" aria-hidden="true"></a>    : conditional&lt;</span>
<span id="cb6-17"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-17" aria-hidden="true"></a>        Lhs,</span>
<span id="cb6-18"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-18" aria-hidden="true"></a>        left,</span>
<span id="cb6-19"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-19" aria-hidden="true"></a>        <span class="dt">conditional_t</span>&lt;</span>
<span id="cb6-20"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-20" aria-hidden="true"></a>            Rhs,</span>
<span id="cb6-21"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-21" aria-hidden="true"></a>            right,</span>
<span id="cb6-22"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-22" aria-hidden="true"></a>            nothing</span>
<span id="cb6-23"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-23" aria-hidden="true"></a>        &gt;</span>
<span id="cb6-24"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-24" aria-hidden="true"></a>    &gt; {};</span>
<span id="cb6-25"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-25" aria-hidden="true"></a></span>
<span id="cb6-26"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-26" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;</span>
<span id="cb6-27"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb6-27" aria-hidden="true"></a><span class="kw">using</span> <span class="dt">lor_t</span> = <span class="kw">typename</span> lor&lt;Lhs, Rhs&gt;::type;</span></code></pre></div>
<p>これが, 冒頭で述べた, 「うまくテンプレートのインスタンス化のタイミングを制御すること」の一例であり, このような工夫によってインスタンス化を遅らせることが可能である事実は, 今回作ったような, パーサコンビネータによるパーサの実装に関して, 重要な意味がありました. 例えば, 以下は今回実装したパーサの一部ですが, <code>pTerm</code> の定義には <code>pCb</code> が, <code>pCb</code> の定義には <code>pTerm</code> が含まれており, これらはいわゆる相互再帰の形となっています.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fmpl-lazyk%2Fblob%2Fabe9289af6b781b5556b010f98c78d9207db2af8%2Fapp%2Fparse.hpp%23L41-L72&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>これらは, パーサコンビネータを「うまくテンプレートのインスタンス化のタイミングを制御すること」で遅延評価するように実装しており, それがもし不可能であったならば, 今回のような方法での実装は恐らくかなわなかったでしょう.</p>
<h2 id="成果物">成果物</h2>
<p>実装は下記リポジトリにて公開しています.</p>
<div class="has-text-centered mb-2">
<p><i class="fab fa-github fa-fw"></i> <a href="https://github.com/falgon/mpl-lazyk">falgon/mpl-lazyk - Compile-time Lazy K interpreter with C++17 template metaprogramming </a></p>
</div>
<p>実行例は以下のとおりです.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb7-1" aria-hidden="true"></a>$ <span class="bu">cd</span> app</span>
<span id="cb7-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb7-2" aria-hidden="true"></a>$ <span class="fu">make</span> LAZYK_CODE=<span class="st">'&quot;(SKK)I&quot;'</span> INPUT=<span class="st">'&quot;Hello, world!&quot;'</span></span>
<span id="cb7-3"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb7-3" aria-hidden="true"></a><span class="ex">Hello</span>, world!</span>
<span id="cb7-4"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb7-4" aria-hidden="true"></a>$ <span class="va">INPUT=</span><span class="st">&quot;Que Sera, Sera&quot;</span> <span class="va">LAZYK_CODE=</span><span class="st">&quot;(SKK)I&quot;</span> <span class="ex">docker-compose</span> -f ./docker/docker-compose.yml run lazyk # または</span>
<span id="cb7-5"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb7-5" aria-hidden="true"></a><span class="ex">Que</span> Sera, Sera</span></code></pre></div>
<p>実は, Lazy K にはコンビネータ記法, Unlambda 記法, Iota 記法, Jot 記法の 4 つの記法があり, これらの記法を 1 つ以上使って書くことができます (つまり, これらの記法を同時に混ぜて使うことができます). 今回の実装では, その全ての記法に対応してい<del>るつもりです</del>ます. 例えば, 以下は Iota 記法による恒等関数の実装です.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb8-1" aria-hidden="true"></a>$ <span class="va">INPUT=</span><span class="st">&quot;Que Sera, Sera&quot;</span> <span class="va">LAZYK_CODE=</span><span class="st">&quot;****i*i*i*ii*ii*ii11111110001111111110000011111111100000&quot;</span> <span class="ex">docker-compose</span> -f docker/docker-compose.yml run lazyk # Iota 記法</span>
<span id="cb8-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb8-2" aria-hidden="true"></a><span class="ex">Que</span> Sera, Sera</span></code></pre></div>
<p>もちろん, この mpl-lazyk の動作としては, Lazy K のソースコードを読み込み, 構文解析によって構文木をつくり, それを基に評価して Ascii characters のリストを構築するという部分まで全てコンパイル時に行われます. 実行時に行われているのは, 標準出力へ文字列を出力することのみです.<br> なお, テストは以下のように実行できます.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb9-1" aria-hidden="true"></a>$ <span class="bu">cd</span> tests <span class="kw">&amp;&amp;</span> <span class="fu">make</span></span>
<span id="cb9-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb9-2" aria-hidden="true"></a>$ <span class="ex">docker-compose</span> -f ./docker/docker-compose.yml run test # または</span></code></pre></div>
なお, 上記で述べたように, 「Lazy K のソースコードを読み込み, 構文解析によって構文木をつくり, それを基に評価して Ascii characters のリストを構築するという部分まで全てコンパイル時に行われる」 ので, 残念ながら, 実行不可能な Lazy K プログラムが必然的に存在します. 例えば, 無限ループを含む Lazy K プログラムなどがそれです. 通常の Lazy K インタプリタでは構築されたリストを遅延評価するか, もしくはそれをシミュレートする方法によって, 随時的に文字を出力できますが, コンパイル時に本処理を行っている以上, それは不可能です. 無論, プログラムの停止性問題により, 無限ループを含む Lazy K プログラムが入力されたときに, 何かをするということはできません. また, C++ テンプレートはチューリング完全であるものの再起深度に限度があるので, その回数を上回るような Lazy K プログラムも必然的に実行できません. N4659 §17.7.1:
<blockquote>
There is an implementation-defined quantity that specifies the limit on the total depth of recursive instantiations ([implimits]), which could involve more than one template. The result of an infinite recursion in instantiation is undefined.
</blockquote>
<p>例えば, 以下はエラトステネスのふるいによって素数を出力し続ける Lazy K プログラムを入力として与えていますが, 再帰深度の限界に到達しています.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb10-1" aria-hidden="true"></a>$ <span class="fu">make</span> LAZYK_CODE=<span class="st">'&quot;K(SII(S(K(S(S(K(SII(S(S(KS)(S(K(S(KS)))(S(K(S(S(KS)(SS(S(S(KS)K))(KK)))))(S(S(KS)(S(KK)(S(KS)(S(S(KS)(S(KK)(S(KS)(S(S(KS)(S(KK)(SII)))(K(SI(KK)))))))(K(S(K(S(S(KS)(S(K(SI))(S(KK)(S(K(S(S(KS)K)(S(S(KS)K)I)(S(SII)I(S(S(KS)K)I)(S(S(KS)K)))))(SI(K(KI)))))))))(S(KK)K)))))))(K(S(KK)(S(SI(K(S(S(S(S(SSK(SI(K(KI))))(K(S(S(KS)K)I(S(S(KS)K)(S(S(KS)K)I))(S(K(S(SI(K(KI)))))K)(KK))))(KK))(S(S(KS)(S(K(SI))(S(KK)(S(K(S(S(KS)K)))(SI(KK))))))(K(K(KI)))))(S(S(KS)(S(K(SI))(SS(SI)(KK))))(S(KK)(S(K(S(S(KS)K)))(SI(K(KI)))))))))(K(K(KI))))))))))(K(KI)))))(SI(KK)))))(S(K(S(K(S(K(S(SI(K(S(K(S(S(KS)K)I))(S(SII)I(S(S(KS)K)I)))))))K))))(S(S(KS)(S(KK)(SII)))(K(SI(K(KI)))))))(SII(S(K(S(S(KS)(S(K(S(S(SI(KK))(KI))))(SS(S(S(KS)(S(KK)(S(KS)(S(K(SI))K)))))(KK))))))(S(S(KS)(S(K(S(KS)))(S(K(S(KK)))(S(S(KS)(S(KK)(SII)))(K(S(S(KS)K)))))))(K(S(S(KS)(S(K(S(S(SI(KK))(KI))))(S(KK)(S(K(SII(S(K(S(S(KS)(S(K(S(K(S(S(KS)(S(KK)(S(KS)(S(K(SI))K))))(KK)))))(S(S(KS)(S(KK)(S(K(SI(KK)))(SI(KK)))))(K(SI(KK))))))))(S(S(KS)(S(K(S(KS)))(S(K(S(KK)))(S(S(KS)(S(KK)(SII)))(K(SI(K(KI))))))))(K(K(SI(K(KI)))))))))(S(K(SII))(S(K(S(K(SI(K(KI))))))(S(S(KS)(S(KK)(SI(K(S(K(S(SI(K(KI)))))K)))))(K(S(K(S(SI(KK))))(S(KK)(SII)))))))))))(K(SI(K(KI))))))))(S(S(KS)K)I)(SII(S(K(S(K(S(SI(K(KI)))))K))(SII)))))&quot;'</span> INPUT=<span class="st">'&quot;&quot;'</span></span>
<span id="cb10-2"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb10-3" aria-hidden="true"></a><span class="ex">fatal</span> error: template instantiation depth exceeds maximum of 900 (use -ftemplate-depth= to increase the maximum)</span>
<span id="cb10-4"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb10-4" aria-hidden="true"></a>     <span class="ex">typedef</span> typename exec_impl<span class="op">&lt;</span>F<span class="op">&gt;</span>::type type<span class="kw">;</span></span>
<span id="cb10-5"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb10-5" aria-hidden="true"></a>                                         ^<span class="ex">~~~</span></span>
<span id="cb10-6"><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#cb10-6" aria-hidden="true"></a><span class="ex">compilation</span> terminated.</span></code></pre></div>
<p>なお, N4659 Annex B によると, この深度の最小推奨値は 1024 であるとされていますが, 依然としてこれはガイドラインに過ぎず, implementation-defined です.</p>
<blockquote>
Recursively nested template instantiations, including substitution during template argument deduction ([temp.deduct]) [1024].
</blockquote>
<p>また, 今回の実行環境である GCC 7.5.0 のデフォルトでは, 上記のエラーメッセージの通り 900 です. <code>-ftemplate-depth</code> でこの値は変更できるのですが, あまりにも大きい数値に設定すると, 現実的な時間内でコンパイルが終了しなくなってしまうこともあります. これに関しては, もう少し深度を抑えるための工夫や別の実装方法への変更が必要になるでしょう.</p>
<h2 id="おわり">おわり</h2>
<p>ほとんどの場合 (恐らく, きっと), テンプレートメタプログラミングを行うことの主な目的は, 型に対して制約を与えることでしょう. 冒頭で述べましたとおり, C++20 以降において, これはコンセプトという言語機能によって置き換えることができるはずです (これには諸説あり, 一部願望が入り混じっています). また, テンプレートメタプログラミングをしていると, 下図のような爆発的なエラーメッセージ<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>と格闘することになる可能性もあります<span class="emoji" data-emoji="innocent">😇</span></p>
<figure>
<img src="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/ce.png" width="500" alt /><figcaption>爆発するコンパイルエラーメッセージ</figcaption>
</figure>
<p>したがって, 無駄な混乱を避けるためにも, テンプレートメタプログラミングは<strong>本当に必要でない限りするべきではありません</strong><a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-templates">C++ Core Guidelines</a> には以下のような記載があります.</p>
<blockquote>
Metaprogramming rule summary:
<ul>
<li>
T.120: Use template metaprogramming only when you really need to
</li>
<li>
T.121: Use template metaprogramming primarily to emulate concepts
</li>
<li>
T.122: Use templates (usually template aliases) to compute types at compile time
</li>
<li>
T.123: Use constexpr functions to compute values at compile time
</li>
<li>
T.124: Prefer to use standard-library TMP facilities
</li>
<li>
T.125: If you need to go beyond the standard-library TMP facilities, use an existing library
</li>
</blockquote>
<p>とは言え, C++ テンプレートがチューリング完全であることは (一部の界隈で) 有名であり, また手続き型言語のプリミティブ, EsoLang としても有名である brainf**k のテンプレートメタプログラミングによるコンパイル時インタプリタの実装は既にインターネット上にあるので, 今回実装したようなテンプレートメタプログラミングによる Lazy K の処理系についても既に存在するだろう…と考えていました. しかし, 私の観測範囲内 (Google, GitHub 検索) では見つけることができませんでしたね…<span class="emoji" data-emoji="thinking">🤔</span></p>
<h2 id="付録-lambda-式の-de-bruijn-index-化">付録: <span class="math inline">\lambda</span> 式の de Bruijn index 化</h2>
<p>先に挙げた例では, 変数が自然数のある位置から何番目の <span class="math inline">\lambda</span> によって束縛されているか, と直感的に考えることで上記の名無し項を得ることができていましたが, これをもっと形式的に求めることを考えます. その考察にあたって, 名付け文脈といわれる仕組みを導入することとします. この仕組みを導入することの動機としては, 例えば <span class="math inline">\lambda w.yw</span> を名無し項として表現することを考えたとき, <span class="math inline">w</span> についての扱い方は陽に分かりますが, <span class="math inline">y</span> については束縛子が見つからないため, 何の数を割り振れば適切か断定のしようがなく, 名無し項を得ることができないというものが挙げられます. この解決策としては, あらかじめ (名前付け文脈といわれる) 自由変数から自然数への写像を定義し, 自由変数に対して自然数を選択する必要が生じた際, 一貫してそれへ従うようにするというものが考えられます. 例として, 名付け文脈 <span class="math inline">\Gamma</span> を以下のように定義できます.</p>
<p><span class="math display">\begin{array}{ccc}
\Gamma&amp;=&amp;x\mapsto 4\\
&amp;&amp;y\mapsto 3\\
&amp;&amp;z\mapsto 2\\
&amp;&amp;a\mapsto 1\\
&amp;&amp;b\mapsto 0
\end{array}</span></p>
<p>上記の通り, インデックスは <span class="math inline">\Gamma</span> に出現する順序で決まります. したがって, より簡潔に <span class="math inline">\Gamma</span> を列 <span class="math inline">\Gamma=xyzab</span> として記述して, 各自由変数名との対応である<a href="/roki.log/2019/03/15/Relation">二項関係</a> <span class="math inline">\left\{\langle x,4\rangle,\langle y,3\rangle,\langle z,2\rangle,\langle a,1\rangle,\langle b, 0\rangle\right\}</span> を表すこととします. また, これをより一般化し, 変数名の順序付けられた可算集合 <span class="math inline">\mathcal{V}</span> から取った変数名 <span class="math inline">x_0,\cdots,x_n\in\mathcal{V}</span> に対して, 名付け文脈 <span class="math inline">\Gamma=x_n,x_{n-1},\cdots,x_1,x_0</span> により, 各自由変数名との対応である二項関係 <span class="math inline">\left\{\langle x_n,n\rangle,\langle x_{n-1},n-1\rangle,\cdots,\langle x_1, 1\rangle,\langle x_0,0\rangle\right\}</span> を表すこととします. さらに <span class="math inline">\mathrm{dom}(\Gamma)</span> と書いて <span class="math inline">\Gamma</span> で扱われる変数名の集合を意味するとします.</p>
<figure>
<img src="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/tree1.png" alt /><figcaption>名付け文脈を持つ <span class="math inline">\lambda w.yw</span> の抽象構文木</figcaption>
</figure>
<p>上図を参考に名無し項の取得を考えると, 各文脈における名付け文脈 <span class="math inline">\Gamma</span> の定義により, <span class="math inline">y\mapsto 4, w\mapsto 0</span> なので <span class="math inline">\lambda w.yw\Leftrightarrow \lambda 4\ 0</span> ということが分かります. つまり, 単に各変数のノードを名付け文脈 <span class="math inline">\lambda</span> の最小のインデックスとして置き換え, その名付け文脈 <span class="math inline">\lambda</span> を参照すればよいということなので, 以下のように, 名付け文脈を持つ <span class="math inline">\lambda</span> 項の下で名無し項への変換関数が定義できます. いま, 任意の列 <span class="math inline">A=\left\{a_n\right\}_{n\in\mathbb{N}}</span> に対し <span class="math inline">A_{-1}:=A_{n}</span> としたとき</p>
<p><span class="math display">
\begin{array}{lcl}
dB_\Gamma(x)&amp;=&amp;\left\{y\in\Gamma\mid x=y\text{ の名前}\right\}_{-1}\\
dB_\Gamma(\lambda x.t)&amp;=&amp;\lambda dB_{\Gamma,x}(t)\\
dB_\Gamma(t_1\ t_2)&amp;=&amp;dB_\Gamma(t_1)dB_\Gamma(t_2)
\end{array}
</span></p>
<p>同時に, この逆関数についても以下のように定義できます.</p>
<p><span class="math display">
\begin{array}{lcll}
bD_\Gamma(i)&amp;=&amp;\Gamma_i\text{ の名前}\\
bD_\Gamma(\lambda t)&amp;=&amp;\lambda x.bD_{\Gamma,x}(t)&amp;\left(\text{ここで, }x=(\mathcal{V}\setminus\text{dom}(\Gamma))_0\right)\\
bD_\Gamma(t_1\ t_2)&amp;=&amp;bD_\Gamma(t_1)bD_\Gamma(t_2)
\end{array}
</span></p>
<p>ここで当然, <span class="math inline">dB_\Gamma(bD_\Gamma(t))=t</span> また束縛変数名の付け替えによる相違を構文レベルで同一視する<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>と, <span class="math inline">bD_\Gamma(dB_\Gamma(M))=M</span> です.</p>
<figure>
<img src="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/tree2.png" alt /><figcaption>名付け文脈を持つ <span class="math inline">\left(\lambda xy.ax\left(\lambda u.ux\right)\right)\left(\lambda x.yx\right)</span> の抽象構文木</figcaption>
</figure>
<p>例えば, 先に扱った <span class="math inline">\left(\lambda\lambda 3\ 1\left(\lambda 0\ 2\right)\right)\left(\lambda 4\ 0\right)</span> についても, この名付け文脈 <span class="math inline">\Gamma</span> に従った名無し項 <span class="math inline">dB_\Gamma(\left(\lambda xy.ax\left(\lambda u.ux\right)\right)\left(\lambda x.yx\right))</span> が利用されていることがわかります.</p>
<h2 id="後日談">後日談</h2>
<p>後日, 何かリアクションがもらえればと思いつき, この話題について <a href="https://www.reddit.com/r/cpp/comments/kt72dz/lazy_k_interpreter_in_c_template_metaprogramming/">Reddit の r/cpp に投下 (Reddit デビュー) してみた</a>.</p>
<p>また, 別件として, 本記事について KLab Engineer Advent Calendar 2020 Recap Day1 にて発表をさせて頂いた (<a href="https://www.klab.com/jp/blog/tech/2021/kfm-202101.html">関連記事</a>).</p>
<blockquote class="mt-3 mb-3 twitter-tweet" data-align="center">
<p lang="ja" dir="ltr">
しゃべります<a href="https://t.co/XO6ajK4CFy">https://t.co/XO6ajK4CFy</a>
</p>
— Roki (@530506) <a href="https://twitter.com/530506/status/1342403203459997696?ref_src=twsrc%5Etfw">December 25, 2020</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>当日は Zoom を利用してのウェビナー形式で行われた. その後 YouTube に発表の様子をアーカイブとして公開して頂いたので, 下記にて掲載する.</p>
<div class="mt-3 mb-3" style="text-align: center;">
<iframe width="560" height="315" src="https://www.youtube.com/embed/OTYsKSZNbZc" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</div>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>
Andrei Alexandrescu (2001) “Modern C++ Design: Generic Programming and Design Patterns Applied”, Addison-Wesley Professional, ISBN: 978-0201704310
</li>
<li>
Benjamin C. Pierce (2002) “Types and Programming Languages”, The MIT Press, ISBN: 978-0262162098
</li>
<li id="ref-3">
de Bruijn, Nicolaas Govert (1972) “Lambda Calculus Notation with Nameless Dummies: A Tool for Automatic Formula Manipulation, with Application to the Church-Rosser Theorem”
</li>
<li>
ISO/IEC 14882:2017, N4659 Working Draft, Standard for Programming Language C++
</li>
<li>
ISO/IEC TS 19568:2017, N4617 C++ Extensions for Library Fundamentals, Version 2
</li>
<li id="ref-6">
Todd L. Veldhuizen (2003) “C++ Template are Turing Complete”, <a href="https://rtraba.files.wordpress.com/2015/05/cppturing.pdf" class="uri">https://rtraba.files.wordpress.com/2015/05/cppturing.pdf</a>
</li>
<li id="ref-7">
“The Lazy K Programming Language”, <a href="https://tromp.github.io/cl/lazy-k.html" class="uri">https://tromp.github.io/cl/lazy-k.html</a>
</li>
<li>
“De Bruijn index - Wikipedia”, <a href="https://en.wikipedia.org/wiki/De_Bruijn_index" class="uri">https://en.wikipedia.org/wiki/De_Bruijn_index</a>
</li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://www.iso.org/standard/79358.html">ISO/IEC PRF 14882</a>, Publication date より. 実は, 本記事の公開の 2 日程前までは, ISO/IEC のページの Publication date に 2021-2 と記載されていました. しかし, <a href="https://twitter.com/530506/status/133887800769232896">いつの間にか Publication date が 2020-12 になっており, 国際標準規格として公開されていた</a>ので, 急遽一部の内容について微調整しています<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote">参考文献 1 はかつて C++ にテンプレートメタプログラミングを世に広めた文献のうちの 1 つでしょう. そのうちの Foreword の一部を引用:
<blockquote>
Some of the techniques herein are admittedly tricky to grasp, especially the template metaprogramming in Chapter 3. Once you’ve mastered that, however, you’ll have a solid foundation for the edifice of generic componentry, which almost builds itself in the ensuing chapters. In fact, I would argue that the metaprogramming material of Chapter 3 alone is worth the book’s price
</blockquote>
<p>第 3 章のメタプログラミングに関する内容だけでも, この本は価格に見合うだけの価値があると述べられていますが, 初めてこの本を読んだときは, 全くそのままそのように感じたことを覚えています…<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>本来 <span class="math inline">\lambda</span> 式の de Bruijn index 化の手続きはもちろんこのようなラフな定義ではなく, 厳密に名無し項を得るための手順を形式的に定めることができますが, Lazy K 処理系を実装するということに当たっては, 入力の関数は (<span class="math inline">\mathrm{S},\mathrm{K},\mathrm{I}</span> を名無し項として定義すれば) 全てはじめから de Bruijn index 化されていることもあり, 今回はあまり重要でないため, この時点では特に触れていません. 念の為, 詳細については末尾に付録として記載することとしました.<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>何故ならば, それらが最も束縛子から近いためです. de Bruijn index の定義から考慮すると当然の帰結ではありますが, より形式的なインデックスの割り当て方に関する詳細は付録を参照してください<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>チューリング完全性については<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#ref-6">参考文献 6</a> を参照してください<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>C++17 標準規格を厳密に考慮した上でこの実装について考えてみると, 実は, 部分特殊化における SFINAE について C++17 標準規格では言及されていないので, この実装に対する正式な標準のサポートがあるとはいえません. これは, <a href="https://wg21.cmeerw.net/cwg/issue2054">CWG Issue 2054</a> として報告されている内容です. しかし, 今回実装の Lazy K インタプリタの内部では, マクロによって使用可否を検出した上で library fundamentals TS v2 の機能の一部を使っています. library fundamentals TS v2 には, 例えば <code>is_detected</code>, <code>detected_t</code>, <code>detected_or</code> (N4617 § 3.3.1) が含まれていますが, この実装では部分特殊化における SFINAE が用いられるので, 必然的に, library fundamentals TS v2 が有効な環境においては, 部分特殊化における SFINAE について有効でなければならないということとなります. これは, 先に述べたマクロによってプリプロセス時に判別することが出来ているので, 今回の実装においては, この問題について特に重要視していません<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>そういえば, この記事の執筆時から 5〜6 年程前には, <a href="https://tgceec.tumblr.com/">Grand C++ Error Explosion Competition</a> という C++ のコンパイルエラーの長さを競うコンテストが開催されることもありました<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>これは少なくとも <a href="https://github.com/isocpp/CppCoreGuidelines/commit/947cf3affcdfc392a316a32f73cdea7383ae55bd#diff-10589f52a46524ed019833fb39740530034f84871ad0c5e547f56e3f7b465c7aR8778">2015 年の時点から言われています</a>.<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>因みに, このような <span class="math inline">\alpha</span> 変換を陽に扱わないとした断りは de Bruijn index を発明したオランダの数学者 Nicolaas Govert de Bruijn による書物 (<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/ref-3">参考文献 3</a>) においても使われています<a href="/roki.log/2020/12/16/CompileTimeLazyKWithCXXTemplateMetaProgramming/#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>個人ページ, ブログを移行した</title>
    <link href="https://roki.dev/roki.log/2020/08/25/hello-roki-web/index.html" />
    <id>https://roki.dev/roki.log/2020/08/25/hello-roki-web/index.html</id>
    <published>2020-08-25T20:45:32Z</published>
    <updated>2020-08-25T20:45:32Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://falgon.github.io/roki/">旧個人ページ</a>及び, <a href="https://falgon.github.io/roki.log/">旧ブログ</a>を本ウェブサイト (<a href="/">roki.dev</a>), 本ブログ (<a href="/roki.log">roki.dev/roki.log</a>, <a href="/roki.diary">roki.dev/roki.diary</a>) に移行した. 以下では, 移行した経緯や技術的概要, 本サイトおよびブログの方針について (ゆるく) 紹介したい.</p>
<h2 id="移行に至った経緯">移行に至った経緯</h2>
<p>移行前の<a href="https://falgon.github.io/roki.log/">旧ブログ</a><a href="/roki.log/2020/08/25/hello-roki-web/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>の構成では, static site generator である <a href="https://github.com/getpelican/pelican">pelican</a> を使っていた. 以下に, それを使ってそこそこの期間の運用をした上での実状, 感想を挙げる.</p>
<ul>
<li><a href="http://www.pelicanthemes.com/">テンプレート</a>や<a href="https://github.com/getpelican/pelican-plugins">プラグイン</a>が充実しており, 設定も非常に少ない記述から簡潔に行えるようになっていて, 主観的な感想として pelican は使い勝手の良いツールであった. 自分の場合は, <a href="https://github.com/gunchu/nikhil-theme">nikhil-theme</a> を元に<a href="https://github.com/falgon/nikhil-theme">拡張して</a>利用しており, いくつかの機能の追加実装や bug fix, 依存関係の更新作業などを行っていた</li>
<li>記事の執筆は Markdown で行い, D3.js や emscripten を導入していたので, 記事内で簡単なシミュレータや計算の視覚化などでヌルヌル動かしたり, 遊んだりできるようにしていた</li>
<li>執筆時には MathJax が意図通り描画できているか等で瞬時にプレビューを見たかったため, 記事内の更新に合わせて記事のリビルド, ブラウザの自動リロードがされる<a href="https://gist.github.com/falgon/5d3fe6838e7f6cb4090823df417680e5">スクリプト</a>を作り, それを実用していたのでブログ記事執筆時のストレスもそこまではなかった</li>
<li>全体のブログ記事管理の仕組みとして, draft から release ブランチに merge &amp; push すると, <a href="https://bitbucket.org/r0ki/roki.log/addon/pipelines/home#!/results/288">Bitbucket Pipelines が走り</a><a href="/roki.log/2020/08/25/hello-roki-web/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, ブログのビルドと GitHub pages へのデプロイが実行されるようにしていたので, 管理コストや記事公開のための作業も少なく, その点は快適であった</li>
<li><a href="https://falgon.github.io/roki.log/posts/2018/%203%E6%9C%88/22/my_first_post/">その他の細かい作業</a> (旧ブログ記事) を行うことで“色々とそれなりに”便利にしていた</li>
</ul>
<p>…とこれまでを振り返ると, あまり不満はなかったのではないかというような気がしてくるが, 全く不満がなかったかというとやはりそうではない.</p>
<ul>
<li>元テンプレートの Bootstrap のバージョンが低い</li>
<li>MathJax が重い</li>
<li>テンプレートが膨大</li>
<li>標準 (プラグイン) の検索機能が日本語に未対応</li>
<li>リンクのバリデーション機能がない</li>
<li>無料 GitHub アカウントでもプライベートリポジトリが使えるようになり, Bitbucket と GitHub 間を横断させる必然性がなくなった (GitHub Actions も使えるようになったことで, ブログ管理のすべてを GitHub のみで一元管理できる)</li>
<li>記事や記事内で使うスクリプトを校生するもの (textlint の linter 等) と, ブログそのもの (Jinja2 テンプレート, ビルド, デプロイ, ライブプレビュー, プラグイン管理…) は全くの別物なので, これらの管理を分離したい</li>
</ul>
<p>無論, 元のブログでも修正, 更新, 機能追加でこれらをすべて満たそうとすることはできるが, もうそこまでするならいっそのことリニューアルしてしまったほうが…<span class="emoji" data-emoji="thinking">🤔</span>となってしまった.<br /></p>
<p>ブログの他にも, 個人 (プロフィール) サイトを公開しており, それにおいては Typescript + React を使って<a href="https://github.com/falgon/roki">構築していた</a><a href="/roki.log/2020/08/25/hello-roki-web/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. こちらは特に何か変わったこともしていないので, 特筆すべきトピックもないのだが, そこまで DOM 操作をするわけでもないプロフィールページにこれらの技術を用いたのはオーバースペックだったし, bundle.js の重さからしてもあまり理にかなっていなかったように思う.</p>
<!--more-->
<h2 id="新個人サイトとブログ">新個人サイトとブログ</h2>
<p>そのようなわけで, 上記のようなモチベーションがあり, 本個人サイトとブログを新設したわけだが, 今回新設したことによって, これらの不満足な点についてすべて解消ができたと考えている. それを果たすことのできた要因や特徴について, いくつか挙げていければと思う.</p>
<h3 id="hakyll-について">Hakyll について</h3>
<p>今回, この新個人サイトとブログを新設するにおいては, Haskell 製の static site generator である <a href="https://jaspervdj.be/hakyll/">Hakyll</a> を使った. 一言に static site generator と聞くと, テンプレートがいくつかあって, それのうちの何かを選び, 場合によってはカスタムなどして, また config があって, そこに任意のほげほげを設定して…というイメージが湧くかもしれない. Hakyll においても, 勿論そのような使い方が可能なのだが, Hakyll はあくまでも static site generator そのものを作るためのライブラリであるという点で特徴的である (と私は感じている). これにより, static site の細かい部分にまで手を付けることができるのである. <br /><br /></p>
<p>例えば, 上記で問題視していた「MathJax が重い」についてであるが, これについてはまず <span class="math inline">\KaTeX</span> へ移行することで対応を行おうと当初考えていた. しかしよくよく考えてみると, <a href="https://hackage.haskell.org/package/hakyll-4.13.4.0/docs/Hakyll-Core-UnixFilter.html#v:unixFilter"><code>unixFilter</code></a> といったような, 外部のプログラムを <code>Compiler</code> として扱うための便利な関数もあるので, こういったものを使って <span class="math inline">\KaTeX</span> から吐き出される数式のタグをサイト生成時に埋め込めれば, わざわざ javascript から動的に書き換える必要すらないのでは…となり<a href="/roki.log/2020/08/25/hello-roki-web/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, 今回はそのように実装することで, 静的な数式レンダリングが行えるようになった<a href="/roki.log/2020/08/25/hello-roki-web/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. <br /><br /></p>
<p>ただこれについては, ビルド時間が比較的長くなるという問題がある. 後述しているように, このウェブサイトのビルド, デプロイに関してはすべて GitHub Actions 上で行っているのもあり, デプロイ前のビルドで時間がかかっても, (GitHub Actions 上で許される範囲内ならば) 特別問題はないのだが, 手元で記事のプレビューをすぐしたいとき等にこれはストレスになる (Hakyll はデフォルト (<a href="https://hackage.haskell.org/package/hakyll-4.13.4.0/docs/Hakyll-Main.html#v:hakyll"><code>hakyll</code></a>, <a href="https://hackage.haskell.org/package/hakyll-4.13.4.0/docs/Hakyll-Main.html#v:hakyllWith"><code>hakyllWith</code></a> 等) で <code>watch</code> オプションが使えるようになっている. これは, 記事等の更新があった場合に自動でビルドを再実行してくれるものである). 今回は <code>hakllWithArgs</code> を用いて, まずこちらでプログラムへの引数を拡張し, それによって static site のビルドの挙動を切り替えられるようにすることでこの問題に対処した. 具体的には, 以下の <code>--preview</code> フラグをセットして実行することにより, ビルド時に <span class="math inline">\KaTeX</span> のレンダリングを行わないようにし, 生成される HTML の <code>head</code> の中に <span class="math inline">\KaTeX</span> を動的にレンダリングする js ファイルを埋め込むようにした.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Froki-web%2Fblob%2Faf49165391316846dbfbd41056b0a0d14f0e2640%2FREADME.md%23L19-L40&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>別の似たような事例として, 不必要な js ファイルの読み込みを行わないようにするといった工夫ができる. このブログでは <a href="https://d3js.org/">d3.js</a> と <a href="https://mathjs.org/">math.js</a> を使えるようにしてあるのだが, 全ての記事でこれらを利用するわけではないので, そのようなときはスクリプトファイルの読み込みを抑えたい. ある記事でこれらのうちの何かが使われたとき, スクリプトファイルの読み込みが必要になるであろうシーンは, 単一の記事を表示するときと, <code>teaser</code> 内にそれが表示範囲として入っていてかつ記事一覧を表示するときであり, 単一の記事を表示しているときは, 単に <code>metadataField</code> にその読み込みの記述があるかないかで判定できるが, 記事一覧を表示するときはその表示される記事一覧の <code>teaser</code> に表示範囲として含まれているか判定しなければならない. が, <code>teaser</code> 内のコンテンツまで読んで判定するとなると, 後々なにか変わった読み込み方をしたくなったときなどに柔軟な対応ができなくなる等の懸念事項があったので, 今回は記事一覧に表示される記事の <code>metadataField</code> に読み込みの記述があれば (<code>teaser</code> に含まれているかとは無関係に), その記事一覧のページにスクリプト読み込みを埋め込むようにしている.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Froki-web%2Fblob%2F2799f109cbc8c8d9065d30b23d7f768fc98f9975%2Fsrc%2FRules%2FBlog%2FCore.hs%23L74-L79&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>…というように, 様々なパフォーマンスに対するニーズについて柔軟に対応ができる点も, Hakyll の良いところであると思う.</p>
<h3 id="リッチな設定ファイル">リッチな設定ファイル</h3>
<p><a href="/">個人ページ</a>の Contributions の一覧は (より多く増やしていきたいという気持ちも込めて) HTML テンプレートに直接埋め込むのではなく, 外部ファイルから読み込むようにしている. その外部ファイルの形式として, 今回は <a href="https://github.com/dhall-lang/dhall-lang">Dhall</a> を採用した. Dhall は簡単に言えば, json に型, 関数, インポートの機能が乗っかった設定ファイル言語である<a href="/roki.log/2020/08/25/hello-roki-web/#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. ここでは Dhall そのものについて詳しくは説明しないが, 例えば, 以下のように各ジャンルについて Union で定義し, 文字列への射を定義することで, 誤った文字列の設定を静的に防ぐといったことができる.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Froki-web%2Fblob%2Fdca4914dad8f00c167e3eea9ba0de6221cdd4243%2Fcontents%2Fconfig%2Fcontributions%2FType%2FGenre.dhall&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>Haskell との親和性も高く, 例えば <code>Dhall.input</code> 等で簡単に読み込むことができる.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Froki-web%2Fblob%2Fab69900746e7ffa9c4a7ec2a4d3c84429e52f406%2Fsrc%2FConfig%2FContributions.hs%23L17-L45&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<h3 id="rssatom-feed-や-site-map">RSS/Atom Feed や Site map</h3>
<p>このサイトは, トップの個人ページの下に二つのブログがぶら下がっている構造をしており, よって, Site map や Atom に関してそれぞれのブログから提供する必要がある.</p>
<p>これは, 標準の <code>renderRSS</code> や <code>renderAtom</code> では対応できないのだが, <code>renderRssWithTemplates</code> や <code>renderAtomWithTemplates</code> で独自の XML テンプレートやコンテキストを渡すことができるので, サイトの構造に合わせて柔軟な対応ができる. Site map については標準の機能として盛り込まれていないのだが, Hakyll のサイトからも紹介されている<a href="https://robertwpearce.com/hakyll-pt-2-generating-a-sitemap-xml-file.html">このブログ記事</a>の通り, Feed の生成と同様, 以下のように XML 用のテンプレートファイルを読ませたり (Lucid 等の) DSL で生成したもの等を使えば良い.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Froki-web%2Fblob%2Fa496b4fe14d6e0b26861f47fac800fb5f1d1222e%2Fsrc%2FRules%2FBlog%2FCore.hs%23L216-L227&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<h3 id="バージョン情報の埋め込み">バージョン情報の埋め込み</h3>
<p>このブログ及びウェブページを生成するアプリケーションのバージョン情報には <a href="https://github.com/falgon/roki-web/blob/72473891c2bb4c31534aafa0b8d76ae88cfe3683/roki-web.cabal#L10">Cabal ファイル</a>で定義されたパッケージバージョンと Git のコミットハッシュ値を埋め込んでいる.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="/roki.log/2020/08/25/hello-roki-web/#cb1-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec site -- --version</span>
<span id="cb1-2"><a href="/roki.log/2020/08/25/hello-roki-web/#cb1-2" aria-hidden="true"></a><span class="ex">The</span> static site roki.dev compiler</span>
<span id="cb1-3"><a href="/roki.log/2020/08/25/hello-roki-web/#cb1-3" aria-hidden="true"></a><span class="ex">version</span>: 0.1.0.0, commit hash: d4dcc402eb6ac271ec070a539e206580ad9cbe5e</span></code></pre></div>
<p>Git のコミットハッシュ値を埋め込むのには <a href="http://hackage.haskell.org/package/gitrev-1.3.1/docs/Development-GitRev.html#v:gitHash"><code>Development.GitRev.gitHash</code></a> が非常に便利で役立った.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Froki-web%2Fblob%2Fd8a997823c03ebf8008f56c6cebf870e66140545%2Fapp%2Fsite%2FMain.hs%23L96-L104&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<h3 id="css-フレームワーク-bulma">CSS フレームワーク Bulma</h3>
<p>このブログは CSS のフレームワークとして <a href="https://bulma.io/">Bulma</a> を使用している. 当初は以前のブログと同様に Bootstrap を使おうかと考えていたが, 極力 javascript をなくし, 最小構成を軽くしたいと考えていたため, こちらを採用した. ウェブサイトのデザインについて疎い私であっても, 一応このような“それなりにそれっぽい”見た目を構成できたという点において, この CSS フレームワークには助けられたといえる. 個人的に非常に便利だったのが, Bulma の提供している <a href="https://bulma.io/documentation/helpers/">Helpers</a> で, これは単に色の定数値や <code>margin</code>, <code>padding</code> 等に関するショートカットが用意されているのだが, 「ほんのちょっと手を入れたい」というときのタイプ数がかなり抑えられるので, 精神的負担が少なく, とても良いものであった.</p>
<p>また, 数学系の記事を書く際には「定義」, 「命題」, … といったような見出しをつけたいものだが, このスタイルの作成についても助けられた (Bulma が便利というのもあるが, 単純に SCSS の展開能力にも助けられた).</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Froki-web%2Fblob%2Ff5735daf569603ba872b9ee56820dfbbbbe4423e%2Fcontents%2Fscss%2Fblog%2F_mixins.scss&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>これを使って, 例えば以下のように書けば</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb2-1"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-1" aria-hidden="true"></a><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;m-prop&quot;</span><span class="kw">&gt;</span></span>
<span id="cb2-2"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-2" aria-hidden="true"></a><span class="kw">&lt;header</span><span class="ot"> class=</span><span class="st">&quot;m-prop-title&quot;</span><span class="kw">&gt;&lt;p&gt;</span>ABC 予想<span class="kw">&lt;/p&gt;&lt;/header&gt;</span></span>
<span id="cb2-3"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-3" aria-hidden="true"></a><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;m-prop-content&quot;</span><span class="kw">&gt;</span></span>
<span id="cb2-4"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-4" aria-hidden="true"></a>\\[ a + b = c \\]</span>
<span id="cb2-5"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-5" aria-hidden="true"></a>を満たす, 互いに素な自然数の組 \\(a, b, c\\) に対し, 積 \\(abc\\) の互いに異なる素因数の積を \\(d\\) とおく.</span>
<span id="cb2-6"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-6" aria-hidden="true"></a>このとき, 任意の \\(\epsilon\gt 0\\) に対して,</span>
<span id="cb2-7"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-7" aria-hidden="true"></a>\\[ c\gt d^{1+\epsilon} \\]</span>
<span id="cb2-8"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-8" aria-hidden="true"></a>を満たす組 \\((a,b,c)\\) は高々有限個しか存在しない</span>
<span id="cb2-9"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-9" aria-hidden="true"></a><span class="kw">&lt;/div&gt;</span></span>
<span id="cb2-10"><a href="/roki.log/2020/08/25/hello-roki-web/#cb2-10" aria-hidden="true"></a><span class="kw">&lt;/div&gt;</span></span></code></pre></div>
<p>次のような表示になる.</p>
<div class="m-prop">
<header class="m-prop-title">
<p>
ABC 予想
</p>
</header>
<div class="m-prop-content">
<p><span class="math display"> a + b = c </span> を満たす, 互いに素な自然数の組 <span class="math inline">a, b, c</span> に対し, 積 <span class="math inline">abc</span> の互いに異なる素因数の積を <span class="math inline">d</span> とおく. このとき, 任意の <span class="math inline">\epsilon\gt 0</span> に対して, <span class="math display"> c\gt d^{1+\epsilon} </span> を満たす組 <span class="math inline">(a,b,c)</span> は高々有限個しか存在しない</p>
</div>
</div>
<h3 id="cicd-と全体の管理体系">CI/CD と全体の管理体系</h3>
<p>前述したとおり, このブログ, ウェブページは GitHub Actions でビルド, デプロイを行っており, それ以外の CI/CD としていくつかボットを設定している. この構成の特徴としては, ドラフトをリモートリポジトリに非公開の状態で保存できるようにしてあること, またそれが Git 上で矛盾しないように構成している点が挙げられると思う. といっても, 下図の通り非常にシンプルな構成である.</p>
<figure>
<img src="https://user-images.githubusercontent.com/1241783/90969880-d99b8a00-e538-11ea-8f35-684365e14406.png" title="個人ページ/ブログ管理の構造" width="640" alt /><figcaption>個人ページ/ブログ管理の構造</figcaption>
</figure>
<p>執筆時点現在では, 少なくとも GitHub 上において「プライベートブランチ」なる概念は存在しない. 従って, 非公開情報を扱いたいのならば, 必然的にそれをプライベートリポジトリとして扱う必要があるが, この構成はドラフトとリリースでリポジトリの公開情報をそれぞれわけることができるということに加えて, ブログ記事そのものに対する管理と, ウェブサイトを生成するアプリケーションの管理を分離することができるという利点がある. 例えば, ブログ記事の管理のほうで扱われるのは Markdown テキスト, 画像などのメディアファイル, 記事内で使うような js ファイル等であり, これらの linter やメディアファイルへの自動圧縮などの CI/CD を構成する際に, アプリケーションの CI と完全に分離できるのである.<br /><br /> なお, この構成をするのには既存の Action である <a href="https://github.com/peaceiris/actions-gh-pages">GitHub Actions for GitHub Pages</a> が非常に役立った. 特に, 既存のファイルを残すように設定できたり, 外部のプロジェクトへ Push できる設定項目については特筆すべき内容で, この Action のおかげで全体の構成をスムーズに行うことが出来たといっても過言ではない. <br /><br /> 次に, パフォーマンス計測についてであるが, 一応デプロイした後に, Google PageSpeed Insights で, <a href="https://github.com/falgon/roki-web/runs/1027626194?check_suite_focus=true">デプロイ後の状態を計測させるようにしている</a>. 現状, PC 版は 90, モバイル版は 65 を閾値として取り敢えず合否を設定しているが, モバイル版のスコアをもう少し上げられるようにしていきたいところである. これには, <a href="https://github.com/actions/github-script">actions/github-script</a> が非常に役立った. javascript を直接書き込める Action で, 手軽に導入が勧められる. 以下の処理においては, GitHub pages の状態がデプロイ完了になるまでポーリングさせている.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Froki-web%2Fblob%2F415890efb43ac2e286b721b09a2881337a0245f0%2F.github%2Fworkflows%2Fbuild.yml%23L97-L128&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>さて, ここまで見てみて, もしかすると, どうやって roki-web と roki-web-post 側で同期を取っているのか, 普段はこの環境でどのようにブログの更新等行うのか等, 疑問に思うかもしれないので少し補足しておく. まず, ブログ記事の更新は, すべて roki-web-post リポジトリ内で行う. roki-web リポジトリ内では, ブログ記事については一切触らない. これをもし触ってしまうと, GitHub Actions によって roki-web の master ブランチにプッシュした際にコンフリクトすることになるので, この点では注意が必要である (が, まあもし間違えて触ってしまったとしてもそこは Git なので別になんとかなる). 反対に, ウェブサイトを生成するアプリケーションについて, roki-web-post では一切触らない. ウェブサイトを生成するアプリケーションについて何らかの変更を加えたい場合は, roki-web のみから行うようにする. <br /> 次に roki-web で何らかの変更が加えられたときに, roki-web-post がどのようにそれを取り込めばよいかであるが, これは単純に remote を複数登録しておいて, 場合によって切り替えて pull してくれば良い. もっと言えば, 下記のように設定しているので,</p>
<pre><code>$ git remote -v
origin  git@github.com:falgon/roki-web-post.git (fetch)
origin  git@github.com:falgon/roki-web-post.git (push)
site-system git@github.com:falgon/roki-web.git (fetch)
site-system git@github.com:falgon/roki-web.git (push)</code></pre>
<p>roki-web の変更を取り込むときは単に</p>
<pre><code>$ git pull site-system master</code></pre>
<p>等をすれば良いようにしている. このとき, <code>--set-upstream</code> 等でデフォルトを <code>origin</code> に設定しておくと, ぼーっとしていて <code>site-system</code> 取り込んでしまった！だとか <code>site-system</code> に push してしまった！等という事故を防ぎやすくなる.<br /><br /></p>
<p>なお, roki-web へのデプロイは deployment key を使って行っているが, これは <a href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows#triggering-new-workflows-using-a-personal-access-token">Action 内でデフォルトで使える <code>GITHUB_TOKEN</code> では, あるワークフローによって別のワークフローをトリガーできないため</a>である.</p>
<blockquote>
<p>When you use the repository’s GITHUB_TOKEN to perform tasks on behalf of the GitHub Actions app, events triggered by the GITHUB_TOKEN will not create a new workflow run.</p>
</blockquote>
<p>この回避策に関しては, <a href="https://github.com/peter-evans/create-pull-request/blob/8f96fd02520b1086ddc0ec0625b6b5814fb0e694/docs/concepts-guidelines.md#triggering-further-workflow-runs">create pull request という GitHub Actions のドキュメント</a>中に記載があるので, 必要ならば参照すると良いかもしれない.</p>
<h3 id="pr-に対するプレビュー">PR に対するプレビュー</h3>
<p>依存パッケージのバージョン更新や追跡等を Bot に管理させると管理コストを抑えることが出来る. このブログも依存パッケージのバージョン更新, 追跡は <a href="https://dependabot.com/">Dependabot</a> を利用することで行っているが, こういった PR を自動で発行してくれるような Bot を運用する上では, 人間はもはやマージボタンをただ押せば良いだけ, という環境を極力整備したいものである. しかし, 今回のようなウェブサイトのプロジェクトの場合, テスト実行のみではどうしても保守ができない箇所が発生するし, マージする前に念の為一度実際にプレビューを見ておきたいといった理由で, Dependabot から投げられてきた PR をただそのままマージするといったことが出来ない場合がある. 手元にプルしてきて毎度確かめればそれは勿論プレビューができるわけだが, 前述したように, こちらは出来る限りボタンをぽちぽちするだけで完結したい. <br /> そこで, 今回は <a href="https://circleci.com/docs/ja/2.0/artifacts/">CirCle CI の Artifacts</a> を用いて, PR (のコミット) 毎にプレビューを閲覧できるようにした. CircleCI の Artifacts は (本エントリ執筆時点において) GitHub Actions と異なり, Artifacts に対するブラウジングが可能となっており, 従って, そこに HTML ファイルを配置すれば, ビルド毎の一時的なウェブサイトが確認できるようになる<a href="/roki.log/2020/08/25/hello-roki-web/#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<figure>
<img src="/roki.log/2020/08/25/hello-roki-web/pr.png" title="PR とプレビューの概観" width="640" alt /><figcaption>PR とプレビュー生成の概観</figcaption>
</figure>
<p>PR に対するプレビュー生成の概観は上図のようになっている. まず GitHub Actions が PR をトリガーに内部でウェブサイトを生成し, Google Drive にアップロードする. ここで, アップロードする tarball にはプレフィックスとしてコミットハッシュ値をつけておく. その後 GitHub Actions が CircleCI の job を起動する. このとき, コミットハッシュ値をパラメータとして付加して起動する. CircleCI は与えられたコミットハッシュ値を参考に Google Drive から Artifacts tarball をダウンロード, Google Drive から削除し, CircleCI 上の Artifacts に展開する. そして, 最後に Bot がその job のログが見れる URL と展開された Artifacts の index.html の URL を該当 PR にコメントする.<br /> 以上により, 手元でプルしてビルドして…といったプレビュー作業を自分で行うことなく, 一時的なプレビューサイトを事前に確認することができるようになっている. <br /></p>
<p>さて, このようにいくつかのサービスを横断させているのにはそれなりの理由がある. まず第一に, Artifacts としてアップロードするウェブサイトを CircleCI 上ではビルドしないように済ませる必要があった, ということ. <a href="https://circleci.com/docs/ja/2.0/configuration-reference/#resource_class">CircleCI は 1 job につきデフォルトで 4GB の RAM が割り当てられる</a>が, このウェブサイトをビルドする際に使われる Cabal という Hakyll の依存パッケージをビルドすると CircleCI 上ではどうしてもメモリリソース不足となってしまい, ビルドができなかった. <code>-j1</code> で事前ビルドしたりといった回避策も試行してみたものの, 私の場合では虚しく, メモリリソース不足となってしまった.</p>
<blockquote class="twitter-tweet tw-align-center">
<p lang="en" dir="ltr">
ﾌｧｰ<br>“Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)” <a href="https://t.co/qHgFGSyCgs">https://t.co/qHgFGSyCgs</a>
</p>
— Roki (@530506) <a href="https://twitter.com/530506/status/1300768211399446528?ref_src=twsrc%5Etfw">September 1, 2020</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>よって, CircleCI 上でのビルドは断念せざるを得なかった, というのと, GitHub Actions 上でそもそもビルドを行っていたので, そこでビルドした tarball をそのまま利用出来た方が無駄がないという面もあり, わざわざ CircleCI 上でビルドを行う必然性も特になかったので, 今回は Artifacts のみを利用することで対応している.</p>
<p>第二に, <a href="https://github.com/actions/upload-artifact/issues/50#issuecomment-639170787">ワークフローの実行中に Artifacts URL を取得することが不可能</a>であったということ. GitHub Actions の Artifacts の URL を CircleCI に渡してダウンロードさせることが出来れば理想的だが, この URL の取得は GitHub Actions の仕様上できないので, ワークフローの内部でビルドした成果物を GitHub Actions Artifacts にアップロードするのではなく, Google Drive といった外部のストレージサービスへアップロードすることで対応を行わざるを得なかった.</p>
<h2 id="総括">総括</h2>
<p>ここまで振り返ってみて, 割とまだまだ拘れる点はあると感じている. 例えば, テンプレートの Lucid 化だとか, 現在の実装をもう少しモナドの合成等ですっきり表せないか等である. 一応, このブログ, ウェブページを構築した際に何をやったのかまとめやすいように, 構築するのに行った大体のタスクについて<a href="https://github.com/falgon/roki-web/issues?q=is%3Aissue+label%3Ainit-build+">ラベルをつけておいた</a>ので, 気になる場合は見てみても良いかもしれない. そのようなわけで, 今後はこのブログ, ウェブサイトを使って以前と同様何かしら書いていければと思っているので, (お手柔らかに) よろしくお願い致します.</p>
<h2 id="追記-1">追記 1</h2>
<ol type="1">
<li>利用している CI/CD, Bot は様々なものを使わせて頂いているが, そのうちの 1 つとして, フォーマッタ等でコードスタイルを判定, 整形して PR を投げてくれる <a href="https://restyled.io/">restyled.io</a> という Bot が挙げられる. 見てみたところ, Dhall は対応していなかったので, 今回は <a href="https://github.com/restyled-io/restylers/pull/96">PR を投げて Dhall の対応を追加してみた</a>. エディタの保存時に自動でフォーマッタを動くようにしていればそもそも不要ではあるが, たまにそのような機能を切ったりすることがあり, ついそのまま push してしまうなんということがあるので, そういった際にこの Bot があると, 一手間作業を減らすことができる</li>
<li><a href="https://www.klab.com/jp/blog/tech/2020/0924-Hakyll.html">KLablog</a> にてこちらの内容を紹介する記事を執筆し, 公開頂きました</li>
</ol>
<h2 id="追記-2-20201119">追記 2 (2020/11/19)</h2>
<p>GitHub Actions の <code>cron</code> を利用することで, 簡単な予約投稿機能を実現した. 理想としては, GitHub Actions 上で <code>at</code> コマンドのようなものが使えれば最適であったが, 残念ながらそのようなものはないので, 予約投稿したい内容の差分が含まれたブランチを用意しておき, 該当時刻の cron とデプロイ処理が記述された GitHub Actions の yaml ファイルをプッシュするという少し強引な方法で実現した. ただ, この yaml ファイルを一々手書きしていては堪えるので, (Hakyll のテンプレート機能を使って) 入力から自動生成する簡単なツールを作ることで対応した.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec spa -- --help</span>
<span id="cb5-2"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-2" aria-hidden="true"></a><span class="ex">Usage</span>: spa [--version] COMMAND [-d<span class="kw">|</span><span class="ex">--date</span> date] [-b<span class="kw">|</span><span class="ex">--branch-name</span> ARG] [-y]</span>
<span id="cb5-3"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-3" aria-hidden="true"></a>  <span class="ex">The</span> roki-web Scheduling Post Action manager 0.1.0.0</span>
<span id="cb5-4"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-5" aria-hidden="true"></a><span class="ex">Available</span> options:</span>
<span id="cb5-6"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-6" aria-hidden="true"></a>  <span class="ex">-h</span>,--help                Show this help text</span>
<span id="cb5-7"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-7" aria-hidden="true"></a>  <span class="ex">--version</span>                Show spa version information</span>
<span id="cb5-8"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-8" aria-hidden="true"></a>  <span class="ex">-d</span>,--date date           Date to schedule (mm-dd-%H:%M)</span>
<span id="cb5-9"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-9" aria-hidden="true"></a>  <span class="ex">-b</span>,--branch-name ARG     The name of the branch you plan to deploy</span>
<span id="cb5-10"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-10" aria-hidden="true"></a>  <span class="ex">-y</span>                       Generate a file without checking the branch name and</span>
<span id="cb5-11"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-11" aria-hidden="true"></a>                           <span class="ex">repository</span> name</span>
<span id="cb5-12"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-12" aria-hidden="true"></a></span>
<span id="cb5-13"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-13" aria-hidden="true"></a><span class="ex">Available</span> commands:</span>
<span id="cb5-14"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-14" aria-hidden="true"></a>  <span class="ex">cexpr</span>                    show crontab expression</span>
<span id="cb5-15"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-15" aria-hidden="true"></a>  <span class="ex">yaml</span>                     generate GitHub Actions yaml from template</span>
<span id="cb5-16"><a href="/roki.log/2020/08/25/hello-roki-web/#cb5-16" aria-hidden="true"></a>  <span class="ex">clean</span>                    clean up and remove cache</span></code></pre></div>
<p>以下のように生成できる.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb6-1"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec spa -- yaml -d <span class="va">$(</span><span class="fu">date</span> <span class="st">&quot;+%m-%d-%R&quot;</span><span class="va">)</span> -b my-awesome-scheduled-post # 現在時刻で生成 (つまり来年に実行される)</span>
<span id="cb6-2"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-2" aria-hidden="true"></a><span class="ex">current</span> branch name is: draft</span>
<span id="cb6-3"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-3" aria-hidden="true"></a><span class="ex">Are</span> you sure you want to continue connecting? (y/N)<span class="ex">y</span></span>
<span id="cb6-4"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-4" aria-hidden="true"></a><span class="ex">Initialising...</span></span>
<span id="cb6-5"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-5" aria-hidden="true"></a>  <span class="ex">Creating</span> store...</span>
<span id="cb6-6"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-6" aria-hidden="true"></a>  <span class="ex">Creating</span> provider...</span>
<span id="cb6-7"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-7" aria-hidden="true"></a>  <span class="ex">Running</span> rules...</span>
<span id="cb6-8"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-8" aria-hidden="true"></a><span class="ex">Checking</span> for out-of-date items</span>
<span id="cb6-9"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-9" aria-hidden="true"></a><span class="ex">Compiling</span></span>
<span id="cb6-10"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-10" aria-hidden="true"></a>  <span class="ex">updated</span> tools/scheduled_post/template.yml</span>
<span id="cb6-11"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-11" aria-hidden="true"></a>  <span class="ex">updated</span> my-awesome-scheduled-post.yml</span>
<span id="cb6-12"><a href="/roki.log/2020/08/25/hello-roki-web/#cb6-12" aria-hidden="true"></a><span class="ex">Success</span></span></code></pre></div>
<p>後は, この yaml ファイルを roki-web-post のメインブランチ内の <code>.github/workflows/</code> 配下に置けばよい. GitHub Actions における cron のタイムゾーンは UTC なので, <code>cexpr</code> という JST での時刻入力を POSIX cron 形式の UTC 時刻で出力するコマンドを念の為用意している.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="/roki.log/2020/08/25/hello-roki-web/#cb7-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec spa -- cexpr -d <span class="va">$(</span><span class="fu">date</span> <span class="st">&quot;+%m-%d-%R&quot;</span><span class="va">)</span></span>
<span id="cb7-2"><a href="/roki.log/2020/08/25/hello-roki-web/#cb7-2" aria-hidden="true"></a><span class="ex">00</span> 15 11 09 *</span></code></pre></div>
<p>予約投稿の実施後には, 上記で生成した yaml ファイルがメインブランチ内に残ることとなり, これをそのままにしておくと, 一年後にまた実行されてしまう. そこでそのファイルの削除忘れが起きないよう, 予約投稿が完了次第, メインブランチ内の該当 yaml ファイルを削除する PR が自動的に発行されるようにしている.</p>
<figure>
<img src="/roki.log/2020/08/25/hello-roki-web/auto-delete.png" width="640" alt /><figcaption>予約投稿完了後に自動発行される PR</figcaption>
</figure>
<p>ここで, PR のマージを忘れてしまうと先に述べたのと同じことになってしまうのだが, かといって, 事前に確認もなく draft ブランチへ変更を加えたくもなかった. 今回は, これらの兼ね合いを考慮した上で, そこそこ納得のいく落とし所がつけられたのではないかと思っている.</p>
<h2 id="追記-3-20210626">追記 3 (2021/06/26)</h2>
<p>CircleCI の Artifacts へのアップロードが完了した後に <a href="https://notify-bot.line.me/ja/">LINE Notify</a> を用いて通知するようにした (<a href="https://github.com/falgon/roki-web/pull/159">#159</a>).</p>
<figure>
<img src="https://user-images.githubusercontent.com/1241783/122118953-9dd50680-ce63-11eb-9f7b-c15d135fb1bb.jpeg" width="320" alt /><figcaption><a href="https://notify-bot.line.me/ja/">LINE Notify</a> によるウェブサイトビルド完了通知</figcaption>
</figure>
<p>CircleCI の Environment Variables に API トークンを <code>LINE_NOTIFY_TOKEN</code> としてセットし, 以下のように叩いている.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Froki-web%2Fblob%2F02b82883ce313505cdf7c1bc009bd39f8ed86cc8%2Ftools%2Fcircleci%2FNotifyLine.hs&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>それよりも前は 2016 年に<a href="https://roki.hateblo.jp/">はてなブログ (Roki のチラ裏)</a> で技術系の記事を書いていた. さらにそれよりも前はアメーバブログで技術系の記事を書いていたが, 随分前にもう消してしまっていた…特別意識しているわけではないが, こう見ると二年周期で移行している気がする… (もう移行はしたくないなぁという気持ち)<a href="/roki.log/2020/08/25/hello-roki-web/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>ここで貼っている Pipelines のリンクは, このブログへ移行する前の旧ブログに対する最後の変更コミットのもの. 切ない.<a href="/roki.log/2020/08/25/hello-roki-web/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>元々は何か色々と DOM 操作をするつもりでいたのだが, 結局単なるプロフィールページなのでオーバースペックであった. この旧プロフィールページはすでにクローズしているが, 記録としてなんとなくキャプチャしたものを <a href="https://youtu.be/31VIygOOwLw">YouTube にアップロードしておいた</a>ので, もし興味があれば.<a href="/roki.log/2020/08/25/hello-roki-web/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>同様の取り組みをされているサイトがいくつかあったため, 大いに参考とさせて頂いた.<a href="/roki.log/2020/08/25/hello-roki-web/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>これにより, 例えば比較的多くの数式を使っている「<a href="/roki.log/2018/07/13/elgamalEncryption/index.html">エルガマル暗号</a>」といった記事について, Google PageSpeed Insights で何度か計測した結果, <a href="https://falgon.github.io/roki.log/posts/2018/%207%E6%9C%88/13/elgamalEncryption/">旧ブログ記事</a>と比較してインタラクティブになるまでの時間が PC で平均 7 倍, モバイルで平均 5 倍高速になった (てきとう調べ)<a href="/roki.log/2020/08/25/hello-roki-web/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>あくまで設定のための言語であり, チューリング完全ではない. Dhall については, 別途なにか記事を書きたい…<a href="/roki.log/2020/08/25/hello-roki-web/#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>GitHub Actions にブラウジング Artifacts 機能が追加される予定があるかに関して <a href="https://github.community/t/browsing-artifacts/16954">Support Community</a> にも話題が挙がっている.<a href="/roki.log/2020/08/25/hello-roki-web/#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Haskell で C コンパイラを作ってみた</title>
    <link href="https://roki.dev/roki.log/2020/03/17/SelfMadeCCompiler/index.html" />
    <id>https://roki.dev/roki.log/2020/03/17/SelfMadeCCompiler/index.html</id>
    <published>2020-03-18T00:00:00Z</published>
    <updated>2020-03-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>本エントリ投稿の 2, 3 ヶ月前に Haskell でスクラッチから x86-64 向けの C コンパイラを作った. 本エントリは, その記録である.</p>
<h2 id="動機背景">動機/背景</h2>
<p>コンパイラの自作は, 社会人になる前に, 前々から一度はやっておきたいと思っていた事柄の一つであったこと, また関数プログラミングとの関係性について探求したかったこと, さらに, 一部には, 関数プログラミングはコンパイラ開発を容易にする<a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>という認識があるが, 数学的構造の実用化の一つとも言える関数プログラミングに関する考察においては, 圏論的な理由付けによりその有用性を言うことができるはずであろうという, 私の中での何となくの予想が本当であるのかどうか, 確認したかったことから, 実際に Haskell で C コンパイラを作るに至った. なお, 圏論の話題は再度別のエントリとしてまとめ, その後, さらに別のエントリにそれと関連付いた話題としてまとめようと考えているため, 本エントリでは特に立ち入らず, あくまでも, Haskell で C コンパイラを作ってみたという単なる取り組みへの記録程度に止める.</p>
<!--more-->
<h2 id="成果">成果</h2>
<p>プロジェクトは, 次のリポジトリにて管理している.</p>
<div class="has-text-centered mb-2">
<p><i class="fab fa-github fa-fw"></i> <a href="https://github.com/falgon/htcc">falgon/htcc - A tiny C language compiler (x86-64) (WIP)</a></p>
</div>
<p>執筆時最新のコミット <a href="https://github.com/falgon/htcc/tree/230137475bf08265db9bd31ea65e2d867b1207fc">2301374</a> におけるコンパイル可能なコードは構文は, テストコードに記されている通りである. より実用的な (コンパイル可能な) サンプルコードは example 配下にある (ナップザック問題, 連結リストのマージソート, Fisher–Yates シャッフルとクイックソート, ライフゲームシミュレータ等).</p>
<p>htcc は標準 C 言語<a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>の構文の他に, 一部の GNU 拡張の構文を実装している. 例えば, <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">Statement Expression</a> はそのうちの一つである. 近年, Rust のような多くの“現代的な”言語は, 文の構文を式として捉えている<a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>が, Statement Expression はそれと同様の機能, すなわち, C の compound-statement を式として捉える機能を提供する. また, <a href="https://gcc.gnu.org/onlinedocs/gcc/Conditionals.html">Conditionals with Omitted Operands</a> もそのうちの一つである. 条件演算子は N1570 において次のように定義されているが</p>
<p><span class="math display">
\begin{array}{llllll}
\text{conditional-expression}:\\
&amp;\text{logical-OR-expression}\\
&amp;\text{logical-OR-expression}&amp;?&amp;\text{expression}&amp;:&amp;\text{conditional-expression}
\end{array}
</span></p>
<p>この expression オペランドが省略された次の構文</p>
<p><span class="math display">
\begin{array}{lll}
\text{logical-OR-expression}&amp;?:&amp;\text{conditional-expression}
\end{array}
</span></p>
<p>をサポートする.</p>
<p>htcc の機能そのものの説明は, 基本的に上記リポジトリの README.md に書かれている通りであるが, ここにコミット <a href="https://github.com/falgon/htcc/tree/230137475bf08265db9bd31ea65e2d867b1207fc">2301374</a> 時点での説明を再掲することとする.</p>
<figure>
<img src="https://raw.githubusercontent.com/falgon/htcc/230137475bf08265db9bd31ea65e2d867b1207fc/assets/some_operation.gif" title="htcc の実行イメージ" alt /><figcaption>htcc の実行イメージ</figcaption>
</figure>
<p>コマンドラインオプションは次のようになっている.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-1" aria-hidden="true"></a>$ <span class="ex">stack</span> exec htcc -- -h</span>
<span id="cb1-2"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-2" aria-hidden="true"></a><span class="ex">Usage</span>: htcc [--visualize-ast] [--img-resolution RESOLUTION] file [-o<span class="kw">|</span><span class="ex">--out</span> file]</span>
<span id="cb1-3"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-3" aria-hidden="true"></a>            [<span class="ex">-w</span><span class="kw">|</span><span class="ex">--supress-warns</span>]</span>
<span id="cb1-4"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-5" aria-hidden="true"></a><span class="ex">Available</span> options:</span>
<span id="cb1-6"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-6" aria-hidden="true"></a>  <span class="ex">-h</span>,--help                Show this help text</span>
<span id="cb1-7"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-7" aria-hidden="true"></a>  <span class="ex">--visualize-ast</span>          Visualize an AST built from source code</span>
<span id="cb1-8"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-8" aria-hidden="true"></a>  <span class="ex">--img-resolution</span> RESOLUTION</span>
<span id="cb1-9"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-9" aria-hidden="true"></a>                           <span class="ex">Specify</span> the resolution of the AST graph to be</span>
<span id="cb1-10"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-10" aria-hidden="true"></a>                           <span class="ex">generated</span> (default: 640x480)</span>
<span id="cb1-11"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-11" aria-hidden="true"></a>  <span class="fu">file</span>                     Specify the input file name</span>
<span id="cb1-12"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-12" aria-hidden="true"></a>  <span class="ex">-o</span>,--out file            Specify the output destination file name, supported</span>
<span id="cb1-13"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-13" aria-hidden="true"></a>                           <span class="ex">only</span> svg (default: ./out.svg)</span>
<span id="cb1-14"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb1-14" aria-hidden="true"></a>  <span class="ex">-w</span>,--supress-warns       Disable all warning messages</span></code></pre></div>
<p>例えば, 標準出力に <code>hello world</code> を出力する C ソースコードのコンパイルは, 次のように実行できる.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#cb2-1" aria-hidden="true"></a>$ <span class="bu">echo</span> <span class="st">'int printf(); int main() { printf(&quot;hello world!\n&quot;); }'</span> <span class="kw">|</span> <span class="ex">stack</span> exec htcc -- /dev/stdin <span class="kw">|</span> <span class="fu">gcc</span> -xassembler -no-pie -o out -  </span></code></pre></div>
<p>htcc には, 内部で構築した構文木をベクタ画像として視覚化し, 出力する機能を実装してある<a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. 次の表は, 実行されるコマンドと出力されるベクタ画像の対応を示したものである.</p>
<div class="table-responsive">
<table class="table table-bordered table-hover is-fullwidth">
<thead>
<tr>
<th style="text-align: center; width:50%;">
コマンド
</th>
<th style="text-align: center;">
出力画像
</th>
</tr>
</thead>
<caption id="karnaugh1" style="caption-side: bottom">
htcc の構築した構文木のベクタ画像出力例
</caption>
<tbody>
<tr>
<td>
<div class="sourceCode">
<pre class="sourceCode bash"><code class="sourceCode bash">
$ echo 'int main() { return 1 * 2 + 4; }' | \
    stack exec htcc -- /dev/stdin           \
        --visualize-ast                     \
        --img-resolution 640x480            \
        --out calc.svg
</code></pre>
</div>
</td>
<td>
<img class="img-responsive" src="https://raw.githubusercontent.com/falgon/htcc/230137475bf08265db9bd31ea65e2d867b1207fc/assets/example_ast/calc.png" alt="ast_graph">
</td>
</tr>
<tr>
<td>
<div class="sourceCode">
<pre class="sourceCode bash"><code class="sourceCode bash">$ echo 'int printf();
void fizzbuzz(int n) { 
    for (int i = 1; i &lt; n; ++i) { 
        if (!(i % 15)) printf("fizzbuzz\n"); 
        else if (!(i % 3)) printf("fizz\n"); 
        else if (!(i % 5)) printf("buzz\n"); 
        else printf("%d\n", i); 
    } 
} 
int main() { fizzbuzz(50); }' |     \
    stack exec htcc -- /dev/stdin   \
        --visualize-ast             \
        --img-resolution 1280x720   \
        --out fizzbuzz.svg
</code></pre>
</div>
</td>
<td>
<img class="img-responsive" src="https://raw.githubusercontent.com/falgon/htcc/230137475bf08265db9bd31ea65e2d867b1207fc/assets/example_ast/fizzbuzz.png" alt="ast_graph">
</td>
</tr>
</tbody>
</table>
</div>
<p>コンパイラの開発には, 『<a href="https://www.sigbus.info/compilerbook">低レイヤを知りたい人のためのCコンパイラ作成入門</a>』を参考とさせて頂いており, この内容から習うようにして, インクリメンタルなテスト駆動開発の手段をとることとした. 今回は, 動機に示された理由により, とくに Haskell での実装を進めたかったため, セルフホストコンパイラの開発という目的には一致していなかったが, 同文書は, 具体的な開発順序や手段の詳細に関する, 多くの知見を与えてくださった. 同書の他に, コンパイラの構成には <a href="https://github.com/falgon/htcc/tree/230137475bf08265db9bd31ea65e2d867b1207fc#references">References</a>-4 を参考とした. 言語仕様は同書同様 N1570 に従い, ABI 等の仕様確認には <a href="https://github.com/falgon/htcc/tree/230137475bf08265db9bd31ea65e2d867b1207fc#references">References</a>-1 を用いた. また, より理論的な参考としては,</p>
<ul>
<li>Benjamin C. Pierce. (2002). <em>Types and Programming Languages</em>. The MIT Press</li>
<li>中田育男. (2009). <em>コンパイラの構成と最適化</em>. 朝倉書店</li>
</ul>
<p>が挙げられる. また, 今回は, <a href="https://gitmoji.carloscuesta.me/">gitmoji</a> のガイドラインに従って, コミットメッセージに絵文字を含めてみた. これに大した理由はないが, やってみた結果としては, 後にコミットを見返した際に, 視覚的な印象により, 多少はその概要をより素早く見直すことができるような気はした.</p>
<h2 id="まとめ">まとめ</h2>
<p>これは, 字句解析器や構文解析器の自動生成ツールを用いずに x86-64 アセンブラを出力する C コンパイラを作ってみるという目的の他, 私自身が関数プログラミングと圏論の関係性を学び, それをコンパイラ開発という一つの用途にあてはめたときに発見できる明確な有用性について, 私自身が議論できるようになる, という目的で行った取り組みであったが, C コンパイラはそれなりに動くところまで作れ, またモナドを利用した言語内 DSL による文脈の強制は, コンパイラ開発の場面でも強力な機能であり, その結果として, 生成されるコードの安全性を保証するに至るということも身を以て分かり, 新たな興味や疑問も多く湧いたので, 私自身にとっては非常に有意義な取り組みであった.</p>
<p>今後は, 生成コードの最適化, 質の良いエラーと警告情報の提供, アドレスサニタイザに関して深掘りしていきたい. また, いわゆるプログラム論理として言われる分野の応用による, マルチステージプログラミング<a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>や, 定理証明支援等の分野には非常に興味があるため, そのような方向へ広げていきたい.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://stackoverflow.com/questions/2906064/why-is-writing-a-compiler-in-a-functional-language-easier">Why is writing a compiler in a functional language easier? - stack overflow</a> より. なお, 同質問は <a href="https://stackoverflow.com/help/closed-questions">opnion-based</a> とされているため文中ではこれを一部の認識としている.<a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>本エントリでいう C 言語とは厳密に言えば C11 の最終ドラフトである N1570 のことを指す.<a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>例えば, C の <code>if</code>, <code>else</code> は文であるが, Rust では三項式である. また, C の <span class="math inline">\text{compound-statement}</span> は, Rust において <code>;</code> で区切られた一連の式に対応する.<a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Special thanks to <a href="https://hackage.haskell.org/package/diagrams-lib">diagrams-lib</a>, <a href="https://hackage.haskell.org/package/diagrams-svg">diagrams-svg</a> and <a href="https://hackage.haskell.org/package/diagrams-contrib">diagrams-contrib</a><a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>マルチステージプログラミングに関する記事は別途記述予定. 著者の興味としてまず目を引いたものとしては, Oleg Kiselyov. (2014). “<em>The Design and Imple-mentation of BER MetaOCaml System Descrip-tion</em>”, FLOPS 2014 であった. これは, 単刀直入に言えば, C++14 でマルチステージプログラミングを可能とするための言語拡張に関する研究である. 論文にはその理論のほかに, clang (というか LLVM コンパイラインフラストラクチャ) を用いた処理系の実装までもが示されているが, この実装に対して著者は以前<a href="https://github.com/meta-cpp/clang/pull/1">ほんの軽微なコントリビュート</a>をした.<a href="/roki.log/2020/03/17/SelfMadeCCompiler/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>ブール代数</title>
    <link href="https://roki.dev/roki.log/2019/05/8/BooleanAlgebra/index.html" />
    <id>https://roki.dev/roki.log/2019/05/8/BooleanAlgebra/index.html</id>
    <published>2019-05-29T00:00:00Z</published>
    <updated>2019-05-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>ブール代数は古典論理における命題論理と密接に関連している. 結論からいえば, 両者の違いは歴史的な背景ぐらいであり, 殆どの場合は同等の理論であるということができる<a href="/roki.log/2019/05/8/BooleanAlgebra/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. ブール代数はその応用として論理回路の構築に直接役立つことから, 計算機科学, とくにハードウェアの分野において重宝される代数系の 1 つである.</p>
<h2 id="ブール代数の公理とその定理">ブール代数の公理とその定理</h2>
<p>次に示すのはブール代数の公理系である. 公理系に関する詳細は証明理論 (TODO) の冒頭を参照のこと.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<a class="disabled" id="boolean_algebra">ブール代数</a>
</p>
</header>
<div class="m-def-content">
<p>半順序集合 <span class="math inline">(B,\lor,\land,',0,1)</span> が可補分配<a href="/roki.log/2019/03/15/Relation/#lattice_def">束</a>ならば, <span class="math inline">(B,\lor,\land,',0,1)</span> はブール代数である. すなわち, <span class="math inline">x,y,z\in B</span> に対して, 次のすべての公理を満たした <span class="math inline">(B,\lor,\land,',0,1)</span> はブール代数である.</p>
<ol type="1">
<li><span class="math inline">\htmlId{boolean_algebra1}{\rm 可換律}</span>: <span class="math inline">x\land y=y\land x,x\lor y=y\lor x</span></li>
<li><span class="math inline">\htmlId{boolean_algebra2}{\rm 分配律}</span>: <span class="math inline">(x\lor y)\land z=(x\land z)\lor(y\land z),(x\land y)\lor z=(x\lor z)\land(y\lor z)</span></li>
<li><span class="math inline">\htmlId{boolean_algebra3}{\rm 同一律}</span>: <span class="math inline">^\forall x\in L</span> に対して <span class="math inline">x\land 1=x,x\lor 0=x</span>. ここで <span class="math inline">1</span> は最大限, 単位元である. <span class="math inline">0</span> は最小限, 零元である.</li>
<li><span class="math inline">\htmlId{boolean_algebra4}{\rm 補元律}</span>: <span class="math inline">^\exists x'\in L\ {\rm s.t.}\ ^\forall x\in L, x\lor x'=1, x\land x'=0</span></li>
</ol>
</div>
</div>
<p>また, この <span class="math inline">1,0</span> からのみ成る集合をブール領域, ブール代数の下に書かれた式をブール式, <span class="math inline">n\in\mathbb{N}</span> 個のブール領域の引数をとり, 1 個のブール領域の値となる関数 <span class="math inline">f:B^n\to B</span> をブール関数という. 例えば, 2 変数ブール関数 <span class="math inline">f(x_1,x_2)</span> では <span class="math inline">x_1,x_2</span> がそれぞれ <span class="math inline">1,0</span> のいずれかとなるので, <span class="math inline">2^4=16</span> 通りの 2 変数ブール式が存在することとなる. 以下, 演算の優先順序は左結合性で <span class="math inline">',\land,\lor</span> の順とする. ただし, 括弧内の演算はより優先される.</p>
<p>さてブール代数の公理における乗法 <span class="math inline">\land</span> と加法 <span class="math inline">\lor</span>, および <span class="math inline">1, 0</span> をそれぞれ入れ替えると, 再びブール代数の公理である. これは<a href="/roki.log/2019/05/8/BooleanAlgebra/#dual_def">双対</a>の原理という公理である.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="dual_def">双対の原理</span>
</p>
</header>
<div class="m-def-content">
<p>ブール代数で成立する文/式は, そこに現れるすべての <span class="math inline">\lor ,\land,0,1</span> をそれぞれ <span class="math inline">\land,\lor ,1,0</span> で置き換えても成立する.</p>
</div>
</div>
<p>これらの公理から<a href="/roki.log/2019/05/8/BooleanAlgebra/#complement_unique">補元の一意性</a>, <a href="/roki.log/2019/05/8/BooleanAlgebra/#idempotence">べき等律</a>, <a href="/roki.log/2019/05/8/BooleanAlgebra/#bounded">有界律</a>, <a href="/roki.log/2019/05/8/BooleanAlgebra/#absorption">吸収律</a>, <a href="/roki.log/2019/05/8/BooleanAlgebra/#associative">結合律</a>, <a href="/roki.log/2019/05/8/BooleanAlgebra/#involution">対合律</a>, <a href="/roki.log/2019/05/8/BooleanAlgebra/#de_morgan">ド・モルガンの法則</a>, <a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem">シャノンの展開定理</a>が導出可能である. 以下 <span class="math inline">x,y,z\in B</span> とする.</p>
<!--more-->
<div class="m-thm">
<header class="m-thm-title">
<p>
補元の一意性
</p>
</header>
<div class="m-thm-content">
<p><span class="math inline">x</span> に対する補元は一意である.</p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
補元の一意性
</p>
</header>
<div class="m-proof-content">
<p>2 つの <span class="math inline">x</span> の補元 <span class="math inline">x'_1,x'_2</span> を仮定する. <span class="math display">\begin{aligned}
x'_1&amp;=&amp;x'_1\land1&amp;(\because {\rm \href{#boolean_algebra3}{公理 3}:同一律})\\
&amp;=&amp;x'_1\land(x\lor x'_2)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;(x'_1\land x)\lor (x'_1\land x'_2)&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;0\lor (x'_1\land x'_2)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;(x\land x'_2)\lor (x'_1\land x'_2)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;x'_2\land(x\lor x'_1)&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;x'_2\land1&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;x'_2&amp;(\because {\rm \href{#boolean_algebra3}{公理 3}:同一律})
\end{aligned}
</span> より <span class="math inline">x</span> の補元が一意であることは明らか.</p>
</div>
</div>
<div class="m-thm">
<header class="m-thm-title">
<p>
<a id="idempotence" class="disabled">べき等律</a>
</p>
</header>
<div class="m-thm-content">
<p>以下が成り立つ.</p>
<ol type="1">
<li><span class="math inline">x\land x\Leftrightarrow x</span></li>
<li><span class="math inline">x\lor x\Leftrightarrow x</span></li>
</ol>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
べき等律
</p>
</header>
<div class="m-proof-content">
<p><a href="/roki.log/2019/03/15/Relation/#proof1">束の定理</a>による.</p>
</div>
</div>
<div class="m-thm">
<header class="m-thm-title">
<p>
<a id="bounded" class="disabled">有界律</a>
</p>
</header>
<div class="m-thm-content">
<p>以下が成り立つ.</p>
<ol type="1">
<li><span class="math inline">x\lor 1=1</span></li>
<li><span class="math inline">x\land 0=0</span></li>
</ol>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
有界律
</p>
</header>
<div class="m-proof-content">
<p><span class="math display">\begin{aligned}
x\lor 1&amp;=&amp;(x\lor 1)\land1&amp;(\because {\rm \href{#boolean_algebra3}{公理 3}:同一律})\\
&amp;=&amp;(x\lor 1)(x\lor x')&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;x\lor (1\land x')&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;x\lor x'&amp;(\because {\rm \href{#boolean_algebra1}{公理1}, \href{#boolean_algebra3}{公理3}:可換律, 同一律})\\
&amp;=&amp;1\\
x\land0&amp;=&amp;x\land x\land x'&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;x\land x'&amp;(\because {\rm 定理:\href{#idempotence}{べき等律}})\\
&amp;=&amp;0&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})
\end{aligned}
</span></p>
</div>
</div>
<div class="m-thm">
<header class="m-thm-title">
<p>
<a id="absorption" class="disabled">吸収律</a>
</p>
</header>
<div class="m-thm-content">
<p>以下が成り立つ.</p>
<p><span class="math display">x\lor x\land y=x\land(x\lor y)=x</span></p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
吸収律
</p>
</header>
<div class="m-proof-content">
<p><span class="math display">\begin{aligned}
x\lor x\land y&amp;=&amp;(x\land1)\lor (x\land y)&amp;(\because {\rm \href{#boolean_algebra3}{公理3}: 同一律})\\
&amp;=&amp;x\land(1\lor y)&amp;(\because {\rm \href{#boolean_algebra2}{公理2}:分配律})\\
&amp;=&amp;x\land1&amp;(\because {\rm \href{#boolean_algebra1}{公理 1}: 可換律, 定理: \href{#bounded}{有界律}} )\\
&amp;=&amp;x&amp;(\because {\rm\href{#boolean_algebra3}{公理 3}: 同一律})\\
x\land(x\lor y)&amp;=&amp;(x\lor 0)(x\lor y)&amp;(\because {\rm \href{#boolean_algebra3}{公理3}: 同一律})\\
&amp;=&amp;(0\land y)\lor x&amp;(\because {\rm \href{#boolean_algebra2}{公理2}: 分配律})\\
&amp;=&amp;x\lor 0&amp;(\because \rm{\href{#boolean_algebra1}{公理1}: 可換律,定理: \href{#bounded}{有界律}})\\
&amp;=&amp;x&amp;(\because \rm{\href{#boolean_algebra3}{公理3}: 同一律})
\end{aligned}</span></p>
</div>
</div>
<div class="m-thm">
<header class="m-thm-title">
<p>
<a id="associative" class="disabled">結合律</a>
</p>
</header>
<div class="m-thm-content">
<p>以下が成り立つ.</p>
<p><span class="math display">x\lor(y\lor z)=(x\lor y)\lor z</span></p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
結合律
</p>
</header>
<div class="m-proof-content">
<p><span class="math inline">A=x\lor (y\lor z), B=(x\lor y)\lor z</span> とおく. このとき,</p>
<p><span class="math display">\begin{aligned}
x\land A&amp;=&amp;x\land(x\lor (y\lor z))\\
&amp;=&amp;x&amp;(\because {\rm 定理: \href{#absorption}{吸収律}})\\
x\land B&amp;=&amp;x\land((x\lor y)\lor z)\\
&amp;=&amp;x\land(x\lor y)\lor x\land z&amp;(\because {\rm \href{#boolean_algebra2}{公理2}: 分配律})\\
&amp;=&amp;x\lor x\land z&amp;(\because {\rm 定理: \href{#absorption}{吸収律}})\\
&amp;=&amp;x&amp;(\because {\rm 定理: \href{#absorption}{吸収律}})
\end{aligned}</span></p>
<p>ゆえに <span class="math display">x\land A=x\land B=x\tag{L1}</span> また,</p>
<p><span class="math display">\begin{aligned}
x'\land A&amp;=&amp;x'\land(x\lor (y\lor z))\\
&amp;=&amp;x'\land x\lor x'\land(y\lor z)&amp;(\because  {\rm \href{#boolean_algebra2}{公理2}: 分配律})\\
&amp;=&amp;x'\land(y\lor z)\lor 0&amp;(\because {\rm \href{#boolean_algebra1}{公理1}, \href{#boolean_algebra4}{公理 4}: 可換律, 補元律})\\
&amp;=&amp;x'\land(y\lor z)&amp;(\because {\rm \href{#boolean_algebra3}{公理3}: 同一律})\\
x'\land B&amp;=&amp;x'\land((x\lor y)\lor z)\\
&amp;=&amp;x'\land(x\lor y)\lor x'\land z&amp;(\because {\rm \href{#boolean_algebra2}{公理2}: 分配律})\\
&amp;=&amp;(x'\land x\lor x'\land y)\lor x'\land z&amp;(\because {\rm \href{#boolean_algebra2}{公理2}: 分配律})\\
&amp;=&amp;(0\lor x'\land y)\lor x'\land z&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;x'\land y\lor x'\land z&amp;(\because {\rm \href{#boolean_algebra3}{公理3}: 同一律})\\
&amp;=&amp;x'\land(y\lor z)&amp;(\because {\rm \href{#boolean_algebra2}{公理2}: 分配律})
\end{aligned}</span></p>
<p>ゆえに <span class="math display">x'\land A=x'\land B=x'\land(y\lor z)\tag{L2}</span> 従って,</p>
<p><span class="math display">\begin{aligned}
A&amp;=&amp;A\land1&amp;(\because {\rm \href{#boolean_algebra3}{公理3}: 同一律})\\
&amp;=&amp;A\land(x\lor x')&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;A\land x\lor A\land x'&amp;(\because {\rm \href{#boolean_algebra2}{公理2}: 分配律})\\
&amp;=&amp;x\land A\lor x'\land A&amp;(\because {\rm \href{#boolean_algebra1}{公理1}: 可換律})\\
&amp;=&amp;x\land B\lor x'\land B&amp;(\because,\ {\rm より})\\
&amp;=&amp;B(x\lor x')&amp;(\because {\rm \href{#boolean_algebra2}{公理2}: 分配律})\\
&amp;=&amp;B\land1&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;B&amp;(\because {\rm \href{#boolean_algebra3}{公理3}: 同一律})
\end{aligned}</span></p>
<p>また, 双対の原理より <span class="math inline">x(y\land z)=(x\land y)\land z</span>.</p>
</div>
</div>
<div class="m-thm">
<header class="m-thm-title">
<p>
<a id="involution" class="disabled">対合律</a>
</p>
</header>
<div class="m-thm-content">
<p>以下が成り立つ.</p>
<p><span class="math display">(x')'=x</span></p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
対合律
</p>
</header>
<div class="m-proof-content">
<p><span class="math display">\begin{aligned}
(x')'&amp;=&amp;(x')'\lor 0&amp;(\because \rm{\href{#boolean_algebra3}{公理3}: 同一律})\\
&amp;=&amp;(x')'\lor x\land x'&amp;(\because {\href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;((x')'\lor x)((x')'\lor x')&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;(x\lor (x')')\land1&amp;(\because {\rm \href{#boolean_algebra1}{公理1}, \href{#boolean_algebra4}{公理 4}:可換律, 補元律})\\
&amp;=&amp;(x\lor (x')')(x\lor x')&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}: 補元律})\\
&amp;=&amp;x\lor ((x')'\land x')&amp;(\because {\rm \href{#boolean_algebra2}{公理2}:分配律})\\
&amp;=&amp;x\lor 0&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;x&amp;(\because {\rm \href{#boolean_algebra3}{公理3}: 同一律})
\end{aligned}</span></p>
</div>
</div>
<div class="m-thm">
<header class="m-thm-title">
<p>
<a id="de_morgan" class="disabled">ド・モルガンの法則</a>
</p>
</header>
<div class="m-thm-content">
<p>以下が成り立つ. <span class="math display">(x\lor y)'=x'\land y'</span></p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
ド・モルガンの法則
</p>
</header>
<div class="m-proof-content">
<p><span class="math inline">x'\land y'</span> が <span class="math inline">(x\lor y)</span> の補元でなければならない. すなわち, <a href="/roki.log/2019/05/8/BooleanAlgebra/#boolean_algebra4">公理4</a>: 補元律より <span class="math inline">(x\lor y)\lor (x'\land y')=1</span> および <span class="math inline">(x\lor y)\land(x'\land y')=0</span> が同時に成り立つことを示せばよい.</p>
<p><span class="math display">\begin{aligned}
(x\lor y)\lor (x'\land y')&amp;=&amp;((x\lor y)\lor x')((x\lor y)\lor y')&amp;(\because {\rm \href{#boolean_algebra2}{公理2}:分配律})\\
&amp;=&amp;(y\lor (x\lor x'))(x\lor (y\lor y'))&amp;(\because {\rm \href{#boolean_algebra1}{公理1}: 可換律, 定理: \href{#associative}{結合律}})\\
&amp;=&amp;(y\lor 1)(x\lor 1)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;1\land1&amp;(\because {\rm 定理: \href{#bounded}{有界律}} )\\
&amp;=&amp;1&amp;(\because {\rm 定理:\href{#idempotence}{べき等律}})\\
(x\lor y)\land(x'\land y')&amp;=&amp;(x'\land y')\land(x\lor y)&amp;(\because {\rm \href{#boolean_algebra1}{公理1}: 可換律})\\
&amp;=&amp;((x'\land y')\land x)\lor ((x'\land y')\land y)&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;(y'\land(x\land x'))\lor (x'\land(y\land y'))&amp;(\because {\rm \href{#boolean_algebra1}{公理1}: 可換律, 定理: \href{#associative}{結合律}})\\
&amp;=&amp;(y'\lor 0)\lor (x'\land1)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}: 補元律})\\
&amp;=&amp;0\lor 0&amp;(\because {\rm 定理: \href{#bounded}{有界律}} )\\
&amp;=&amp;0&amp;(\because {\rm 定理:\href{#idempotence}{べき等律}})
\end{aligned}</span></p>
<p>また, <a href="/roki.log/2019/05/8/BooleanAlgebra/#dual_def">双対の原理</a>より <span class="math inline">(x\land y)'=x'\lor y'</span>.</p>
</div>
</div>
<div class="m-thm">
<header class="m-thm-title">
<p>
<a id="chanon_theorem" class="disabled">シャノン展開</a>
</p>
</header>
<div class="m-thm-content">
<p>任意の <span class="math inline">n</span> 変数ブール関数 <span class="math inline">f(x_1,x_2,\cdots,x_n)</span> を <span class="math inline">x_1</span> について, 次のように展開できる.</p>
<p><span class="math display">\begin{aligned}
f(x_1,x_2,\cdots,x_n)&amp;=&amp;(x'_1\lor x_1)\land f(x_1,x_2,\cdots,x_n)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}, \href{#boolean_algebra3}{公理 3} :補元律, 同一律})\\
&amp;=&amp;x'_1\land f(x_1,x_2,\cdots,x_n)\lor x_1\land f(x_1,x_2,\cdots,x_n)&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;x'_1\land f(0,x_2,\cdots,x_n)\lor x_1\land f(1,x_2,\cdots,x_n)&amp;(\because \href{#chanon_theorem_proof}{以下に証明})
\end{aligned}</span></p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
<a id="chanon_theorem" class="disabled">シャノン展開</a>
</p>
</header>
<div class="m-proof-content">
<p><span class="math inline">x_1=0</span> のとき, <span class="math display">f(0,x_2,\cdots,x_n)=1\land f(0,x_2,\cdots,x_n)\lor 0\land f(1,x_2,\cdots,x_n)=f(0,x_2,\cdots,x_n)</span> <span class="math inline">x_1=1</span> のとき, <span class="math display">f(1,x_2,\cdots,x_n)=0\land f(0,x_2,\cdots,x_n)\lor 1\land f(1,x_2,\cdots,x_n)=f(1,x_2,\cdots,x_n)</span></p>
</div>
</div>
<p>例として, <span class="math inline">f(x_1,x_2,x_3)=x_1\land x_2\lor x_2\land x_3\lor x_1\land x_3</span> を <span class="math inline">x_1</span> について展開すると,</p>
<p><span class="math display">\begin{aligned}
f(x_1,x_2,x_3)&amp;=&amp;x_1\land x_2\lor x_2\land x_3\lor x_1\land x_3\\
&amp;=&amp;(x'_1\lor x_1)\land f(x_1,x_2,x_3)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}, \href{#boolean_algebra3}{公理 3} :補元律, 同一律})\\
&amp;=&amp;x'_1\land f(x_1,x_2,x_3)\lor x_1\land f(x_1,x_2,x_3)&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;x'_1\land f(0,x_2,x_3)\lor x_1\land f(1,x_2,x_3)&amp;(\because {\rm 定理: \href{#chanon_theorem}{シャノンの展開定理}})\\
&amp;=&amp;x'_1\land x_2\land x_3\lor x_1\land x_2\lor x_2\land x_3\lor x_3&amp;(\because {\rm \href{#boolean_algebra3}{公理 3}:同一律})\\
&amp;=&amp;x'_1\land x_2\land x_3\lor x_1\land x_2\lor x_3&amp;(\because {\rm \href{#boolean_algebra1}{公理1}: 可換律, 定理: \href{#absorption}{吸収律}})\\
\end{aligned}</span></p>
<p>となる. また<a href="/roki.log/2019/05/8/BooleanAlgebra/dual_def">双対の原理</a>より,</p>
<p><span class="math display">\begin{aligned}
f(x_1,x_2,\cdots,x_n)&amp;=&amp;(x_1\land x'_1)\lor f(x_1,x_2,\cdots,x_n)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}, \href{#boolean_algebra3}{公理 3} :補元律, 同一律})\\
&amp;=&amp;(x_1\lor f(x_1,x_2,\cdots,x_n))\land(x'_1\lor f(x_1,x_2,\cdots,x_n))&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;(x_1\lor f(0,x_2,\cdots,x_n))\land(x'_1\lor f(1,x_2,\cdots,x_n))&amp;(\because {\rm \href{#chanon_theorem_proof}{上記証明}の\href{#dual_def}{双対}})
\end{aligned}</span></p>
<p>この展開をシャノン双対展開という.</p>
<h2 id="標準形">標準形</h2>
<p>異なる表現のなされたブール式が同値であるかを即座に断定することは, 一般的に困難であることが多い<a href="/roki.log/2019/05/8/BooleanAlgebra/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. ここで, ブール式を一意に表す方法が決まっていれば, 即座に同値であるか判断がしやすく, 便利である. ブール代数では主に 2 つの形式が決められており, その形式への変形を標準化, また正規化という. 以下, <span class="math inline">n</span> 変数ブール関数 <span class="math inline">f(x_1,x_2,\cdots,x_n)</span> において, <span class="math inline">x_1,x_2,\cdots,x_n</span> を入力変数, また入力変数およびその否定をリテラルという. さらに <span class="math inline">n</span> 個の入力変数に対し, <span class="math inline">k</span> 番目のリテラル <span class="math inline">x_k^{e_k}\ (1\leq k\leq n)</span> を次のように表す.</p>
<p><span class="math display">\begin{aligned}
x^{e_k}_k=\begin{cases}
x_k&amp;(=x^1_k)&amp;e_k=1{\rm\ のとき}\\
x'_k&amp;(=x^0_k)&amp;e_k=0{\rm\ のとき}
\end{cases}
\end{aligned}</span></p>
<h3 id="加法標準形-主加法標準形">加法標準形, 主加法標準形</h3>
<p><span class="math inline">f(x_1,x_2,\cdots,x_n)</span> を <span class="math inline">x_1,x_2</span> について<a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem">シャノン展開</a>すると,</p>
<p><span class="math display">\begin{aligned}
f(x_1,x_2,\cdots,x_n)&amp;=&amp;x'_1\land x'_2\land f(0,0,\cdots,x_n)\\
&amp;&amp;\lor x'_1\land x_2\land f(0,1,\cdots,x_n)\\
&amp;&amp;\lor x_1\land x'_2\land f(1,0,\cdots,x_n)\\
&amp;&amp;\lor x_1\land x_2\land f(1,1,\cdots,x_n)
\end{aligned}</span></p>
<p>となる. 従って, 全入力変数 <span class="math inline">x_1,x_2,\cdots,x_n</span> について<a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem">シャノン展開</a>すると,</p>
<p><span class="math display">\begin{aligned}
f(x_1,x_2,\cdots,x_n)&amp;=&amp;x'_1\land x'_2\land\cdots\land x'_n\land f(0,0,\cdots,0)\\
&amp;&amp;\lor x'_1\land x'_2\land\cdots\land x_n\land f(0,0,\cdots, 1)\\
&amp;&amp;\lor\cdots\\ 
&amp;&amp;\lor x_1\land x_2\land\cdots\land x'_n\land f(1,1,\cdots,0)\\
&amp;&amp;\lor x_1\land x_2\land\cdots\land x_n\land f(1,1,\cdots,1)
\end{aligned}</span></p>
<p>となる (<a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem">シャノンの定理</a>より数学的帰納法により証明できるが, 省略). これを以下のように定義する.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<a id="minimum_term_expansion" class="disabled">最小項展開</a>
</p>
</header>
<div class="m-def-content">
<p><span class="math inline">n</span> 変数ブール関数 <span class="math inline">f(x_1,x_2,\cdots,x_n)</span> のすべての入力変数 <span class="math inline">x_1,x_2,\cdots,x_n</span> について, <a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem">シャノン展開</a>した形式 <span class="math display">f(x_1,x_2,\cdots,x_n)=
\bigvee_{(e_1,e_2,\cdots,e_n)\in B^n}f(e_1,e_2,\cdots,e_n)\land\bigwedge_{i=1}^{n}x_i^{e_i}\tag{1}</span> は <span class="math inline">f(x_1,x_2,\cdots,x_n)</span> の最小項展開である. なお, このときの項数は <span class="math inline">2^n</span> となる.</p>
</div>
</div>
<p>これを踏まえ, 加法標準形および主加法標準形を導入する.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<a id="DNF_PDNF" class="disabled">加法標準形, 主加法標準形</a>
</p>
</header>
<div class="m-def-content">
<ul>
<li>加法標準形 (disjunctive normal form: DNF) は, ブール式のリテラル, または 2 つ以上のリテラルの積の和のことをいう. ここで, 2 つ以上のリテラルの積で同じ入力変数を 2 度以上含まない論理式を基本積, また標準項という. 基本積のうち, すべての入力変数を含むブール式を最小項という. すなわち, 上記<a href="/roki.log/2019/05/8/BooleanAlgebra/#minimum_term_expansion">最小項展開</a>の <span class="math inline">\displaystyle\bigwedge_{i=1}^nx^{e_i}_i</span> は最小項である.</li>
<li>主加法標準形 (principal disjunctive normal form: PDNF) は, ブール関数を<a href="/roki.log/2019/05/8/BooleanAlgebra/#minimum_term_expansion">最小項展開</a>した形式, すなわち<a href="/roki.log/2019/05/8/BooleanAlgebra/#minimum_term_expansion">最小項展開</a>の形式である.</li>
</ul>
</div>
</div>
<p>例えば, 否定論理積 <span class="math inline">\mid</span> を PDNF で表すとしよう. 否定論理和は 2 項演算子なので, その PDNF は 2 変数ブール関数を最小項展開した形となる.</p>
<p><span class="math display">f(x_1,x_2)=f(0,0)\land x'_1\land x'_2\lor f(0,1)x'_1\land x_2\lor f(1,0)\land x_1\land x'_2\lor f(1,1)\land x_1\land x_2</span></p>
<p>便宜上, 2 項演算子 <span class="math inline">\mid</span> を最小項展開した形を <span class="math inline">f_\mid(x_1,x_2)</span> で表すこととする. あとは<a href="/roki.log/2019/05/8/BooleanAlgebra/#truthtable2">真理値表 2</a> の <span class="math inline">\mid</span> の列のとおりに <span class="math inline">f_\mid(x_1,x_2)</span> の値を決めてやればよいので</p>
<p><span class="math display">
\begin{aligned}
f_\mid(x_1,x_2)&amp;=&amp;1\land x'_1\land x'_2\lor 1\land x'_1\land x_2\lor 1\land x_1\land x'_2\lor 0\land x_1\land x_2\\
&amp;=&amp;x'_1\land x'_2\lor x'_1\land x_2\lor x_1\land x'_2
\end{aligned}
</span></p>
<p>従って, 否定論理積の PDNF は <span class="math inline">x'_1\land x'_2\lor x'_1\land x_2\lor x_1\land x'_2</span> となる. この操作を振り返ると, 真理値表から PDNF を書くためには, 結果が <span class="math inline">1</span> となっている入力変数の全パターンに対して, 元の入力変数の値が <span class="math inline">1</span> ならそのまま, <span class="math inline">0</span> ならその補元をとり, それらすべての和を取ればよいことがわかる. 何故ならば, 結果が <span class="math inline">0</span> となる部分は, <a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem_proof">シャノンの展開定理の証明</a>でも示したように消えてしまうからである. 同じようにして, 否定論理和, 排他的論理和も<a href="/roki.log/2019/05/8/BooleanAlgebra/#truthtable2">真理値表 2</a> の <span class="math inline">\downarrow,\oplus</span> の列をみると, <span class="math inline">1</span> となる入力のパターンから</p>
<p><span class="math display">
\begin{aligned}
f_{\downarrow}(x_1,x_2)&amp;=&amp;x'_1\land x'_2\\
f_{\oplus}(x_1,x_2)&amp;=&amp;x_1\land x'_2\lor x'_1\land x_2\\
\end{aligned} 
</span></p>
<p>となる. すなわち, 真理値表で表現できるブール式は PDNF で表せるということである<a href="/roki.log/2019/05/8/BooleanAlgebra/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>次に, 任意の論理式から PDNF に変換することを考える. 結論からいうと, 次の手順に従えば PDNF へ機械的に変換できることが知られている.</p>
<ol type="1">
<li>ブール式全体を基本項による積の和の形にする (分配律等を利用)</li>
<li>最小項でない基本項に対し, その基本項に含まれないすべてのリテラル <span class="math inline">x_i</span> について <span class="math inline">(x_i\land x'_i)</span> を乗ずる</li>
<li>分配律等に従い展開して, 冗長な項を除去する</li>
</ol>
<p>以下, PDNF で表されたブール式を <span class="math inline">f(x_1,x_2,\cdots,x_n)_{\rm P D N F}</span> と書くこととする. 例えば, ブール式 <span class="math inline">f(x_1,x_2)=x_1\land x_2\land x_1\lor x_2</span> を PDNF で表すとすると,</p>
<p><span class="math display">
\begin{aligned}
f(x_1,x_2)&amp;=&amp;x_1\land x_2\land x_1\lor x_2\\
&amp;=&amp;x_1\land x_1\land x_2\lor x_2&amp;(\because {\rm\href{#boolean_algebra1}{公理1}: 可換律})\\
&amp;=&amp;x_1\land x_2\lor x_2&amp;(\because {\rm 定理:\href{#idempotence}{べき等律}})\\
&amp;=&amp;x_1\land x_2\lor 1\land x_2&amp;(\because {\rm \href{#boolean_algebra3}{公理 3}:同一律})\\
&amp;=&amp;x_1\land x_2\lor (x_1\lor x_1')\land x_2&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;x_1\land x_2\lor x_1\land x_2\lor x_1'\land x_2&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\ 
&amp;=&amp;x_1\land x_2\lor x_1'\land x_2&amp;(\because {\rm 定理:\href{#idempotence}{べき等律}})
\end{aligned}
</span></p>
<p>従って <span class="math display">f(x_1,x_2)_{\rm P D N F}=x_1\land x_2\lor x_1'\land x_2</span> となる. 例としてもう 1 つ, <span class="math inline">f(x_1,x_2,x_3)=x_1\land x_2'\land x_3\lor x_1\land x'_3\lor x_2\land x'_3</span> としたときの PDNF は</p>
<p><span class="math display">
\begin{aligned}
f(x_1,x_2,x_3)&amp;=&amp;x_1\land x'_2\land x_3\lor x\land x'_3\lor x_2\land x'_3\\
&amp;=&amp;x_1\land x'_2\land x_3\lor x_1\land(x_2\lor x'_2)\land x'_3\lor (x_1\lor x_1')\land x_2\land x'_3&amp;(\because {\rm \href{#boolean_algebra3}{公理 3}, \href{#boolean_algebra4}{公理 4}: 同一律, 補元律} )\\
&amp;=&amp;x_1\land x'_2\land x_3\lor x_1\land x_2\land x'_3\lor x_1\land x'_2\land x'_3\lor x_1\land x_2\land x'_3\lor x'_1\land x_2\land x'_3&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;x_1\land x'_2\land x_3\lor x_1\land x_2\land x'_3\lor x_1\land x'_2\land x'_3\lor x'_1\land x_2\land x'_3&amp;(\because {\rm 定理: \href{#idempotence}{べき等律}})
\end{aligned}
</span></p>
<p>従って <span class="math display">f(x_1,x_2,x_3)_{\rm P D N F}=x_1\land x'_2\land x_3\lor x_1\land x_2\land x'_3\lor x_1\land x'_2\land x'_3\lor x'_1\land x_2\land x'_3</span> となる.</p>
<h3 id="乗法標準形-主乗法標準形">乗法標準形, 主乗法標準形</h3>
<p><span class="math inline">f(x_1,x_2,\cdots,x_n)</span> を <span class="math inline">x_1,x_2</span> について<a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem">シャノン双対展開</a>すると,</p>
<p><span class="math display">
\begin{aligned}
f(x_1,x_2,\cdots,x_n)&amp;=&amp;(x_1\lor x_2\lor f(0,0,\cdots,x_n))\\
&amp;&amp;\land (x_1\lor x'_2\lor f(0,1,\cdots,x_n))\\
&amp;&amp;\land (x'_1\lor x_2\lor f(1,0,\cdots,x_n))\\
&amp;&amp;\land (x'_1\lor x'_2\lor f(1,1,\cdots,x_n))
\end{aligned}
</span></p>
<p>となる. 従って, 全入力変数 <span class="math inline">x_1,x_2,\cdots,x_n</span> について<a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem">シャノン双対展開</a>すると,</p>
<p><span class="math display">
\begin{aligned}
f(x_1,x_2,\cdots,x_n)&amp;=&amp;(x_1\lor x_2\lor\cdots\lor x_n\lor f(0,0,\cdots,0))\\
&amp;&amp;\land(x_1\lor x_2\lor\cdots\lor x'_n\lor f(1,0,\cdots,0))\\
&amp;&amp;\land\cdots\\
&amp;&amp;\land(x'_1\lor x'_2\lor\cdots x_n\lor f(1,1,\cdots,0))\\
&amp;&amp;\land(x'_1\lor x'_2\lor\cdots x'_n\lor f(1,1,\cdots,1))
\end{aligned}
</span></p>
<p>となる (<a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem">シャノンの定理</a>より数学的帰納法により証明できるが, 省略). これを以下のように定義する.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<a id="maximum_term_expansion" class="disabled">最大項展開</a>
</p>
</header>
<div class="m-def-content">
<p><span class="math inline">n</span> 変数ブール関数 <span class="math inline">f(x_1,x_2,\cdots,x_n)</span> のすべての入力変数 <span class="math inline">x_1,x_2,\cdots,x_n</span> について, <a href="/roki.log/2019/05/8/BooleanAlgebra/#chanon_theorem">シャノン双対展開</a>した形式 <span class="math display">f(x_1,x_2,\cdots,x_n)=
\bigwedge_{(e_1,e_2,\cdots,e_n)\in B^n}(f(e_1,e_2,\cdots,e_n)\lor\bigvee_{i=1}^{n}x_i^{e'_i})\tag{2}</span> は <span class="math inline">f(x_1,x_2,\cdots,x_n)</span> の最大項展開である. なお, このときの項数は <span class="math inline">2^n</span> となる.</p>
</div>
</div>
<p>これを踏まえ, 乗法標準形, 主乗法標準形を導入する.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<a id="CNF_PCNF" class="disabled">乗法標準形, 主乗法標準形</a>
</p>
</header>
<div class="m-def-content">
<ul>
<li>乗法標準形 (CNF: conjunctive normal form) は, ブール式のリテラル, または 2 つ以上のリテラルの和の積のことをいう. ここで, 2 つ以上のリテラルの和で同じ入力変数を 2 度以上含まないブール式を基本和, また標準項という. 基本和のうち, すべての入力変数を含むブール式を最大項という. すなわち, 上記<a href="/roki.log/2019/05/8/BooleanAlgebra/#maximum_term_expansion">最大項展開</a>の <span class="math inline">\displaystyle\bigvee_{i=1}^{n}x_i^{e'_i}</span> は最大項である.</li>
<li>主乗法標準形 (principal conjunctive normal form: PCNF) は, ブール関数を<a href="/roki.log/2019/05/8/BooleanAlgebra/#maximum_term_expansion">最大項展開</a>した形式, すなわち<a href="/roki.log/2019/05/8/BooleanAlgebra/#maximum_term_expansion">最大項展開</a>の形式である.</li>
</ul>
</div>
</div>
<p>例えば, 否定論理積 <span class="math inline">\mid</span> を PCNF で表すとしよう. 否定論理積は 2 項演算子なので, その PCNF は 2 変数ブール関数を最大項展開した形となる.</p>
<p><span class="math display">
f(x_1,x_2)=
(x_1\lor x_2\lor f(0,0))\land (x_1\lor x'_2\lor f(0,1))\land(x'_1\lor x_2\lor f(1,0))\land(x'_1\lor x'_2\lor f(1,1))</span></p>
<p>2 項演算子 <span class="math inline">\mid</span> を最大項展開した式 <span class="math inline">f_{\mid}(x_1,x_2)</span> は, <a href="/roki.log/2019/05/8/BooleanAlgebra/#truthtable2">真理値表 2</a> の <span class="math inline">\mid</span> の列のとおりに <span class="math inline">f_{\mid}(x_1,x_2)</span> の値を決めてやればよいので</p>
<p><span class="math display">
\begin{aligned}
f_{\mid}(x_1,x_2)&amp;=&amp;(x_1\lor x_2\lor 1)\land (x_1\lor x'_2\lor 1)\land(x'_1\lor x_2\lor 1)\land(x'_1\lor x'_2\lor 0)\\
&amp;=&amp;x'_1\lor x'_2
\end{aligned}
</span></p>
<p>従って, 否定論理積の PCNF は <span class="math inline">x'_1\lor x'_2</span> となる. この操作を振り返ると, 真理値表から PCNF を書くためには, 結果が <span class="math inline">0</span> となっている入力変数の全パターンに対して, 元の入力変数の値が <span class="math inline">1</span> なら補元をとり, <span class="math inline">0</span> ならそのままで和を取り, それらすべての積を取ればよいことがわかる. 何故ならば, 結果が <span class="math inline">1</span> となる部分は, 和の性質, すなわち<a href="/roki.log/2019/05/8/BooleanAlgebra/#boolean_algebra3">公理 2: 同一律</a>より消えてしまうからである. 同じようにして, 否定論理和, 排他的論理和も<a href="/roki.log/2019/05/8/BooleanAlgebra/#truthtable2">真理値表 2</a> の <span class="math inline">\downarrow,\oplus</span> の列をみると, <span class="math inline">0</span> となる入力のパターンから</p>
<p><span class="math display">
\begin{aligned}
f_{\downarrow}(x_1,x_2)&amp;=&amp;(x'_1\lor x'_2)\land(x'_1\lor x_2)\land(x_1\lor x'_2)\\
f_{\oplus}(x_1,x_2)&amp;=&amp;(x'_1\lor x'_2)\land(x_1\lor y_1)
\end{aligned}
</span></p>
<p>となる. すなわち, 真理値表で表現できるブール式は, PCNF で表せるということである<sup><a class="footnote-ref" href="/roki.log/2019/05/8/BooleanAlgebra/#fn-5">5</a></sup>. 次に, 任意の論理式から PCNF に変換することを考える. 結論からいうと, 次の手順に従えば PCNF へ機械的に変換できることが知られている.</p>
<ol type="1">
<li>ブール式全体を基本項による和の積の形にする (分配律等を利用)</li>
<li>最大項でない基本項に対し, その基本項に含まれないすべてのリテラル <span class="math inline">x_i</span> について <span class="math inline">x_i\land x'_i</span> を乗ずる</li>
<li>分配律等に従い展開して, 冗長な項を除去する</li>
</ol>
<p>以下, PCNF で表されたブール式を <span class="math inline">f(x_1,x_2,\cdots,x_n)_{\rm P C N F}</span> と書くこととする. 例えば, ブール式 <span class="math inline">f(x_1,x_2,x_3)=x_1\land(x'_2\land x_3)'</span> を PCNF で表すとすると,</p>
<p><span class="math display">
\begin{aligned}
f(x_1,x_2,x_3)&amp;=&amp;x_1\land(x'_2\land x_3)'\\
&amp;=&amp;x_1\land(x_2\lor x'_3)&amp;(\because {\rm 定理: \href{#de_morgan}{ド・モルガンの法則}})\\
&amp;=&amp;(x_1\lor x_2\land x'_2)\land(x_2\lor x'_3)&amp;(\because {\rm \href{#boolean_algebra3}{公理 3}:同一律})\\
&amp;=&amp;(x_1\lor x_2)\land(x_1\lor x'_2)\land(x_2\lor x'_3)&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;(x_1\lor x_2\lor x_3\land x'_3)\land(x_1\lor x'_2\lor x_3\land x'_3)\land(x_1\land x'_1\lor x_2\land x'_3)&amp;(\because {\rm \href{#boolean_algebra3}{公理 3}:同一律})\\
&amp;=&amp;(x_1\lor x_2\lor x_3)\land(x_1\lor x_2\lor x'_3)\land(x_1\lor x'_2\lor x_3)\\
&amp;&amp;\land(x_1\lor x'_2\lor x'_3)\land(x_1\lor x_2\lor x'_3)\land(x'_1\lor x_2\lor x'_3)&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;(x_1\lor x_2\lor x_3)\land(x_1\lor x_2\lor x'_3)\land(x_1\lor x'_2\lor x_3)\\
&amp;&amp;\land(x_1\lor x'_2\lor x'_3)\land(x'_1\lor x_2\lor x'_3)&amp;(\because {\rm 定理:\href{#idempotence}{べき等律}})
\end{aligned}
</span></p>
<p>従って <span class="math display">f(x_1,x_2,x_3)_{\rm P C N F}=(x_1\lor x_2\lor x_3)\land(x_1\lor x_2\lor x'_3)\land(x_1\lor x'_2\lor x_3)\land(x_1\lor x'_2\lor x'_3)\land(x'_1\lor x_2\lor x'_3)</span></p>
<p>となる. 例としてもう 1 つ, <span class="math inline">f(x_1,x_2,x_3)=x_1\land x'_2\lor x_2\land x_3</span> としたときの PCNF は</p>
<p><span class="math display">
\begin{aligned}
f(x_1,x_2,x_3)&amp;=&amp;x_1\land x'_2\lor x_2\land x_3\\
&amp;=&amp;(x_1\land x'_2\lor x_2)\land(x_1\land x'_2\lor x_3)&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})\\
&amp;=&amp;(x_1\lor x_2)\land(x_1\lor x_3)\land(x'_2\lor x_3)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;(x_1\lor x_2\lor x_3\land x'_3)\land(x_1\lor x_2\land x'_2\lor x_3)\land(x_1\land x'_1\lor x'_2\lor x_3)&amp;(\because {\rm \href{#boolean_algebra4}{公理 4}:補元律})\\
&amp;=&amp;(x_1\lor x_2\lor x_3)\land(x_1\lor x_2\lor x'_3)\land(x_1\lor x'_2\lor x_3)\land(x'_1\lor x'_2\lor x_3)&amp;(\because {\rm \href{#boolean_algebra2}{公理 2}:分配律})
\end{aligned}
</span></p>
<p>従って <span class="math display">f(x_1,x_2,x_3)_{\rm P C N F}=(x_1\lor x_2\lor x_3)\land(x_1\lor x_2\lor x'_3)\land(x_1\lor x'_2\lor x_3)\land(x'_1\lor x'_2\lor x_3)</span> となる.</p>
<h2 id="簡単化">簡単化</h2>
<p>ブール式を簡単化する方法について見ていく.</p>
<h3 id="カルノー図">カルノー図</h3>
<p>例えばブール関数が <span class="math display">f(x_1,x_2)=x_1\land x'_2\lor x'_1\land x'_2\lor x_1\land x'_2\lor x_1\land x_2 \tag{3}</span> と与えられたとき, 式変形をしていくと簡単化できることがわかる. 事実, <span class="math inline">(3)=(x_1\lor x'_1)\land x'_2\lor x_1\land(x'_2\lor x_2)=x'_2\lor x_1</span> である. このような, <a href="/roki.log/2019/05/8/BooleanAlgebra/#boolean_algebra4">公理4: 補元律</a>を用いた式変形は, カルノー図という図式を用いることで視覚的に捉えることができる. カルノー図は, 真理値表を 2 次元的に並べる形をしており, 例えば式 <span class="math inline">(3)</span> をカルノー図で表すと次のようになる.</p>
<table>
<caption>カルノー図 1</caption>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">x_1\backslash x_2</span></th>
<th style="text-align: center;"><span class="math inline">0</span></th>
<th style="text-align: center;"><span class="math inline">1</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
</tr>
</tbody>
</table>
<p>緑色の表示となっているセルの部分それぞれが最小項を表しており, 元の論理関数に含まれる最小項のセルには <span class="math inline">1</span>, 含まれないセルには <span class="math inline">0</span> を記述する<a href="/roki.log/2019/05/8/BooleanAlgebra/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>ことで<a href="/roki.log/2019/05/8/BooleanAlgebra/#karnaugh1">上図</a>のようになる. このとき, 緑色の表示となっているセルの部分の個数は <span class="math inline">2^n</span> である. これらをまとめることが, 冗長な変数の削除に対応するのである. カルノー図をみて <span class="math inline">1</span> となるセルの和を書き下すことは, PDNF を書くことと同値である式 (<span class="math inline">(3)</span> は元から PDNF である. <a href="/roki.log/2019/05/8/BooleanAlgebra/#karnaugh1">カルノー図 1</a> から結果として, これが導出できる).</p>
<p>カルノー図の隣接するセルの間では, 全ての変数のうちのどれか 1 つの <span class="math inline">1</span> か <span class="math inline">0</span> が変わった結果となっているので, <a href="/roki.log/2019/05/8/BooleanAlgebra/#boolean_algebra4">公理4: 補元律</a>を利用してまとめることができるのである. 従って, 隣接する <span class="math inline">1</span> のセルをグループ化し, <a href="/roki.log/2019/05/8/BooleanAlgebra/#boolean_algebra4">公理4: 補元律</a>を利用することで簡単化が実現できる.</p>
<p>以下, <span class="math inline">i</span> 行目 <span class="math inline">j</span> 列目のセルを <span class="math inline">i:j</span> と示すこととする. 例えば, <a href="/roki.log/2019/05/8/BooleanAlgebra/#karnaugh1">カルノー図 1</a> で <span class="math inline">1</span> となるセルは <span class="math inline">1:1,2:1,2:2</span> で, これらはそれぞれ <span class="math inline">x'_1\land x'_2,x_1\land x'_2,x_1\land x_2</span> である. ここで, 任意の隣接するセル <span class="math inline">c_i</span> をグループ化したことを <span class="math inline">{c_1,c_2,\cdots,c_n}</span> と書くとき, <span class="math inline">g_1={1:1,2:1}, g_2={2:1,2:2}</span> とグループ化できることがわかる. 従って, それぞれを論理式で基本積の形に表すと,</p>
<p><span class="math display">
\begin{aligned}
g_1&amp;=&amp;x'_1\land x'_2\lor x_1\land x'_2&amp;=&amp;(x'_1\lor x_1)\land x'_2&amp;=&amp;x'_2\\
g_2&amp;=&amp;x_1\land x'_2\lor x_1\land x_2&amp;=&amp;x_1\land(x'_2\lor x_2)&amp;=&amp;x_1
\end{aligned}
</span></p>
<p>よって, <span class="math inline">=x'_2\lor x_1</span> とわかる. 別のカルノー図についてもやってみよう.</p>
<table>
<caption>カルノー図 2</caption>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">x_1x_2\backslash x_3x_4</span></th>
<th style="text-align: center;"><span class="math inline">00</span></th>
<th style="text-align: center;"><span class="math inline">01</span></th>
<th style="text-align: center;"><span class="math inline">11</span></th>
<th style="text-align: center;"><span class="math inline">10</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">00</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">01</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">11</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">10</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
</tr>
</tbody>
</table>
<p>これは, 4 つの引数をもったブール関数のカルノー図である. カルノー図では, 最上, 最下また最左, 最右のセルは隣接していると考える. 従って, <a href="/roki.log/2019/05/8/BooleanAlgebra/#karnaugh2">カルノー図 2</a> におけるグループ化の一つの例として <span class="math inline">g_1={1:2,2:2},g_2={1:3,4:3},g_3={4:1,4:4}</span> と構成できる. よって,</p>
<p><span class="math display">\begin{aligned}
g_1&amp;=&amp;x'_1\land x'_2\land x'_3\land x_4\lor x'_1\land x_2\land x'_3\land x_4&amp;=&amp;x'_1\land x'_3\land x_4\\
g_2&amp;=&amp;x'_1\land x'_2\land x_3\land x_4\lor x_1\land x'_2\land x_3\land x_4&amp;=&amp;x'_2\land x_3\land x_4\\
g_3&amp;=&amp;x_1\land x'_2\land x'_3\land x'_4\lor x_1\land x'_2\land x_3\land x'_4&amp;=&amp;x_1\land x'_2\land x'_4
\end{aligned}</span></p>
<p>ゆえに<a href="/roki.log/2019/05/8/BooleanAlgebra/#karnaugh2">カルノー図 2</a> で示される論理関数の簡単な表現は</p>
<p><span class="math display">x'_1\land x'_3\land x_4\lor x'_2\land x_3\land x_4\lor x_1\land x'_2\land x'_4</span></p>
<p>となる. このグループ化という操作が一意ではないことからわかるように, 簡単化したブール式も一意でないことがわかる. 例えば, <span class="math inline">g_1={1:2,2:2},g_2={1:2,1:3},g_3={4:1,4:4},g_4={4:3,4:4}</span> とグループ化すると,</p>
<p><span class="math display">\begin{aligned}
g_1&amp;=&amp;x'_1\land x'_2\land x'_3\land x_4\lor x'_1\land x_2\land x'_3\land x_4&amp;=&amp;x'_1\land x'_3\land x_4\\
g_2&amp;=&amp;x'_1\land x'_2\land x'_3\land x_4\lor x'_1\land x'_2\land x_3\land x_4&amp;=&amp;x'_1\land x'_2\land x_4\\
g_3&amp;=&amp;x_1\land x'_2\land x'_3\land x'_4\lor x_1\land x'_2\land x_3\land x'_4&amp;=&amp;x_1\land x'_2\land x'_4\\
g_4&amp;=&amp;x_1\land x'_2\land x_3\land x_4\lor x_1\land x'_2\land x_3\land x'_4&amp;=&amp;x_1\land x'_2\land x_3
\end{aligned}</span></p>
<p>ゆえに,</p>
<p><span class="math display">x'_1\land x'_3\land x_4\lor x'_1\land x'_2\land x_4\lor x_1\land x'_2\land x'_4\lor x_1\land x'_2\land x_3</span></p>
<p>となる. 1 つの例を見ただけなので, 厳密に言えたことではないが, 一般的にグループの数が少なく, かつグループ内のセルの数を(<span class="math inline">2n</span> 個で)なるべく多く取る方がより簡単な論理式を構成できることがわかる.</p>
<p>さて, ある論理変数の組み合わせが予め起こりえないことがわかっていたとき, その場合もカルノー図を用いて簡単化を進めることができる. このような組み合わせに対する最小項を禁止項, または don’t care 項という. 例えば, <span class="math display">\begin{aligned}
f(x_1,x_2,x_3,x_4)&amp;=&amp;x'_1\land x'_2\land x'_3\land x_4 \\ 
&amp;&amp;\lor x'_1\land x_2\land x'_3\land x_4 \\ 
&amp;&amp;\lor x'_1\land x_2\land x_3\land x_4\\
&amp;&amp;\lor x'_1\land x_2\land x_3\land x'_4\\
&amp;&amp;\lor x_1\land x'_2\land x_3\land x_4\\
&amp;&amp;\lor x_1\land x'_2\land x_3\land x'_4\tag{\htmlId{formula4}{4}}
\end{aligned}</span></p>
<p>というブール関数を簡単化することを考える. このとき, <span class="math inline">x_1\land x_2</span>, また <span class="math inline">x_1\land x'_2\land x'_3\land x'_4</span> は禁止項とする. 禁止行の対応するセルには <span class="math inline">\phi</span> を記述する. すると, 式 <span class="math inline">(4)</span> のカルノー図は次のとおりとなる.</p>
<table>
<caption>カルノー図 3</caption>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">x_1x_2\backslash x_3x_4</span></th>
<th style="text-align: center;"><span class="math inline">00</span></th>
<th style="text-align: center;"><span class="math inline">01</span></th>
<th style="text-align: center;"><span class="math inline">11</span></th>
<th style="text-align: center;"><span class="math inline">10</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">00</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">01</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">11</span></td>
<td style="text-align: center;"><span class="math inline">\phi</span></td>
<td style="text-align: center;"><span class="math inline">\phi</span></td>
<td style="text-align: center;"><span class="math inline">\phi</span></td>
<td style="text-align: center;"><span class="math inline">\phi</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">10</span></td>
<td style="text-align: center;"><span class="math inline">\phi</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
</tr>
</tbody>
</table>
<p>禁止項は, <span class="math inline">1</span> でも <span class="math inline">0</span> でもよいということになるので, グループを構成するにあたって自分で都合よく <span class="math inline">1</span> か <span class="math inline">0</span> に解釈してしまって良い. できる限り多くのセルと少ないグループの数で構成するために, いま <span class="math inline">3:3,3:4</span> を <span class="math inline">1</span> と解釈すれば, <span class="math inline">g_1={1:2,2:2},g_2={2:3,2:4,3:3,3:4},g_3={3:3,3:4,4:3,4:4}</span> とグループ化できる. 従って,</p>
<p><span class="math display">
\begin{aligned}
g_1&amp;=&amp;x'_1\land x'_2\land x'_3\land x_4\lor x'_1\land x_2\land x'_3\land x_4&amp;=&amp;x'_1\land x'_3\land x_4\\
g_2&amp;=&amp;x'_1\land x_2\land x_3\land x_4\lor x'_1\land x_2\land x_3\land x'_4\lor x_1\land x_2 \land x_3\land x_4\lor x_1\land x_2\land x_3\land x'_4&amp;=&amp;x_2\land x_3\\
g_3&amp;=&amp;x_1\land x_2\land x_3\land x_4\lor x_1\land x_2\land x_3\land x'_4\lor x_1\land x'_2\land x_3\land x_4\lor x_1\land x'_2\land x_3\land x'_4&amp;=&amp;x_1\land x_3
\end{aligned}
</span></p>
<p>ゆえに, 式 <span class="math inline">\href{#formula4}{(4)}</span> は</p>
<p><span class="math display">f(x_1,x_2,x_3,x_4)=x'_1\land x'_3\land x_4\lor x_2\land x_3\lor x_1\land x_3</span></p>
<p>と簡単化できた. カルノー図は, 1 次元につき 2 つまでの引数を扱えると考えると, 人間の次元認識能力の見地から実質 6 つの引数にまで対応できることとなるわけだが, 実際は平面的に考えることが多いので, 大抵, 最大 4 個の引数までしか扱うことができない.</p>
<h3 id="クワインマクラスキー法">クワイン・マクラスキー法</h3>
<p>主にクワイン・マクラスキー法は <span class="math display">x\land y\lor x\land y'=x\land(y\lor y')=x\tag{\htmlId{formula5}{5}}</span> を繰り返し利用し, ブール関数を機械的に簡単化していく方法であり, その手順は次のとおりである.</p>
<ol type="1">
<li>ブール式を PDNF にする</li>
<li>式 <span class="math inline">\href{#formula5}{(5)}</span> を利用して圧縮し, 主項を求める
<ol type="1">
<li>ブール式を 2 進値に割り当てる<a href="/roki.log/2019/05/8/BooleanAlgebra/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></li>
<li>ハミング距離 1 のビット列同士を可能な限り繰り返し組み合わせる</li>
</ol></li>
<li>求めた主項からただ 1 つの最小項を包含する主項(必須項)を求める.</li>
<li>ブール関数を作成する
<ol type="1">
<li>必須項の和をとる</li>
<li>必須項により包含されていない最小項があるとき, 最も簡単な主項を選択し和を取る.</li>
</ol></li>
</ol>
<p>いま, 式 <span class="math inline">\href{#formula4}{(4)}</span> を簡単化することを考えるとしよう. このとき, まず式を PDNF にする. <span class="math inline">(4)</span> はすでに PDNF の形式となっているので, 今回は必要ない. 次に, <a href="/roki.log/2019/05/8/BooleanAlgebra/#karnaugh3">カルノー図 3</a> の各セル <span class="math inline">i:j</span> を <span class="math inline">m_0=1:1,m_1=2:1,m_2=3:1,m_3=4:1,m_4=1:2,\cdots,m_{15}=4:4</span> とおき, PDNF を構成する各最小項について次のようにビット列と対応させる.</p>
<p>ここで, 先と同様, <span class="math inline">x_1\land x_2</span> と <span class="math inline">x_1\land x'_2\land x'_3\land x'_4</span> を禁止項としたときは, それについてもビット列と対応させておく.</p>
<p>これは <span class="math inline">\displaystyle\bigvee {\rm m}(4,5,9,11,13,15)+{\rm dc}(2,3,6,10,14)=(4)</span> と書かれる. このとき, 例えば <span class="math inline">m_4\lor m_5</span> は式 <span class="math inline">(5)</span> を利用して簡単化できることがわかる. 事実, <span class="math display">x'_1\land x'_2\land x'_3\land x_4\lor x'_1\land x_2\land x'_3\land x_4=x'_1\land x'_3\land x_4\land(x'_2\lor x_2)=x'_1\land x'_3\land x_4</span> である. このような簡単化をすべての可能な組み合わせについて繰り返し実行する. この作業を圧縮ということとする. 先にブール式をビット列と対応させたので, 圧縮とはハミング距離 1 のビット列同士を繰り返し組み合わせることと同値である. 次の表に, 圧縮を 1 度行った結果を示す. 組み合わせられたビット部分は <span class="math inline">-</span>, それ以上圧縮できないものを主項といい, <span class="math inline">\ast</span> で示すものとする<a href="/roki.log/2019/05/8/BooleanAlgebra/#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. これを圧縮表ということとする.</p>
<div class="content">
<table class="table">
<thead>
<th>
1 の数
</th>
<th>
最小項
</th>
<th>
ビット列表現
</th>
</thead>
<caption id="compress_table1" style="caption-side: bottom">
圧縮表 (1 回目)
</caption>
<tbody>
<tr>
<td rowspan="3">
<span class="math inline">1</span>
</td>
<td>
<span class="math inline">m_{4,5}</span>
</td>
<td>
<span class="math inline">0-01\ast</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{3,15}</span>
</td>
<td>
<span class="math inline">10-0</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{2,3}</span>
</td>
<td>
<span class="math inline">1-00</span>
</td>
</tr>
<tr>
<td rowspan="8">
<span class="math inline">2</span>
</td>
<td>
<span class="math inline">m_{5,9}</span>
</td>
<td>
<span class="math inline">01-1</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{5,6}</span>
</td>
<td>
<span class="math inline">-101</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{9,13}</span>
</td>
<td>
<span class="math inline">011-</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{13,14}</span>
</td>
<td>
<span class="math inline">-110</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{14,15}</span>
</td>
<td>
<span class="math inline">1-10</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{11,15}</span>
</td>
<td>
<span class="math inline">101-</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{2,6}</span>
</td>
<td>
<span class="math inline">110-</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{2,14}</span>
</td>
<td>
<span class="math inline">11-0</span>
</td>
</tr>
<tr>
<td rowspan="5">
<span class="math inline">3</span>
</td>
<td>
<span class="math inline">m_{9,10}</span>
</td>
<td>
<span class="math inline">-111</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{10,11}</span>
</td>
<td>
<span class="math inline">1-11</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{6,10}</span>
</td>
<td>
<span class="math inline">11-1</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{10,14}</span>
</td>
<td>
<span class="math inline">111-</span>
</td>
</tr>
</tbody>
</table>
</div>
<p>残りのすべての最小項について <span class="math inline">\ast</span> がつくまで繰り返す.</p>
<div class="table-responsive">
<table class="table table-hover">
<thead>
<th>
1 の数
</th>
<th>
最小項
</th>
<th>
ビット列表現
</th>
</thead>
<caption id="compress_table2" style="caption-side: bottom">
圧縮表 (2 回目)
</caption>
<tbody>
<tr>
<td>
<span class="math inline">1</span>
</td>
<td>
<span class="math inline">m_{2,3,14,15}</span>
</td>
<td>
<span class="math inline">1--0\ast</span>
</td>
</tr>
<tr>
<td rowspan="4">
<span class="math inline">2</span>
</td>
<td>
<span class="math inline">m_{5,6,9,10}</span>
</td>
<td>
<span class="math inline">-1-1\ast</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{9,10,13,14}</span>
</td>
<td>
<span class="math inline">-11-\ast</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{10,11,14,15}</span>
</td>
<td>
<span class="math inline">1-1-\ast</span>
</td>
</tr>
<tr>
<td>
<span class="math inline">m_{2,6,10,14}</span>
</td>
<td>
<span class="math inline">11--\ast</span>
</td>
</tr>
</tbody>
</table>
</div>
<p>従って, 主項は <span class="math inline">m_{4,5},m_{2,3,14,15},m_{5,6,9,10},m_{9,10,13,14},m_{10,11,14,15},m_{2,6,10,14}</span> であるから, <a href="/roki.log/2019/05/8/BooleanAlgebra/#compress_table1">圧縮表 1</a> および <a href="/roki.log/2019/05/8/BooleanAlgebra/#compress_table2">2</a> より, 式 \(\) は次のように表現できることがわかる.</p>
<p><span class="math display">\underbrace{x'_1\land x'_3\land x_4}_{m_{4,5}}\lor
\underbrace{x_1\land x'_4}_{m_{2,3,14,15}}\lor\underbrace{x_2\land x_4}_{m_{5,6,9,10}}\lor\underbrace{x_2\land x_3}_{m_{9,10,13,14}}\lor\underbrace{x_1\land x_3}_{m_{10,11,14,15}}\lor
\underbrace{x_1\land x_2}_{m_{2,6,10,14}}</span></p>
<p>しかしこれはまだ冗長である. この主項から必須項を調べる. 縦軸に主項, 横軸に最小項を並べ, 最小項を包含する主項のセルに印 <span class="math inline">\bigcirc</span> を, 包含する最小項が 1 つしかない主項のセルに印 <span class="math inline">\circledcirc</span> をつける. これを主項表という.</p>
<div class="table-responsive">
<table>
<caption>主項表 1</caption>
<thead>
<tr class="header">
<th style="text-align: center;">主項 <span class="math inline">\backslash</span> 最小項</th>
<th style="text-align: center;"><span class="math inline">m_4</span></th>
<th style="text-align: center;"><span class="math inline">m_5</span></th>
<th style="text-align: center;"><span class="math inline">m_9</span></th>
<th style="text-align: center;"><span class="math inline">m_{13}</span></th>
<th style="text-align: center;"><span class="math inline">m_{11}</span></th>
<th style="text-align: center;"><span class="math inline">m_{15}</span></th>
<th style="text-align: center;">ビット表現</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">m_{4,5}</span></td>
<td style="text-align: center;"><span class="math inline">\color{blue}{\circledcirc}</span></td>
<td style="text-align: center;"><span class="math inline">\color{blue}{\bigcirc}</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">0-01</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">m_{5,6,9,10}</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\bigcirc</span></td>
<td style="text-align: center;"><span class="math inline">\bigcirc</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">-1-1</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">m_{9,10,13,14}</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\color{blue}{\bigcirc}</span></td>
<td style="text-align: center;"><span class="math inline">\color{blue}{\circledcirc}</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">-11-</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">m_{10,11,14,15}</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\color{blue}{\circledcirc}</span></td>
<td style="text-align: center;"><span class="math inline">\color{blue}{\bigcirc}</span></td>
<td style="text-align: center;"><span class="math inline">1-1-</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">m_{2,3,14,15}</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\bigcirc</span></td>
<td style="text-align: center;"><span class="math inline">1--0</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">m_{2,6,10,14}</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">11--</span></td>
</tr>
</tbody>
</table>
</div>
<p>従って, 必須項は <span class="math inline">\circledcirc</span> のつく <span class="math inline">m_{4,5},m_{9,10,13,14},m_{10,11,14,15}</span> である. あとはそれらを書き出し, 残りの主項で最小項を全て含む最も簡単な組み合わせを探すこととなる(ここで現れる必須項が全ての最小項を包含するとは限らない). ここで, もし <span class="math inline">\circledcirc</span> が 1 つも含まれない最小項があれば, すなわち必須項にすべての最小項が含まれていなければ, 最も簡単となりかつ, 全ての最小項を含むブール式となるよう適当な主項を選択する. 今回の場合では, 必須項のみで全ての最小項を包含することができている(印を青の表示としておいた)から <span class="math inline">m_{4,5},m_{9,10,13,14},m_{10,11,14,15}</span> の和, すなわち <span class="math display">x'_1\land x'_3\land x_4\lor x_2\land x_3\lor x_1\land x_3</span> が式 <span class="math inline">(4)</span> の最簡形である. 先に示したカルノー図による簡単化で得られたブール式と同等の結果が得られたことがわかる. なお, クワイン・マクラスキー法は NP 完全である<a href="/roki.log/2019/05/8/BooleanAlgebra/#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>ため, 使用範囲が限られる.</p>
<h3 id="ペトリック法">ペトリック法</h3>
<p>先のクワイン・マクラスキー法の最後では, 「最も簡単となりかつ, 全ての最小項を含むブール式となるよう適当な主項を選択」することによって最簡形を得るとのことであったが, この部分をペトリック法で置き換えることにより, 機械的に最簡形のブール式を決定することができる. ここでも, <span class="math inline">(4)</span> を例に方法を示すこととする. クワイン・マクラスキー法の手順のうち 3 まで実行したものとし, <a href="/roki.log/2019/05/8/BooleanAlgebra/#prime_implicant_table1">主項表 1</a> が得られたとしよう. まず<a href="/roki.log/2019/05/8/BooleanAlgebra/#prime_implicant_table1">主項表 1</a> の列を見て, 印のある主項らで和を取り, それらの積をとった次の式を得る.</p>
<p><span class="math display">m_{4,5}\land (m_{4,5}\lor m_{5,6,9,10})\land(m_{5,6,9,10}\lor m_{9,10,13,14})\land m_{9,10,13,14}\land m_{10,11,14,15}\land(m_{10,11,14,15}\lor m_{2,3,14,15})\tag{6}</span></p>
<p>式 <span class="math inline">(6)</span> を<a href="/roki.log/2019/05/8/BooleanAlgebra/#boolean_algebra2">公理2</a>: 分配律および<a href="/roki.log/2019/05/8/BooleanAlgebra/#absorption">吸収律</a>を用いて変形していくと,</p>
<p><span class="math display">
\begin{aligned}
(6)&amp;=&amp;(m_{4,5}\lor m_{4,5}\land m_{5,6,9,10})\land(m_{5,6,9,10}\land m_{9,10,13,14}\lor m_{9,10,13,14})\land(m_{10,11,14,15}\lor m_{10,11,14,15}\land m_{2,3,14,15})\\
&amp;=&amp;m_{4,5}\land m_{9,10,13,14}\land m_{10,11,14,15}
\end{aligned}
</span></p>
<p>この主項の積となっている部分を主項の和とすることで, ブール関数の最簡形が求まる. 従って, 先と同様の結果が機械的に得られたことがわかる.</p>
<h4 id="クワインマクラスキー法-ペトリック法の実装">クワイン・マクラスキー法, ペトリック法の実装</h4>
<p>これらは一度プログラムで実装することが割と学習の定番となっているので, Haskell で実装した. 次のリポジトリにて管理している.</p>
<div class="has-text-centered mb-3 mt-3">
<p><i class="fab fa-github fa-fw"></i> <a href="https://github.com/falgon/bsimplified">falgon/bsimplified - The simple and pure implementation of Quine-McCluskey method, Petrick’s method and parsing of Boolean formula</a></p>
</div>
<p>まず, いま解いた簡単化を再度実行してみる. よくある実装法だと思うが, クワイン・マクラスキー法の圧縮過程は二分木のデータ構造として表現する. 従って, まずはじめに各最小項に対応するノードを作成することで PDNF を表現することとした.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb1-1" aria-hidden="true"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>m <span class="op">+</span><span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span></span>
<span id="cb1-2"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb1-2" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span><span class="op">&gt;</span> <span class="kw">let</span> tr <span class="ot">=</span> fromJust <span class="op">$</span> pdnfForest (fromJust <span class="op">$</span> strBitsList [<span class="st">&quot;0001&quot;</span>,<span class="st">&quot;0101&quot;</span>,<span class="st">&quot;0111&quot;</span>,<span class="st">&quot;1011&quot;</span>,<span class="st">&quot;0110&quot;</span>,<span class="st">&quot;1010&quot;</span>,<span class="st">&quot;1100&quot;</span>,<span class="st">&quot;1000&quot;</span>,<span class="st">&quot;1101&quot;</span>,<span class="st">&quot;1111&quot;</span>,<span class="st">&quot;1110&quot;</span>]) (<span class="fu">replicate</span> <span class="dv">6</span> <span class="dt">False</span> <span class="op">++</span> <span class="fu">replicate</span> <span class="dv">5</span> <span class="dt">True</span>)</span>
<span id="cb1-3"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb1-3" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span><span class="op">&gt;</span> tr</span>
<span id="cb1-4"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb1-4" aria-hidden="true"></a>[<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">18370878410602274422</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">101</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">17795521015237778886</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">9505003458451781531</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1011</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">5344459161969259783</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">2509103263232437805</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1010</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">9465362842462816922</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1100</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">5080631804786515567</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1000</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8905849755465195471</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1101</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">7582384624143865392</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">4819471800686604738</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8582731269452337816</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}]</span></code></pre></div>
<p><code>pdnfForest</code> には <code>QMyBits</code> のインスタンス (<code>DigitListBits</code>, <code>StrBits</code>, <code>RawBits</code>) のリストと Don’t care か否かを制御するフラグのリストを渡す. このとき, 2 つのリストの要素数は同一でなければならない (もしそうでなければ <code>Nothing</code> が返る). ここで, <code>DigitListBits</code>, <code>StrBits</code>, <code>RawBits</code> はそれぞれビット列の表現を包括的に捉えるための型である.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb2-1" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span><span class="op">&gt;</span> <span class="op">:</span>m <span class="op">+</span><span class="dt">BSimplified.Bits</span></span>
<span id="cb2-2"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb2-2" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span> <span class="dt">BSimplified.Bits</span><span class="op">&gt;</span> toRawBits (<span class="dt">StrBits</span> <span class="st">&quot;1010&quot;</span>) <span class="op">==</span> toRawBits (<span class="dt">RawBits</span> <span class="dv">10</span>)</span>
<span id="cb2-3"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb2-3" aria-hidden="true"></a><span class="dt">True</span></span>
<span id="cb2-4"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb2-4" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span> <span class="dt">BSimplified.Bits</span><span class="op">&gt;</span> toRawBits (<span class="dt">StrBits</span> <span class="st">&quot;1010&quot;</span>) <span class="op">==</span> toRawBits (<span class="dt">DigitListBits</span> [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>])</span>
<span id="cb2-5"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb2-5" aria-hidden="true"></a><span class="dt">True</span></span></code></pre></div>
<p>クワイン・マクラスキー法によって圧縮を実行する.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb3-1" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span> <span class="dt">BSimplified.Bits</span><span class="op">&gt;</span> quineMcCluskey tr</span>
<span id="cb3-2"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb3-2" aria-hidden="true"></a><span class="dt">PrimeImplicants</span> [<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">2</span>, identifier <span class="ot">=</span> <span class="dv">577617992350188464</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">18370878410602274422</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">101</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">17795521015237778886</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">11</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">2</span>, identifier <span class="ot">=</span> <span class="dv">6829379978376433071</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">11</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8439440437090953821</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">101</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">17795521015237778886</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">9505003458451781531</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">3159344086055741426</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1101</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">7582384624143865392</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">4819471800686604738</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">11</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">2</span>, identifier <span class="ot">=</span> <span class="dv">10719524625750522604</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">11</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">11617789877111658934</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">9505003458451781531</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">2509103263232437805</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">3889360259696288602</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">4819471800686604738</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8582731269452337816</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">11</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">18197116026168548551</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">101</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">14515361159708671901</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1011</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">5344459161969259783</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1010</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">9465362842462816922</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">3889360259696288602</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">4819471800686604738</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8582731269452337816</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">10</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">14507692373987760546</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">100</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">17927799263722280277</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1010</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">9465362842462816922</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1000</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8905849755465195471</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">3574163930668469495</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1100</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">5080631804786515567</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8582731269452337816</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">11</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">1892010599057419013</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">3438512683213686879</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1100</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">5080631804786515567</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1101</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">7582384624143865392</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">3889360259696288602</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">4819471800686604738</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8582731269452337816</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}}]</span></code></pre></div>
<p>実際の計算ではこれで十分なのだが, 一応人間にとってより分かりやすい <code>traceQuineMcCluskey</code> を用意してある. 引数には, <code>pdnfForest</code> で作成したノードのリストと, それに対応する変数名のリストを渡す. 両者の要素数は同一でなければならない (もしそうでない場合 <code>Nothing</code> が返る). ここでは, 先に扱った例題に対応した変数名を渡しているので, 得られた主項が先と同一であることが確認できる.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb4-1" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span> <span class="dt">BSimplified.Bits</span><span class="op">&gt;</span> <span class="op">:</span>m <span class="op">+</span><span class="dt">Control.Monad</span></span>
<span id="cb4-2"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb4-2" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span> <span class="dt">BSimplified.Bits</span> <span class="dt">Control.Monad</span><span class="op">&gt;</span> void <span class="op">$</span> traceQuineMcCluskey tr [<span class="st">&quot;m_4&quot;</span>,<span class="st">&quot;m_5&quot;</span>,<span class="st">&quot;m_9&quot;</span>,<span class="st">&quot;m_11&quot;</span>,<span class="st">&quot;m_13&quot;</span>,<span class="st">&quot;m_15&quot;</span>,<span class="st">&quot;m_2&quot;</span>,<span class="st">&quot;m_3&quot;</span>,<span class="st">&quot;m_6&quot;</span>,<span class="st">&quot;m_10&quot;</span>,<span class="st">&quot;m_14&quot;</span>]</span>
<span id="cb4-3"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb4-3" aria-hidden="true"></a><span class="dt">The</span> state <span class="kw">of</span> compression <span class="op">#</span><span class="dv">1</span><span class="op">:</span> [<span class="st">&quot;m_4 m_5&quot;</span>,<span class="st">&quot;m_5 m_9&quot;</span>,<span class="st">&quot;m_5 m_6&quot;</span>,<span class="st">&quot;m_9 m_13&quot;</span>,<span class="st">&quot;m_9 m_10&quot;</span>,<span class="st">&quot;m_11 m_15&quot;</span>,<span class="st">&quot;m_11 m_10&quot;</span>,<span class="st">&quot;m_13 m_14&quot;</span>,<span class="st">&quot;m_15 m_3&quot;</span>,<span class="st">&quot;m_15 m_14&quot;</span>,<span class="st">&quot;m_2 m_3&quot;</span>,<span class="st">&quot;m_2 m_6&quot;</span>,<span class="st">&quot;m_2 m_14&quot;</span>,<span class="st">&quot;m_6 m_10&quot;</span>,<span class="st">&quot;m_10 m_14&quot;</span>]</span>
<span id="cb4-4"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb4-4" aria-hidden="true"></a><span class="dt">Found</span> prime implicants<span class="op">:</span> [<span class="st">&quot;m_4 m_5&quot;</span>]</span>
<span id="cb4-5"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb4-5" aria-hidden="true"></a><span class="dt">The</span> state <span class="kw">of</span> compression <span class="op">#</span><span class="dv">2</span><span class="op">:</span> [<span class="st">&quot;m_5 m_9 m_6 m_10&quot;</span>,<span class="st">&quot;m_9 m_13 m_10 m_14&quot;</span>,<span class="st">&quot;m_11 m_15 m_10 m_14&quot;</span>,<span class="st">&quot;m_15 m_3 m_2 m_14&quot;</span>,<span class="st">&quot;m_2 m_6 m_10 m_14&quot;</span>]</span>
<span id="cb4-6"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb4-6" aria-hidden="true"></a><span class="dt">Found</span> prime implicants<span class="op">:</span> [<span class="st">&quot;m_5 m_9 m_6 m_10&quot;</span>,<span class="st">&quot;m_9 m_13 m_10 m_14&quot;</span>,<span class="st">&quot;m_11 m_15 m_10 m_14&quot;</span>,<span class="st">&quot;m_15 m_3 m_2 m_14&quot;</span>,<span class="st">&quot;m_2 m_6 m_10 m_14&quot;</span>]</span></code></pre></div>
<p>簡単化された最低限の項を得るには <code>minTerms</code> 等を用いる. これも, 変数名と対応した結果を得ることのできる <code>minTermsStr</code> を用意してある.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb5-1" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span> <span class="dt">BSimplified.Bits</span> <span class="dt">Control.Monad</span><span class="op">&gt;</span> minTerms tr</span>
<span id="cb5-2"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb5-2" aria-hidden="true"></a>[<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">2</span>, identifier <span class="ot">=</span> <span class="dv">577617992350188464</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">18370878410602274422</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">101</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">17795521015237778886</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">11</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">2</span>, identifier <span class="ot">=</span> <span class="dv">10719524625750522604</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">11</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">11617789877111658934</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">9505003458451781531</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">2509103263232437805</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">3889360259696288602</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">4819471800686604738</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8582731269452337816</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}},<span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">11</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">18197116026168548551</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">101</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">14515361159708671901</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1011</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">5344459161969259783</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1010</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">9465362842462816922</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">False</span> }, mergedFlag <span class="ot">=</span> <span class="dv">0</span>, identifier <span class="ot">=</span> <span class="dv">3889360259696288602</span>, prevLeft <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1111</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">4819471800686604738</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}, prevRight <span class="ot">=</span> <span class="dt">CTNode</span> {row <span class="ot">=</span> <span class="dt">TruthTableRow</span> { var <span class="ot">=</span> <span class="dv">1110</span> (binary), dontcare <span class="ot">=</span> <span class="dt">True</span> }, mergedFlag <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span>, identifier <span class="ot">=</span> <span class="dv">8582731269452337816</span>, prevLeft <span class="ot">=</span> <span class="dt">CTEmpty</span>, prevRight <span class="ot">=</span> <span class="dt">CTEmpty</span>}}}]</span>
<span id="cb5-3"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb5-3" aria-hidden="true"></a><span class="dt">Prelude</span> <span class="dt">BSimplified.QMM</span> <span class="dt">Data.Maybe</span> <span class="dt">BSimplified.Bits</span> <span class="dt">Control.Monad</span><span class="op">&gt;</span> minTermsStr tr [<span class="st">&quot;m_4&quot;</span>,<span class="st">&quot;m_5&quot;</span>,<span class="st">&quot;m_9&quot;</span>,<span class="st">&quot;m_11&quot;</span>,<span class="st">&quot;m_13&quot;</span>,<span class="st">&quot;m_15&quot;</span>,<span class="st">&quot;m_2&quot;</span>,<span class="st">&quot;m_3&quot;</span>,<span class="st">&quot;m</span></span>
<span id="cb5-4"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb5-4" aria-hidden="true"></a><span class="st">_6&quot;</span>,<span class="st">&quot;m_10&quot;</span>,<span class="st">&quot;m_14&quot;</span>]</span>
<span id="cb5-5"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb5-5" aria-hidden="true"></a><span class="dt">Just</span> [[<span class="st">&quot;m_4&quot;</span>,<span class="st">&quot;m_5&quot;</span>],[<span class="st">&quot;m_9&quot;</span>,<span class="st">&quot;m_13&quot;</span>,<span class="st">&quot;m_10&quot;</span>,<span class="st">&quot;m_14&quot;</span>],[<span class="st">&quot;m_11&quot;</span>,<span class="st">&quot;m_15&quot;</span>,<span class="st">&quot;m_10&quot;</span>,<span class="st">&quot;m_14&quot;</span>]]</span></code></pre></div>
<p>また, ブール式を入力して, 最も簡単な式となる項を見つけられるようにもしてある. ブール式の表記としては, 後述の記号 (否定: <code>~</code>, 積: <code>*</code>, 和: <code>+</code>, 括弧: <code>(</code>,<code>)</code>) を用いることができる. アルファベット 1 文字は変数名として捉える. ここでは, 例として式 <span class="math inline">(3)</span> を入力として与える.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb6-1" aria-hidden="true"></a>$ <span class="ex">stack</span> build</span>
<span id="cb6-2"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb6-2" aria-hidden="true"></a>$ <span class="ex">stack</span> exec bsimplified -- <span class="st">&quot;A*~B+~A*~B+A*~B+A*B&quot;</span></span>
<span id="cb6-3"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb6-3" aria-hidden="true"></a><span class="ex">Minterms</span> (Truth patterns)<span class="bu">:</span></span>
<span id="cb6-4"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb6-4" aria-hidden="true"></a>        <span class="ex">m_0</span> = { A = True, B = True }</span>
<span id="cb6-5"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb6-5" aria-hidden="true"></a>        <span class="ex">m_1</span> = { A = True, B = False }</span>
<span id="cb6-6"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb6-6" aria-hidden="true"></a>        <span class="ex">m_3</span> = { A = False, B = False }</span>
<span id="cb6-7"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb6-7" aria-hidden="true"></a><span class="ex">The</span> state of compression #1: [<span class="st">&quot;m_0 m_1&quot;</span>,<span class="st">&quot;m_1 m_3&quot;</span>]</span>
<span id="cb6-8"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb6-8" aria-hidden="true"></a><span class="ex">Found</span> prime implicants: [<span class="st">&quot;m_0 m_1&quot;</span>,<span class="st">&quot;m_1 m_3&quot;</span>]</span>
<span id="cb6-9"><a href="/roki.log/2019/05/8/BooleanAlgebra/#cb6-9" aria-hidden="true"></a><span class="ex">Simplified</span> terms: (m_0 m_1), <span class="kw">(</span><span class="ex">m_1</span> m_3<span class="kw">)</span></span></code></pre></div>
<p><span class="math inline">m_{0,1},m_{1,3}</span> が結果として得られた. それぞれ, ビット列上の圧縮された部分を <span class="math inline">-</span> で表記すると, <span class="math inline">m_{0,1}=1-, m_{1,3}=-0</span> である. これはつまり <span class="math inline">A B'</span> なので, 従って最簡形は <span class="math inline">A\lor B'</span> である. 当然ながら, 先に求めた解と同じ結果が得られたことが確認できる. 実装については普通に字句解析, 再起下降で計算, 真理値表を構成して PDNF をつくっている. ところで, この最簡形を得るという問題は充足可能性問題であり NP 困難<a href="/roki.log/2019/05/8/BooleanAlgebra/#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>なので, 変数の多いブール関数に対する最簡形を得ることは難しい. その場合, 現実的な時間で比較的良質な解が得られるヒューリスティックを含む方法で求めることとなる.</p>
<h2 id="ブール代数の例">ブール代数の例</h2>
<p>ここではブール代数の一例として, 計算機科学で一般的に用いられるブール代数を挙げる. 集合 <span class="math inline">L={0,1}</span> に対して <span class="math inline">\land</span> を積 <span class="math inline">\cdot:L\times L\to L</span>, <span class="math inline">\lor</span> を和 <span class="math inline">+:L\times L\to L</span>, 補元 <span class="math inline">x'</span> を否定 <span class="math inline">\overline{x}</span> とおく. 各演算子は, 次の<a href="/roki.log/2019/05/8/BooleanAlgebra/#truthtable1">真理値表 1</a> に従う (<span class="math inline">\overline{y}</span> は <span class="math inline">\overline{x}</span> と同様なので省略).</p>
<table>
<caption><span class="math inline">\htmlId{truthtable1}{\rm 真理値表 1}</span></caption>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">x</span></th>
<th style="text-align: center;"><span class="math inline">y</span></th>
<th style="text-align: center;"><span class="math inline">\overline{x}</span></th>
<th style="text-align: center;"><span class="math inline">x\cdot y</span></th>
<th style="text-align: center;"><span class="math inline">x+y</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
</tr>
</tbody>
</table>
<p>これは紛れもなくブール代数である. この形式の下で書かれる式は一般に論理式, 演算子は論理記号といわれる. 計算機科学の分野において, ブール代数は排他的論理和: <span class="math inline">\oplus</span>, 否定論理積: <span class="math inline">\mid</span>, 否定論理和: <span class="math inline">\downarrow</span> といった記号らをも含めて論理記号として扱うことが多い. これらの真理値表は <span class="math inline">x,y\in L</span> に対して次の通りである.</p>
<table>
<caption><span class="math inline">\htmlId{truthtable2}{\rm 真理値表 2}</span></caption>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">x</span></th>
<th style="text-align: center;"><span class="math inline">y</span></th>
<th style="text-align: center;"><span class="math inline">x\mid y</span></th>
<th style="text-align: center;"><span class="math inline">x\downarrow y</span></th>
<th style="text-align: center;"><span class="math inline">x\oplus y</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">1</span></td>
<td style="text-align: center;"><span class="math inline">0</span></td>
</tr>
</tbody>
</table>
<p>とくに, 否定論理積 <span class="math inline">\mid</span> はそれ一つで積, 和, 否定が定義できるため, 他の論理記号よりも特別視されるような場合のある結合子である. これは, シェファーの棒記号といわれ, 真理値表をみるとわかるように <span class="math inline">\overline{(x\land y)}</span>, また <span class="math inline">\overline{x}\lor \overline{y}</span> と同値である. この否定論理積を使って, <span class="math inline">\overline{x}:=x\mid x</span> と否定が定義できる. この否定を使って, <span class="math inline">x\land y:=\overline{(x\mid y)}</span> と積が定義できるし, <span class="math inline">x\lor y:=\overline{x}\mid \overline{y}</span> と和も定義できる. どちらかをも定義せずとも, 否定に加えて積があれば和が定義できるし, 和があれば積が定義できる.</p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li>“<a id="ref1" href="https://math.stackexchange.com/questions/1210458/what-is-the-difference-between-boolean-logic-and-propositional-logic">What is the difference between Boolean logic and propositional logic?</a>” 2019 年 4 月 13 日アクセス.</li>
<li>“<a id="ref2" href="https://www.quora.com/What-is-the-difference-between-Boolean-Algebra-and-propositional-logic-If-either-they-are-same-or-one-is-a-subset-of-another-why-should-we-study-those-separately">What is the difference between Boolean Algebra and propositional logic? If either they are same or one is a subset of another why should we study those separately?</a>” 2019 年 4 月 13 日アクセス.</li>
<li>J. Donald Monk (1976) “Mathematical Logic (Graduate Texts in Mathematics)” Springer; Softcover reprint of the original 1st ed. 1976版 (1976/9/7). ISBN-13: 978-1468494549</li>
<li>赤間世紀, 長田康敬, 玉城史朗 (2006)『<a id="ref4" class="disabled">情報数学入門</a>』共立出版. ISBN-13: 978-4320018143</li>
<li>W. V. Quine (1952) “The Problem of Simplifying Truth Functions” The American Mathematical Monthly Vol. 59, No. 8 (Oct., 1952), pp. 521-531</li>
<li>W. V. Quine (1955) “A Way to Simplify Truth Functions” The American Mathematical Monthly Vol. 62, No. 9 (Nov., 1955), pp. 627-631</li>
<li>[動画] Phalanetra. H.S “<a href="https://www.youtube.com/watch?v=97KpndF8-So">Quine McCluskey minimisation and Petrick’s method for obtaining simplified Boolean expressions</a>”, 2019 年 4 月 30 日アクセス.</li>
<li><a href="http://www.mrc.uidaho.edu/mrc/people/jff/349/lect.10">Lecture #10: Petrick’s Method</a></li>
<li>Czort, S. (1999) “<a id="ref9" class="disabled">The complexity of minimizing disjunctive normal form formulas (Master’s thesis)</a>”. University of Aarhus.</li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>イギリスの数学者ジョージ・ブール (英: George Boole) は 19 世紀半ばに人間の思考を代数計算で行うための研究を行い, ブール代数を形式化した. 命題論理はそれよりも昔にフレーゲにより構築された論理体型であるが, これは哲学的投機から派生したものである. 19 世紀後半になると, 哲学者たちは殆どブールの象徴主義を採用し, その後の 20 世紀ではこれらの学問間における明確な区別はなかったとのこと(<a href="/roki.log/2019/05/8/BooleanAlgebra/#ref2">参考文献2</a> より引用: <i>The main difference is historical. George Boole was a mathematician interested in efficient practical solutions of complicated logical questions in the middle 19th century. His main innovation was symbolic logic, a system of notation for clear specification of propositions and relations among propositions. [..] Propositional logic goes back to ancient times and derives from philosophical speculation. In the late 19th century philosophers mostly adopted Boole’s symbolism. Therefore in the 20th century there’s no clear distinction between the two fields, </i>). しかしながら, ブール代数に還元できないいくつかの命題論理が残っているとのこと(<a href="/roki.log/2019/05/8/BooleanAlgebra/#ref2">参考文献2</a> より引用: <i>although there remains some propositional logic that cannot be reduced to Boolean symbols. </i>). これが事実ならば, ブール代数は命題論理のサブセット的な論理であることがいえるが, <a href="/roki.log/2019/05/8/BooleanAlgebra/#ref3">参考文献3</a> p.158 では, “<i>the correspondence between Boolean algebras and sentential logics […] We shall see that there is a full correspondence between these two kinds of mathematical objects.</i> とあり, さらに同著書 p.160 で”<i>the following theorem, which is another kind of completeness theorem for Boolean algebras. […] Hence we may say that the theories of Boolean algebras and of sentential logics are equivalent, in some sense.</i>" とも言われていることから, 大まかに言い切ってしまえば, 殆ど差はないということであろう.<a href="/roki.log/2019/05/8/BooleanAlgebra/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>ブール式は 1 つのブール関数を定めるが, ブール関数はブール式を一意には定めない.<a href="/roki.log/2019/05/8/BooleanAlgebra/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>このあたりは自明とする.<a href="/roki.log/2019/05/8/BooleanAlgebra/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>すなわち, ブール関数の値を記述する. <span class="math inline">0</span> は記述せずに省略される場合もある.<a href="/roki.log/2019/05/8/BooleanAlgebra/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>2 進値を用いず, 変数を用いて圧縮表を作成する方法はクワイン法といわれる. ウィラード・ヴァン・オーマン・クワイン (英: Willard van Orman Quine) によって提案されたクワイン法がエドワード・J・マクラスキーによって発展されたため, このように言われている.<a href="/roki.log/2019/05/8/BooleanAlgebra/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>この表記の仕方は <a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AF%E3%82%A4%E3%83%B3%E3%83%BB%E3%83%9E%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%AD%E3%83%BC%E6%B3%95">Wikipedia の記事</a>を参考とした.<a href="/roki.log/2019/05/8/BooleanAlgebra/#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><a href="/roki.log/2019/05/8/BooleanAlgebra/#ref9">参考文献 9</a> より<a href="/roki.log/2019/05/8/BooleanAlgebra/#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>これについては, 命題論理のエントリ(TODO)内のトートロジー判定器のセクションにおいて取り上げている.<a href="/roki.log/2019/05/8/BooleanAlgebra/#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>関係 (集合論)</title>
    <link href="https://roki.dev/roki.log/2019/03/15/Relation/index.html" />
    <id>https://roki.dev/roki.log/2019/03/15/Relation/index.html</id>
    <published>2019-03-15T00:00:00Z</published>
    <updated>2019-03-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>関係 (集合論) について復習.</p>
<h2 id="一般的な関係">一般的な関係</h2>
<p>いま, 二つの要素の順序体を <span class="math inline">\left\lt a, b\right\gt</span> と書くこととする. 他の異なる順序体 <span class="math inline">\left\lt c, b\right\gt</span> に対し, 以下の通り定義する.</p>
<p><span class="math display">
\begin{aligned}
\left\lt a,b\right\gt=\left\lt c,d\right\gt&amp;:=&amp;a=c, b=d\\
{\rm デカルト積} = {\rm 直積} = A\times B&amp;:=&amp;\left\{\left\lt a,b\right\gt\mid a\in A, b\in B\right\}
\end{aligned}
</span></p>
<p>このとき順序体の要素を <span class="math inline">n</span> 個に拡張したものを <span class="math inline">n</span>-tuple といい, 以下の通り定義する.</p>
<!--more-->
<div class="m-def">
<header class="m-def-title">
<p>
<span id="n-tuple"><span class="math inline">n</span>-tuple の同値関係と直積</span>
</p>
</header>
<div class="m-def-content">
<span class="math display">
\left\lt a_1,a_2,\cdots,a_n\right\gt=\left\lt b_1,b_2,\cdots,b_n\right\gt:=(a_1=b_1,a_2=b_2,\cdots,a_n=b_n) \tag{1} </span> <span class="math display">
{\rm デカルト積} =  {\rm直積} = A_1\times A_2\times\cdots\times A_n=\prod_{i=1}^{n}A_i:=\left\{\left\lt a_1,a_2,\cdots,a_n\right\gt\mid a_1\in A_1,a_2\in A_2,\cdots,a_n\in A_n\right\} \tag{2}
</span>
</div>
</div>
<p>なお <span class="math inline">(2)</span> より <span class="math inline">A^n:=(A_1=A_2=\cdots =A_n)</span> が自明に導ける. いま集合 <span class="math inline">A</span> から <span class="math inline">B</span> に対する二項関係 <span class="math inline">R\subseteq A\times B</span> があって, <span class="math inline">\left\lt a,b\right\gt\in R</span> ならば <span class="math inline">a</span> と <span class="math inline">b</span> は関係 <span class="math inline">R</span> にあるといい, <span class="math inline">R(a,b)</span> または <span class="math inline">aRb</span> と書く.</p>
<p><span class="math display">R:=\{\left\lt a,b\right\gt\mid a\in A,b\in B,aRb\}</span></p>
<p><span class="math inline">(a,b)\not\in R</span> ならば <span class="math inline">a</span> と <span class="math inline">b</span> は関係 <span class="math inline">R</span> にないといい, <span class="math inline">\overline{R}(a,b)</span> または <span class="math inline">a\overline{R}b</span> と書く. このとき <span class="math inline">A=B</span> ならば二項関係 <span class="math inline">R\subseteq (A^2=A\times B)</span> を <span class="math inline">A</span> 上の二項関係という<a href="/roki.log/2019/03/15/Relation/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>例えば, 自然数の集合 <span class="math inline">\mathbb{N}</span> に対し, その<a href="/roki.log/2019/03/15/Relation/#equivalence_relation">同値関係</a> “<span class="math inline">=</span>” を順序体を用いて新たに</p>
<p><span class="math display">R:=\{\left\lt n,n\right\gt\mid n\in \mathbb{N}\}\subseteq\mathbb{N}^2</span></p>
<p>と定義すると <span class="math inline">a,b\in \mathbb{N}</span> に対して <span class="math inline">a R_=b\Leftrightarrow a=b</span> である. また, 集合 <span class="math inline">X={1,2,3}</span> に対し, その<a href="/roki.log/2019/03/15/Relation/#ordered_relation">順序関係</a> <span class="math inline">R_\gt\subseteq X^2</span> を大なりの関係 “<span class="math inline">\gt</span>” とすると <span class="math inline">R_\gt</span> は</p>
<p><span class="math display">R_\gt=\{\left\lt 2,1\right\gt, \left\lt 3,1\right\gt, \left\lt 3,2\right\gt\}</span></p>
<p>となる. ここで, 逆関係を導入する. 関係 <span class="math inline">R</span> の逆関係は <span class="math inline">B</span> から <span class="math inline">A</span> への関係, すなわち</p>
<p><span class="math display">R^{-1}:=\{\left\lt b,a\right\gt\mid a\in A, b\in B, aRb\}</span></p>
<p>と定義される. 従って, 例えば集合 <span class="math inline">X</span> に対する <span class="math inline">R_\gt</span> の逆関係は <span class="math inline">R_\gt^{-1}={\left\lt 1,2\right\gt, \left\lt 1,3\right\gt, \left\lt 2,3\right\gt}</span> である.</p>
<p>二項関係は, より一般化することができる.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="n-ary_relation"><span class="math inline">n</span> 項関係</span>
</p>
</header>
<div class="m-def-content">
<p>いま複数の集合の直積の部分集合, すなわち <span class="math inline">n</span> 項関係 <span class="math inline">R\subseteq\prod_{i=1}^{n}A_i</span> があって, <span class="math inline">\left\lt a_1,a_2,\cdots,a_n\right\gt\in R</span> ならば <span class="math inline">a_1,a_2,\cdots,a_n</span> は 関係 <span class="math inline">R</span> にあるといい, <span class="math inline">R(a_1,a_2,\cdots,a_n)</span> と書く.</p>
<p><span class="math display">R:=\{\left\lt a_1,a_2,\cdots,a_n\right\gt\mid a_1\in A_1,a_2\in A_2,\cdots,a_n\in A_n, R(a_1,a_2,\cdots,a_n)\}\subseteq\prod_{i=1}^{n}A_i</span></p>
また <span class="math inline">\left\lt a_1,a_2,\cdots,a_n\right\gt\not\subseteq R</span> ならば <span class="math inline">a_1,a_2,\cdots,a_n</span> は 関係 <span class="math inline">R</span> にないといい, <span class="math inline">\overline{R}(a_1,a_2,\cdots,a_n)</span> と書く.
</div>
</div>
<p>ここで, 本ブログ内で特に断りなく使われる一般的な関係に関する記号の表記, その意図について表明しておく.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="order_symbol">本ブログで使われる一般的な関係に関する記号表記</span>
</p>
</header>
<div class="m-def-content">
任意の二項関係 <span class="math inline">\lesssim</span> の要素 <span class="math inline">\left\lt a,b\right\gt\in\ \lesssim</span> に対し:
<ul>
<li>
<span class="math inline">\prec\ :={\left\lt a,b \right\gt\mid \left\lt a, b\right\gt\in\ \lesssim, a\not=b}</span>
</li>
<li>
<span class="math inline">\ll\ :={\left\lt a,b\right\gt\mid\left\lt a, c\right\gt\not\in\ \lesssim\ {\rm かつ}\ \left\lt c,b\right\gt\not\in\ \lesssim}</span>
</li>
</ul>
</div>
</div>
<p>すなわち, <span class="math inline">x\prec y</span> は <span class="math inline">x</span> は真に <span class="math inline">y</span> の前にある, <span class="math inline">x\ll y</span> は <span class="math inline">x</span> は <span class="math inline">y</span> の直前にあることを意味する.</p>
<h2 id="主な二項関係の規則">主な二項関係の規則</h2>
<p>主な二項関係における規則を以下に定義する.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="reflexive_relation">反射律</span>
</p>
</header>
<div class="m-def-content">
二項関係 <span class="math inline">R\subseteq A\times B</span>, また <span class="math inline">x\in A\cap B</span> があって, <span class="math inline">\left\lt x,x\right\gt\in R</span> が存在するとき <span class="math inline">R</span> は反射律を満たすという.
</div>
</div>
<p>例えば, 実数の集合 <span class="math inline">\mathbb{R}</span> をとってみると, 任意の <span class="math inline">^\forall x\in\mathbb{R}</span> に対して <span class="math inline">x\leq x</span> であるから <span class="math inline">\leq</span> は <span class="math inline">\mathbb{R}</span> の下で反射律を満たす. しかし, <span class="math inline">x\lt x</span> は成立しないので, <span class="math inline">\lt</span> は <span class="math inline">\mathbb{R}</span> の下で反射律を満たさない.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="symmetric_relation">対称律</span>
</p>
</header>
<div class="m-def-content">
二項関係 <span class="math inline">R\subseteq A\times B</span>, また <span class="math inline">x,y\in A\cap B</span> があって, <span class="math inline">\left\lt x,y\right\gt\in R</span> ならば <span class="math inline">\left\lt y,x\right\gt \in R</span> が存在するとき, <span class="math inline">R</span> は対称律を満たすという.
</div>
</div>
<p>例えば, 実数の集合 <span class="math inline">\mathbb{R}</span> をとってみると, 自明な例でいえば, 任意の <span class="math inline">^\forall x,y\in\mathbb{R}</span> に対して <span class="math inline">x=y</span> ならば <span class="math inline">y=x</span> なので <span class="math inline">=</span> は <span class="math inline">\mathbb{R}</span> の下で対称律を満たす. しかし, <span class="math inline">x\lt y</span> ならば <span class="math inline">y\lt x</span> ではないので, <span class="math inline">\lt</span> は <span class="math inline">\mathbb{R}</span> の下で対称律を満たさない. また, 別の例として, 例えば平面状のすべての三角形から成る集合 <span class="math inline">A</span> と, 相似の関係 <span class="math inline">R</span> を組み合わせると <span class="math inline">R</span> は <span class="math inline">A</span> 上で対称律を満たす. <span class="math display">R=\{\left\lt x,y\right\gt\mid x,y\in A,x\ {\rm と}\ y\ {\rm は相似}\}\subseteq A^2</span> なお, これは<a href="/roki.log/2019/03/15/Relation/#equiv_relation">同値律</a>を満たす. 対称律の特徴を挙げると:</p>
<ul>
<li>必ずしも <span class="math inline">x=y</span> ではない</li>
<li>真に大きい/小さい関係はあり得ない. <span class="math inline">R\not=\ \prec</span> かつ <span class="math inline">R\not=\ \succ</span> (すべてのありとあらゆる集合上で <span class="math inline">x\prec y ならば y\not\prec x</span> なので)</li>
</ul>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="antisymmetric_relation">反対称律</span>
</p>
</header>
<div class="m-def-content">
二項関係 <span class="math inline">R\subseteq A\times B</span>, また <span class="math inline">x,y\in A\cap B</span> があって, <span class="math inline">\left\lt x,y\right\gt\in R</span> に対し <span class="math inline">\left\lt y,x\right\gt\in R</span> が存在するならば <span class="math inline">x=y</span> のとき, <span class="math inline">R</span> は反対称律を満たすという.
</div>
</div>
<p>例えば, 集合 <span class="math inline">A=\{a_1,a_2\}</span> に対して 二項関係を:</p>
<ul>
<li><span class="math inline">R=\{\left\lt a_1,a_1\right\gt,\left\lt a_2,a_2\right\gt\}</span> とおくと, <span class="math inline">R</span> は <span class="math inline">A</span> 上で (<a href="/roki.log/2019/03/15/Relation/#symmetric_relation">対称律</a>を満たし) 反対称律を満たす. なお, これは<a href="/roki.log/2019/03/15/Relation/#equiv_relation">同値律</a>を満たす.</li>
<li><span class="math inline">R=\{\left\lt a_1,a_1\right\gt,\left\lt a_1,a_2\right\gt\}</span> とおくと, <span class="math inline">R</span> は <span class="math inline">A</span> 上で (<a href="/roki.log/2019/03/15/Relation/#symmetric_relation">対称律</a>を満たさないが) 反対称律を満たす.</li>
<li><span class="math inline">R=\{\left\lt a_1,a_2\right\gt,\left\lt a_2,a_1\right\gt\}</span> とおくと, <span class="math inline">R</span> は <span class="math inline">A</span> 上で (<a href="/roki.log/2019/03/15/Relation/#symmetric_relation">対称律</a>を満たすが) 反対称律を満たさない.</li>
</ul>
<p>反対称律の特徴を挙げると:</p>
<ul>
<li>対象的な二項関係が存在するとき, 必ず <span class="math inline">x=y</span></li>
</ul>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="transitive_relation">推移律</span>
</p>
</header>
<div class="m-def-content">
<p>二項関係 <span class="math inline">R\subseteq A\times B</span>, また <span class="math inline">x,y,z\in A\cap B</span> があって, <span class="math inline">\left\lt x,y\right\gt,\left\lt y,z\right\gt\in R</span> ならば <span class="math inline">\left\lt x,z\right\gt \in R</span> が存在するとき, <span class="math inline">R</span> は推移律を満たすという.</p>
</div>
</div>
<p>例えば, 実数の集合 <span class="math inline">\mathbb{R}</span> をとってみると, 任意の <span class="math inline">^\forall x,y,z\in\mathbb{R}</span> に対して <span class="math inline">x\leq y</span> かつ <span class="math inline">y\leq z</span> ならば <span class="math inline">x\leq z</span> なので <span class="math inline">\leq</span> は <span class="math inline">\mathbb{R}</span> の下で推移律を満たす. しかし, 例えば自然数の集合 <span class="math inline">\mathbb{N}</span> に対して <span class="math display">R=\left\{\left\lt a, b\right\gt\mid a,b,c\in\mathbb{N}, a=b^2\ {\rm かつ}\ b=c^2\ {\rm ならば}\ a=c^2\ {\rm を満たす}\right\}\subseteq\mathbb{N}^2</span> としたとき, 任意の <span class="math inline">x,y\in A</span> に対し必ずしも <span class="math inline">\left\lt x,y\right\gt\in R</span> が存在するとは限らない (反例: <span class="math inline">16=4^2</span> かつ <span class="math inline">4=2^2</span> だが <span class="math inline">16\not=2^2</span>) ので, <span class="math inline">R</span> は <span class="math inline">\mathbb{N}</span> の下で推移律を満たさない.</p>
<h3 id="主な二項関係">主な二項関係</h3>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="previous_order">前順序</span>
</p>
</header>
<div class="m-def-content">
<p>二項関係 <span class="math inline">R</span> が集合 <span class="math inline">A</span> 上で<a href="/roki.log/2019/03/15/Relation/#reflexive_relation">反射律</a>, <a href="/roki.log/2019/03/15/Relation/#transitive_relation">推移律</a>を同時に満たすとき, <span class="math inline">R</span> は <span class="math inline">A</span> 上の前順序関係という.</p>
</div>
</div>
<p>これは要するに, じゃんけんのような, 3 すくみ, すなわち グー <span class="math inline">\lesssim</span> パー <span class="math inline">\lesssim</span> チョキ <span class="math inline">\lesssim</span> グー <span class="math inline">\lesssim\cdots</span> といった循環関係がないこと, グラフで表したときに有向非巡回グラフとなることを要請している.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="equiv_relation">同値</span>
</p>
</header>
<div class="m-def-content">
<a href="/roki.log/2019/03/15/Relation/#previous_order">前順序関係</a> <span class="math inline">R</span> が集合 <span class="math inline">A</span> 上で<a href="/roki.log/2019/03/15/Relation/#symmetric_relation">対称律</a>を満たすとき, <span class="math inline">R</span> は <span class="math inline">A</span> 上で同値律を満たすという. また:
<ul>
<li>
<span class="math inline">\{y\in X\mid xRy\}</span> を <span class="math inline">x</span> の同値類といい, <span class="math inline">\left[x\right]_R</span> や <span class="math inline">\left[x\right]</span> と書く. このときの <span class="math inline">x</span> は, 同値類 <span class="math inline">\left[x\right]</span> の代表元という
</li>
<li>
集合 <span class="math inline">A</span> 上の同値関係 <span class="math inline">R</span> の同値類全体から成る集合 <span class="math inline">\{[a]\mid a\in A\}</span> を商集合といい, <span class="math inline">A/R</span> と書く
</li>
</ul>
</div>
</div>
<p>まず自明な例でいえば, <span class="math inline">=</span> は, 空でない任意の集合上で同値関係にあるといえる. ほかに, 例えば, 整数の集合 <span class="math inline">\mathbb{Z}</span> について <span class="math inline">R</span> を整数 <span class="math inline">p\in\mathbb{Z}</span> を法とする合同関係 <span class="math inline">\equiv_p</span> とおくと, <span class="math inline">R</span> は <span class="math inline">\mathbb{Z}</span> 上の同値関係となる. <span class="math display">R=\equiv_p=\{\left\lt m,n\right\gt\mid m,n\in\mathbb{Z}, m {\rm と}\ n\ {\rm は}\ p\ {\rm で割ったときの余りが等しい}\}\subseteq\mathbb{Z}^2</span> 一つ一つ確認してみると</p>
<ul>
<li>反射律: 任意の <span class="math inline">m\in\mathbb{Z}</span> に対して <span class="math inline">m-m=0\cdot p</span> なので <span class="math inline">m\equiv_p m</span></li>
<li>推移律: 任意の <span class="math inline">m,n,k\in\mathbb{Z}</span> に対して <span class="math inline">m\equiv_p n</span> かつ <span class="math inline">n\equiv_p k</span> と仮定すると, ある <span class="math inline">d,d'\in\mathbb{Z}</span> に対して <span class="math inline">m-n=d\cdot p</span> かつ <span class="math inline">n-k=d'\cdot p</span> で, このとき <span class="math inline">m-k=(m-n)+(n-k)=(d+d')\cdot p</span> である. <span class="math inline">d+d'\in\mathbb{Z}</span> なので, <span class="math inline">m\equiv_p k</span></li>
<li>対称律: 任意の <span class="math inline">m,n\in\mathbb{Z}</span> に対して <span class="math inline">m\equiv_p n</span> と仮定すると, ある <span class="math inline">d\in\mathbb{Z}</span> に対して <span class="math inline">m-n=d\cdot p</span> だから <span class="math inline">n-m=(-d)\cdot p</span> で, <span class="math inline">-d\in\mathbb{Z}</span> だから <span class="math inline">n\equiv_p m</span></li>
</ul>
<p>と同値律を満たすことがわかる.</p>
<p>同値類や商集合の例として, 集合 <span class="math inline">X={1,3,6,10,11,15,16}\subseteq \mathbb{N}</span> の要素 <span class="math inline">1</span> を代表元とし, いまその同値関係を <span class="math inline">5</span> を法とした合同<a href="/roki.log/2019/03/15/Relation/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>で考えると, <span class="math inline">1</span> の同値類 <span class="math inline">\left[1\right]_R={x\mid 1\equiv x\pmod{5}}</span> は <span class="math inline">\left[1\right]_R={1,6,11,16}</span> である<a href="/roki.log/2019/03/15/Relation/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. また,</p>
<p>であるので, <span class="math inline">X/R={{1,6,11,16},{10,15},{3}}</span> である.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="ordered_relation">半順序</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#previous_order">前順序関係</a> <span class="math inline">R</span> が集合 <span class="math inline">A</span> 上で<a href="/roki.log/2019/03/15/Relation/#antisymmetric_relation">反対称律</a>を満たすとき, <span class="math inline">R</span> は <span class="math inline">A</span> 上の半順序関係といい, <span class="math inline">A</span> を半順序集合 (poset) という.</p>
</div>
</div>
<p>例えば, 集合族上の包含関係 <span class="math inline">\subset</span> は以下の通り半順序である.</p>
<p>半順序集合が定義できれば, (最(大|小), 極(大|小))(要素|元)が定義できる.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="extremum">(最(大|小)|極(大|小))(要素|元)</span>
</p>
</header>
<div class="m-def-content">
<p>半順序集合 <span class="math inline">A</span> の要素 <span class="math inline">a_0\in A</span> について</p>
<ul>
<li>
<span class="math inline">^\exists a\in A\ {\rm s.t.}\ a_0\lesssim a</span> なる <span class="math inline">a</span> が存在しないとき <span class="math inline">a_0</span> を <span class="math inline">A</span> の最大(要素|元)といい, <span class="math inline">\max A</span> と書く. とくに <span class="math inline">A</span> が複素数の部分集合 <span class="math inline">A\subseteq\mathbb{C}</span> ならば, <span class="math inline">\max A</span> を最大値という
</li>
<li>
<span class="math inline">^\exists a\in A\ {\rm s.t.}\ a\lesssim a_0</span> なる <span class="math inline">a</span> が存在しないとき <span class="math inline">a_0</span> を <span class="math inline">A</span> の最小(要素|元)といい, <span class="math inline">\min A</span> と書く. とくに <span class="math inline">A</span> が複素数の部分集合 <span class="math inline">A\subseteq\mathbb{C}</span> ならば, <span class="math inline">\min A</span> を最小値という
</li>
</ul>
<p>また <span class="math inline">a\in A</span> に対し</p>
<ul>
<li>
<span class="math inline">a\gtrsim a_0</span> ならば <span class="math inline">a=a_0</span> のとき <span class="math inline">a_0</span> を <span class="math inline">A</span> の極大(要素|元)という
</li>
<li>
<span class="math inline">a\lesssim a_0</span> ならば <span class="math inline">a=a_0</span> のとき <span class="math inline">a_0</span> を <span class="math inline">A</span> の極小(要素|元)という
</li>
</ul>
<p><span class="math inline">A</span> に最小元が存在するとき, <span class="math inline">A</span> は点付き (pointed) であるという. また, 最大値, 最小値あるいは極大値, 極小値を総じて extremum という (<a href="/roki.log/2019/03/15/Relation/#ref1">参考文献 1</a>, <a href="/roki.log/2019/03/15/Relation/#ref2">参考文献 2</a>).</p>
</div>
</div>
<p>例えば, 自然数全体の集合 <span class="math inline">\mathbb{N}</span> の最小要素は <span class="math inline">0</span> であるが, 最大要素は存在しない. 実数全体の集合 <span class="math inline">\mathbb{R}</span> には最(大|小)要素が存在しない<a href="/roki.log/2019/03/15/Relation/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. 集合 <span class="math inline">X={x_1,x_2,x_3}</span> に対して順序集合 <span class="math inline">(\wp(X)-{\emptyset,X},\leq)</span><a href="/roki.log/2019/03/15/Relation/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> の極大要素は <span class="math inline">{x_1,x_2},{x_1,x_3},{x_2,x_3}</span>, また極小要素は <span class="math inline">{x_1},{x_2},{x_3}</span> である.</p>
<p>半順序集合が定義できれば, (上|下)(界|限)が定義できる.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="upper_least_bound">(上|下)(界|限)</span>
</p>
</header>
<div class="m-def-content">
半順序集合 <span class="math inline">(\wp(X),\leq)</span> の空でない部分集合 <span class="math inline">A\not =\emptyset</span> の任意の要素 <span class="math inline">a\in A</span> に対し,
<ul>
<li>
<span class="math inline">^\exists x\in X\ {\rm s.t.}\ a\lesssim x</span> なる <span class="math inline">x</span> が存在するならば <span class="math inline">A</span> は上に有界であるといい, <span class="math inline">x</span> を <span class="math inline">A</span> の上界という.
</li>
<li>
<span class="math inline">^\exists x\in X\ {\rm s.t.}\ x\gtrsim a</span> なる <span class="math inline">x</span> が存在するならば <span class="math inline">A</span> は下に有界であるといい, <span class="math inline">x</span> を <span class="math inline">A</span> の下界という.
</li>
<li>
<span class="math inline">A</span> の上界全体の集合 <span class="math inline">B=\{x\in X | a\lesssim x\}</span> の最小要素 <span class="math inline">\min B</span> を <span class="math inline">A</span> の上限, または最小上界といい, <span class="math inline">\sup A</span> と書く.
</li>
<li>
<span class="math inline">A</span> の下界全体の集合 <span class="math inline">B=\{x\in X | x\lesssim a\}</span> の最大要素 <span class="math inline">\max B</span> を <span class="math inline">A</span> の下限, または最大下限といい, <span class="math inline">\inf A</span> と書く.
</li>
</ul>
</div>
</div>
<p>例えば, 集合 <span class="math inline">X={1,\frac{1}{2},\frac{1}{3},\frac{1}{4},\cdots}</span> について, 上界および最大値は <span class="math inline">\sup A=\max A=1</span>, 下界は <span class="math inline">\inf A=0</span>, 最小値は存在しないといえる. また, 実数全体の集合 <span class="math inline">R</span> の空でない部分集合が(上|下)に有界ならば, その(上|下)限が必ず存在する. これは, ワイエルストラスの定理といわれる.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="directed_set_def">有向 (directed) 集合</span>
</p>
</header>
<div class="m-def-content">
<p>集合 <span class="math inline">A\not=\emptyset</span> と<a href="/roki.log/2019/03/15/Relation/#previous_order">前順序関係</a> <span class="math inline">R</span> との組 <span class="math inline">(A,R)</span> に対し, <span class="math inline">A</span> の任意の有限部分集合 <span class="math inline">X\subseteq A</span> の上界 <span class="math inline">\sup X\in A</span> が存在するとき, <span class="math inline">A</span> を有向 (directed) 集合という.</p>
</div>
</div>
<p>有向集合は, <a href="/roki.log/2019/03/15/Relation/#antisymmetric_relation">反対称律</a>を要請されていないので, 必ずしも<a href="/roki.log/2019/03/15/Relation/#ordered_relation">半順序</a>集合とはならないことに注意. 例えば, 集合 <span class="math inline">A=\{a_1,a_2,a_3\}</span> と関係 <span class="math inline">R=\{\left\lt a_1,a_1\right\gt,\left\lt a_1,a_2\right\gt,\left\lt a_1,a_3\right\gt, \left\lt a_2,a_2\right\gt,\left\lt a_3,a_3\right\gt,\left\lt a_3,a_1\right\gt,\left\lt a_3,a_2\right\gt\}</span> の組は, 半順序でない有向集合である (<span class="math inline">\left\lt a_1,a_3\right\gt,\left\lt a_3,a_1\right\gt\in R</span> だが, <span class="math inline">a_1=a_3</span> は要請していない).</p>
<figure style="text-align:center;" id="directed_but_not_poset_fig">
<img src="/roki.log/2019/03/15/Relation/directed_but_not_poset.svg" />
<figcaption>
図 1: 集合 <span class="math inline">A=\{a_1,a_2,a_3\}</span> と関係 <span class="math inline">R=\{\left\lt a_1,a_1\right\gt, \left\lt a_1,a_2\right\gt,\left\lt a_1,a_3\right\gt, \left\lt a_2,a_2\right\gt,\left\lt a_3,a_3\right\gt, \left\lt a_3,a_1\right\gt,\left\lt a_3,a_2\right\gt\}</span> の有向グラフによる図示
</figcaption>
</figure>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="complete_order">全順序</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#ordered_relation">半順序関係</a> <span class="math inline">R</span> が集合 <span class="math inline">A</span> 上の任意の要素に対して比較可能であるとき, <span class="math inline">R</span> は <span class="math inline">A</span> 上の全順序関係という.</p>
</div>
</div>
<p>任意の全順序集合の有限部分集合は明らかに最大要素がただ 1 つ存在するため有界であるので, 有向集合である. その他, 例えば, 大小関係 <span class="math inline">\leq</span> は自然数の集合 <span class="math inline">\mathbb{N}</span> 上で全順序関係である.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="omega_chain"><span class="math inline">\omega</span> 鎖</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#ordered_relation">半順序関係</a> <span class="math inline">R</span> と集合 <span class="math inline">A</span> の組 <span class="math inline">\left(A,R\right)</span> に対し, 二項関係 <span class="math inline">\left\{\left\lt a_0,a_1\right\gt,\left\lt a_1,a_2\right\gt,\cdots\right\}\subseteq R</span> に関する <span class="math inline">A</span> の元の列 <span class="math display">a_0\ R\ a_1\ R\ a_2\ R \cdots</span> を <span class="math inline">\omega</span> 鎖という. 列 <span class="math inline">\left\lt a_0,a_1,a_2,\cdots\right\gt</span> は自然数の集合と 1 対 1 に対応し, <span class="math inline">i\leq j\Rightarrow \left\lt a_i,a_j\right\gt\in R</span>.</p>
</div>
</div>
<p><span class="math inline">\omega</span> 鎖は (関係 <span class="math inline">R</span> の部分集合と示したように), 自然数の連鎖と同型の半順序集合の部分集合についてをいい, 全順序集合と同じ理由より明らかに有向集合である. 教科書によっては, <span class="math inline">\omega</span> 鎖が上限を持つ構造を <a href="/roki.log/2019/03/15/Relation/#cpo_def">cpo</a> や <span class="math inline">\omega</span>-<a href="/roki.log/2019/03/15/Relation/#cpo_def">cpo</a> ということがある.</p>
<p>上記で定義した二項関係と集合間の射について定義する.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="monotone_def">単調 (monotone)</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#ordered_relation">半順序関係</a> <span class="math inline">R_0,R_1\subseteq R</span> と集合 <span class="math inline">A_0,A_1\subseteq A</span> の組 <span class="math inline">\left(A_0,R_0\right),\left(A_1,R_1\right)</span> と射 <span class="math inline">f:A_0\rightarrow A_1</span> について以下が成りたつとき, <span class="math inline">f</span> は単調である (または単調関数) という. <span class="math display">^\forall a_0,a_1\in A_0.\left\lt a_0,a_1\right\gt\in R_0\Rightarrow \left\lt f(a_0),f(a_1)\right\gt\in R_1</span></p>
</div>
</div>
<h2 id="ハッセ図">ハッセ図</h2>
<p>主に半順序集合の図示の方法としてよく使われるハッセ図について, 以下にいくつかの例を示す.</p>
<p>まずは, 入門書でよく見る例題に習い, 自然数全体の集合 <span class="math inline">\mathbb{N}</span> の任意の要素 <span class="math inline">m,n\in\mathbb{N}</span> について, <span class="math inline">m</span> が <span class="math inline">n</span> を割り切ることを <span class="math inline">m\mid n</span> と書くとき<a href="/roki.log/2019/03/15/Relation/#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, 整除関係 <span class="math inline">\mid</span> は <span class="math inline">\mathbb{N}</span> 上の半順序であることに関して考察しよう.</p>
<p>さて, このような一つの有限半順序集合上の関係は, <a href="/roki.log/2019/03/15/Relation/#directed_but_not_poset_fig">図 1</a> と同様にして, 以下のように有向グラフにより表現できる. いま, 集合 <span class="math inline">X=\{n\mid n\in\mathbb{N}, 1\leq n\leq 10\}</span> に対する整除関係による順序を <span class="math inline">\ll</span> で考えると, <span class="math inline">x\mid y</span> なら <span class="math inline">y</span> は必ず <span class="math inline">x</span> の後に存在する (<span class="math inline">x\lesssim y</span>) ので, 次のような有向非巡回グラフが書ける<a href="/roki.log/2019/03/15/Relation/#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<figure style="text-align:center;">
<img src="/roki.log/2019/03/15/Relation/graph.svg" />
<figcaption>
図2: 整除の下で <span class="math inline">\ll</span> の関係における <span class="math inline">X</span> の有限グラフによる図示
</figcaption>
</figure>
<p>これをハッセ図では次のように書く.</p>
<figure style="text-align:center;" id="hasse1">
<img src="/roki.log/2019/03/15/Relation/hasse1.svg" />
<figcaption>
図3: 整除の下で <span class="math inline">\ll</span> の関係における <span class="math inline">X</span> のハッセ図による図示
</figcaption>
</figure>
<p>有向グラフが <span class="math inline">x\to y</span> というように矢印で順序を表しているのに対して, ハッセ図では <span class="math inline">y</span> を <span class="math inline">x</span> よりも高い位置に置いて, それぞれを線で結ぶ. このときの最小値および下限は <span class="math inline">1</span> であり, 上界は <span class="math inline">10,8,6,9</span> だが <span class="math inline">10,8,6,9</span> を比較不可能であるため, 上限は存在しない.</p>
<p>別の例として, <span class="math inline">X=\left\{a, b, c, d\right\}</span> とおいたとき, <span class="math inline">a\lesssim c, a\lesssim d, b\lesssim c, b\lesssim d</span> という半順序関係にある集合 <span class="math inline">(X,\lesssim)</span> を考えると, 以下のように示せる.</p>
<figure style="text-align:center;" id="hasse3">
<img src="/roki.log/2019/03/15/Relation/nonsup.svg" />
<figcaption>
図4: 半順序関係 <span class="math inline">a\lesssim c, a\lesssim d, b\lesssim c, b\lesssim d</span> のハッセ図による図示
</figcaption>
</figure>
<p>このときの下界は <span class="math inline">a,b</span>, 上界は <span class="math inline">c,d</span> である. 最小元, 最大元, 下限, 上限は <span class="math inline">a,b</span> および <span class="math inline">c,d</span> が比較不可能であるため存在しない.</p>
<p>最後にもう 1 つ, 半順序集合 <span class="math inline">(\wp({x_1,x_2,x_3}), \subset)</span> について考えてみる. 先にも示したように, 集合族上の包含関係 <span class="math inline">\subset</span> は半順序である. <span class="math inline">\emptyset\subset{x_1},{x_1}\subset{x_1,x_2},\cdots</span> と考えていくと, ハッセ図は次のようになる.</p>
<figure style="text-align:center;" id="hasse2">
<img src="/roki.log/2019/03/15/Relation/hasse4.svg" />
<figcaption>
図5: 半順序集合 <span class="math inline">(\wp({x_1,x_2,x_3}), \subset)</span> のハッセ図による図示
</figcaption>
</figure>
<p>このときの最小元および下限は <span class="math inline">\emptyset</span> であり, 最大元および上限は <span class="math inline">{x_1,x_2,x_3}</span> である.</p>
<h2 id="半順序集合の拡張">半順序集合の拡張</h2>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="directet_partial_set_def">有向半順序 (directed partial order) 集合</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#ordered_relation">半順序関係</a> <span class="math inline">R</span> と<a href="/roki.log/2019/03/15/Relation/#directed_set_def">有向集合</a> <span class="math inline">A</span> の組 <span class="math inline">(A, R)</span> に対し <span class="math inline">A</span> を有向半順序 dpo (directed partial order) 集合という.</p>
</div>
</div>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="dcpo_def">有向完備半順序 (directed-complete partial order) 集合</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#ordered_relation">半順序</a>集合 <span class="math inline">A</span> の任意の有向部分集合 <span class="math inline">X\subseteq A</span> について, <span class="math inline">X</span> の上限 <span class="math inline">\sup X\in A</span> が存在するとき, <span class="math inline">A</span> を有向完備半順序 dcpo (directed complete partial order) 集合という.</p>
</div>
</div>
<p>いま <span class="math inline">X\subseteq A</span> を有限有向部分集合としたとき, 有限半順序集合 <span class="math inline">A</span> の部分集合 <span class="math inline">X</span> は, <span class="math inline">A</span> の半順序関係により必ず有向部分集合となる. つまり, 有限半順序集合は dcpo 集合になる. 従って, <a href="/roki.log/2019/03/15/Relation/#hasse1">図 3</a>, <a href="/roki.log/2019/03/15/Relation/#hasse3">図 4</a>, <a href="/roki.log/2019/03/15/Relation/#hasse2">図 5</a> で示される集合は dcpo 集合である (上記の定義のニュアンスとして, たまに任意の部分集合が有向部分集合でなければならないと捉えられる場合があるが, そうではなく, あくまで有向部分集合として構成可能な部分集合のうちという意味合いである). 教科書によっては, dcpo を単に完備半順序, また cpo ということがある. また, すべての <span class="math inline">\omega</span> 鎖はその定義より有向集合であるから, dcpo は (その部分集合に <span class="math inline">\omega</span> 鎖が存在する場合) <span class="math inline">\omega</span> 鎖が上限を持つとして <span class="math inline">\omega</span>-cpo である. その逆は必ずしも成り立たない.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="continuous_def">連続 (continuous)</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#dcpo_def">dcpo</a> 集合 <span class="math inline">D,D'</span> について, <a href="/roki.log/2019/03/15/Relation/#monotone_def">単調関数</a> <span class="math inline">f:D\rightarrow D'</span> が以下を満たすとき, (Scott-) 連続 (continuous) であるという. <span class="math display">^\forall A\subseteq D.f(\sup A)=\sup\left\{f(a)\mid a\in A\right\}</span> ここで <span class="math inline">A</span> は<a href="/roki.log/2019/03/15/Relation/#directed_set_def">有向集合</a>.</p>
</div>
</div>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="compact_def">コンパクト (compact)</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#dcpo_def">dcpo</a> <span class="math inline">R</span> と集合 <span class="math inline">D</span> の組 <span class="math inline">(D,R)</span> に対し, 以下の条件を満たすとき, <span class="math inline">x\in D</span> はコンパクトであるという. <span class="math display">^\forall A\subseteq D. \left\lt x,\sup A\right\gt\in R\Rightarrow ^\exists y\in A.\left\lt x,y\right\gt \in R\tag{\htmlId{compact}{1}}</span> ここで <span class="math inline">A</span> は有向集合. なお, 条件式 <span class="math inline">\href{#compact}{1}</span> を満たす元全体を次のように書くこともある. <span class="math display">\mathrm{K}(D):=\left\{x\mid\text{条件式}\ \href{#compact}{1}\ \text{を満たす} x\in D\right\}</span></p>
</div>
</div>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="algebraic_def">代数的 (algebraic)</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#dcpo_def">dcpo</a> <span class="math inline">R</span> と集合 <span class="math inline">D</span> の組 <span class="math inline">(D,R)</span> に対し, 以下の条件を満たすとき, <span class="math inline">D</span> は代数的であるという. <span class="math display">^\forall x\in D,A=\left\{a\in\mathrm{K}(D)\mid \left\lt a,x\right\gt\in R\right\}.A\text{ は有向集合}\land\sup A=x</span></p>
</div>
</div>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="basis_def">基底 (basis)</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#dcpo_def">dcpo</a> <span class="math inline">R</span> と集合 <span class="math inline">D</span> の組 <span class="math inline">(D,R)</span> 対し, 以下の条件を満たすとき, <span class="math inline">A\subseteq\mathrm{K}(D)</span> を <span class="math inline">D</span> の基底という. <span class="math display">^\forall x\in D,A=\left\{a\in A\mid \left\lt a,x\right\gt\in R\right\}.A\text{ は有向集合}\land\sup A=x</span></p>
</div>
</div>
<p>ここで <span class="math inline">A</span> が <span class="math inline">D</span> の基底であるとき, <span class="math inline">D</span> は代数的であり <span class="math inline">\mathrm{K}(D)=A</span> である.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="cpo_def"><a href="/roki.log/2019/03/15/Relation/#extremum">点付き</a>有向完備半順序 (pointed directed-complete partial order) 集合</span>
</p>
</header>
<div class="m-def-content">
次の 2 つの条件を満たす<a href="/roki.log/2019/03/15/Relation/#ordered_relation">半順序</a>集合 <span class="math inline">A</span> を<a href="/roki.log/2019/03/15/Relation/#extremum">点付き</a>有向完備半順序集合 cppo (pointed directed-complete partial order) という.
<ol>
<li>
<span class="math inline">A</span> は <a href="/roki.log/2019/03/15/Relation/#dcpo_def">dcpo</a> 集合
</li>
<li>
<span class="math inline">A</span> は最小元をもつ
</li>
</ol>
</div>
</div>
<p>以下にいくつかの例を示す.</p>
<ul>
<li>任意の集合 <span class="math inline">A</span> について, <span class="math inline">A</span> の部分集合全体の集合 <span class="math inline">\mathcal{P}(A)=\left\{S\mid S\subseteq A\right\}</span> は, 集合の包含関係 <span class="math inline">\subseteq</span> との組 <span class="math inline">\left(\mathcal{P}(A),\subseteq\right)</span> で <a href="/roki.log/2019/03/15/Relation/#cpo_def">cppo</a> となる (さらに, すべての <span class="math inline">P\subseteq\mathcal{P}(A)</span> について <span class="math inline">P</span> の上限 <span class="math inline">\sup P\in\mathcal{P}(A)</span> が存在するから, <span class="math inline">\mathcal{P}(A)</span> は<a href="/roki.log/2019/03/15/Relation/#lattice_def">完備束</a>でもある)</li>
<li><a href="/roki.log/2019/03/15/Relation/#hasse1">図 3</a> および <a href="/roki.log/2019/03/15/Relation/#hasse2">図 5</a> で示される集合は <a href="/roki.log/2019/03/15/Relation/#dcpo_def">dcpo</a> でありかつ最小元をもつため <a href="/roki.log/2019/03/15/Relation/#cpo_def">cppo</a> だが, <a href="/roki.log/2019/03/15/Relation/#hasse4">図 4</a> は最小元をもたないため, <a href="/roki.log/2019/03/15/Relation/#cpo_def">cppo</a> ではない</li>
<li><span class="math inline">(\mathbb{N}, \leq)</span> は, 有向集合として <span class="math inline">\mathbb{N}\subseteq\mathbb{N}</span> が取れるが, その上限は存在しないので, <a href="/roki.log/2019/03/15/Relation/#cpo_def">cppo</a> ではない. ここで, <span class="math inline">\infty = \max \mathbb{N}</span> となるように拡張した <span class="math inline">(\mathbb{N}\cup\{\infty\},\leq)</span> で考えると, <a href="/roki.log/2019/03/15/Relation/#cpo_def">cppo</a> になる</li>
</ul>
<p>教科書によっては, <a href="/roki.log/2019/03/15/Relation/#cpo_def">cppo</a> を単に完備半順序, また cpo ということがある.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="continuous_def">正格, 厳密 (strict)</span>
</p>
</header>
<div class="m-def-content">
<p><a href="/roki.log/2019/03/15/Relation/#cpo_def">cppo</a> 集合 <span class="math inline">D,D'</span> について, 射 <span class="math inline">f:D\rightarrow D'</span> が最小元を保つ <span class="math inline">f(\min D)=\min D\in D'</span> とき, <span class="math inline">f</span> は正格または厳密であるという.</p>
</div>
</div>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="lattice_def">束</span>
</p>
</header>
<div class="m-def-content">
二項演算子 <span class="math inline">\land,\lor</span><a href="/roki.log/2019/03/15/Relation/#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> のもとで閉じている空でない集合 <span class="math inline">L</span> の任意の要素 <span class="math inline">x,y,z\in L</span> に対して, 次の三つの束の公理
<ol>
<li id="lattice1">
可換律:<span class="math inline">x\land y=y\land x, x\lor y=y\lor x</span>
</li>
<li id="lattice2">
結合律:<span class="math inline">(x\land y)\land z=x\land(y\land z), (x\lor y)\lor z=x\lor(y\lor z)</span>
</li>
<li id="lattice3">
吸収律:<span class="math inline">x\land(x\lor y)=x,x\lor(x\land y)=x</span>
</li>
</ol>
<p>を満たすとき, 集合 <span class="math inline">L</span> は束であるといい, <span class="math inline">(L,\land,\lor)</span> と表す. ここで <span class="math inline">\lor,\land</span> はそれぞれ, 結び, 交わりと言われる. いま半順序集合 <span class="math inline">S</span> の任意の要素 <span class="math inline">a,b</span> について, 上限を <span class="math display">\sup\left\{a,b\right\}:=\left\{x\mid ^\forall m\in M(x\lesssim m),x\in M\right\}, 
M=\left\{m\mid a,b\lesssim m,m\in S\right\}</span> 下限を <span class="math display">\inf\{a,b\}:=\left\{x\mid ^\forall m\in M(x\gtrsim m),x\in M\right\},
M=\left\{m\mid a,b\gtrsim m,m\in S\right\}</span> と書くこととすると, <span class="math inline">\sup\left\{a,b\right\},\inf\left\{a,b\right\}</span> はそれぞれ <span class="math inline">a\lor b,a\land b</span> と同値である. すなわち, 束とは, <span class="math inline">x, y</span> について上限と下限が存在する半順序集合のことである<a href="/roki.log/2019/03/15/Relation/#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>. また,</p>
<ul>
<li>
束 <span class="math inline">L</span> の任意の部分集合が上限と下限をもつとき, 束 <span class="math inline">L</span> をとくに完備束
</li>
<li>
束の部分集合が束であるとき, その束をとくに部分束
</li>
<li>
束 <span class="math inline">L</span> の任意の要素 <span class="math inline">^\forall x,y\in L</span> について <span class="math inline">f(x\land y)=f(x)\land f(y), f(x\lor y)=f(x)\lor f(y)</span> を満足する単射 <span class="math inline">f: L_1\to L_2</span> が存在するとき束 <span class="math inline">L_1,L_2</span> は同型
</li>
<li>
束の任意の要素 <span class="math inline">x,y,z</span> について <span class="math inline">x\lor(y\land z)=(x\lor y)\land(x\lor z), x\land(y\lor z)=(x\land y)\lor(x\land z)</span> を満たす束をとくに分配束
</li>
</ul>
<p>という.</p>
</div>
</div>
<p>例えば, <a href="/roki.log/2019/03/15/Relation/#hasse2">先の例</a>でも挙げた <span class="math inline">(\wp({x_1,x_2,x_3}), \subset)</span> は束である. 任意の要素として <span class="math inline">{x_1},{x_2}</span> をとってみると, その上限 <span class="math inline">\sup{{x_1},{x_2}}</span> は <span class="math inline">{x_1}\subset{x_1,x_2},{x_2}\subset{x_1,x_2}</span> なので, <span class="math inline">\sup{{x_1},{x_2}}={x_1,x_2}</span> である.</p>
<figure style="text-align:center;" id="hasse3">
<img src="/roki.log/2019/03/15/Relation/hasse3.svg" />
<figcaption>
図6: 半順序集合 <span class="math inline">(\wp({x_1,x_2,x_3}), \subset)</span> のハッセ図による図示, <span class="math inline">\sup\left\{\left\{x_1\right\},\left\{x_2\right\}\right\}</span> を強調
</figcaption>
</figure>
<p>ハッセ図で考えると, 上方向に辺を辿っていったとき, 各ノードそれぞれが順序比較可能でありかつ最小であるものが上限となる. 例えば</p>
<p><span class="math display">
\begin{aligned}
\sup\left\{\left\{x_1,x_2\right\},\left\{x_2,x_3\right\}\right\}&amp;=&amp;\left\{x_1,x_2,x_3\right\}\\
\sup\left\{\left\{x_1\right\},\left\{x_2,x_3\right\}\right\}&amp;=&amp;\left\{x_1,x_2,x_3\right\}\\
\sup\left\{\emptyset,\left\{x_1,x_2\right\}\right\}&amp;=&amp;\left\{x_1,x_2\right\}\\
\sup\left\{\emptyset,\emptyset\right\}&amp;=&amp;\emptyset\tag{9}
\end{aligned}
</span></p>
<p>となる. 最後の <span class="math inline">(9)</span> はすべての束の任意の要素について言えることである. すなわち任意の束 <span class="math inline">L</span> の任意の要素 <span class="math inline">x\in L</span> に対して <span class="math inline">\sup{x,x}=x</span> である. これは, 束の公理から導ける, 一般にべき等律といわれる定理である.</p>
<div class="m-proof">
<header class="m-proof-title">
<p>
<span id="proof1">べき等律</span>
</p>
</header>
<div class="m-proof-content">
<p><span class="math inline">x,y\in L,z=(x\lor y)</span> に対して</p>
<p><span class="math display">
\begin{aligned}
\sup\left\{x,x\right\}\leftrightarrow x\lor x&amp;=&amp;x\lor(x\land(x\lor y)) &amp; (\because {\rm \href{#lattice3}{公理3}: 吸収律})\\
&amp;=&amp;x\lor (x\land z)&amp;(\because {\rm \href{#lattice3}{公理3}: 吸収律})\\
&amp;=&amp;x&amp;(\because {\rm \href{#lattice3}{公理3}: 吸収律})
\end{aligned}
</span></p>
</div>
</div>
<p>ここで一度, 上の定理に加えて考察できるいくつかの事項を羅列する.</p>
<ul>
<li>下限は, 上限の逆順序で定義されるものである. 例えば, <span class="math inline">\inf{{x_1},{x_2}}=\emptyset</span> である</li>
<li><a id="necessarily_exists_extremum" class="disabled">完備束</a> <span class="math inline">(L,\land,\lor)</span> の任意の部分集合 <span class="math inline">S\subseteq L</span> に対して <span class="math inline">S=\emptyset</span> ならば <span class="math inline">\sup S=\min L</span>, <span class="math inline">S=L</span> ならば <span class="math inline">\sup S=\max D</span> である</li>
</ul>
<p>いま, 分配束 <span class="math inline">L</span> の最大元, 最小元をそれぞれ <span class="math inline">1,0</span> と書くこととする. 束 <span class="math inline">L</span> の任意の要素 <span class="math inline">x,y\in L</span> について <span class="math inline">x\lor y=1,x\land y=0</span> を満足するとき, <span class="math inline">x</span> は <span class="math inline">y</span> の補元といい, <span class="math inline">x'</span> または <span class="math inline">\bar{x}</span> と書く. 元 <span class="math inline">1,0</span> はそれぞれ単位元, 零元である. このときの <span class="math inline">L</span> の補元は, 唯一に定まる.</p>
<div class="m-proof">
<header class="m-proof-title">
<p>
<span class="math inline">L</span> の補元の唯一性
</p>
</header>
<div class="m-proof-content">
<p><span class="math inline">x,y\in L</span> が <span class="math inline">a\in L</span> の二つの補元だと仮定する.</p>
<p><span class="math display">
\begin{aligned}
x&amp;=&amp;x\lor 0\\
&amp;=&amp;x\lor(a\land y)\\
&amp;=&amp;(x\lor a)\land(x\lor y)\\
&amp;=&amp;1\land(x\lor y)\\
&amp;=&amp;x\land y
\end{aligned}
</span></p>
<p>同様に <span class="math inline">y=x\lor y</span> となるから <span class="math inline">x=y</span>.</p>
</div>
</div>
<p>束 <span class="math inline">L</span> のすべての元が補元をもつとき, <span class="math inline">L</span> は可補束, または相補束という. 可補分配束は一般に<a href="/roki.log/2019/05/8/BooleanAlgebra/">ブール代数</a>である<a href="/roki.log/2019/03/15/Relation/#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>.</p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><a id="ref1" href="http://mathworld.wolfram.com/Extremum.html">Extremum - Wolfram MathWorld</a> 2019/3/15 アクセス.</li>
<li><a id="ref2" href="https://www.encyclopediaofmath.org/index.php?title=Maximum_and_minimum_of_a_function">Maximum and minimum of a function - Encyclopedia of Mathematics</a> 2019/3/15 アクセス.</li>
<li>赤間世紀, 長田康敬, 玉城史朗 (2006)『<a id="ref3" class="disabled">情報数学入門</a>』共立出版. ISBN-13: 978-4320018143</li>
<li>“Directed complete partial orders”, <a href="http://math.chapman.edu/~jipsen/structures/doku.php/directed_complete_partial_orders" class="uri">http://math.chapman.edu/~jipsen/structures/doku.php/directed_complete_partial_orders</a> 2020/7/9 アクセス.</li>
<li>S. Abramsky, A. Jung: Domain theory. In S. Abramsky, D. M. Gabbay, T. S. E. Maibaum, editors (1994)『Handbook of Logic in Computer Science, vol. III』, Oxford University Press.</li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>例えば <span class="math inline">xy</span> 座標平面を <span class="math inline">\mathbb{R}^2</span> と書くのは, それが実数二つのペアの集合と考えられるからである.<a href="/roki.log/2019/03/15/Relation/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote">任意の整数 <span class="math inline">a,b,c,n\in \mathbb{N}</span> に対して
<p>であることを容易に確かめられる. 従って, 合同は同値関係である.<a href="/roki.log/2019/03/15/Relation/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>これをとくに剰余類という. FYI: <a href="/roki.log/2018/07/13/elgamalEncryption/">エルガマル暗号, ガロア体のセクションを参照</a>.<a href="/roki.log/2019/03/15/Relation/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>関連: <a href="/roki.log/2018/10/4/jacobian/#epsilonDelta-definitionOfLimit"><span class="math inline">\epsilon-\delta</span> 論法</a><a href="/roki.log/2019/03/15/Relation/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>ここで, <span class="math inline">\wp(A)</span> は <span class="math inline">\wp(A):={Y\mid Y\subseteq A}</span> であり, <span class="math inline">A</span> の冪集合という. すなわち <span class="math inline">A={a,b}</span> とすると <span class="math inline">\wp(A)={\emptyset,{a},{b},{a,b}}</span> となる. いまその要素の個数を <span class="math inline">\left|\wp(A)\right|</span> と書くとすると, <span class="math inline">\left|\wp(A)\right|</span> は集合 <span class="math inline">A</span> の全要素の全組み合わせであるので <span class="math inline">\left|\wp(A)\right|={}_3C_0+{}_3C_1+{}_3C_2=7</span> となる. 従って, ここで取り上げた例題について丁寧に書き出してみると, <span class="math display">\wp(X)-{\emptyset,X}={X,{x_1,x_2},{x_1,x_3},{x_2,x_3},{x_1},{x_2},{x_3},\emptyset}-{\emptyset,X}</span> ということ.<a href="/roki.log/2019/03/15/Relation/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><span class="math inline">\mid</span> は整数論の界隈で普遍的な記述である. 「割り切れない」も同様にして <span class="math inline">\not\mid</span> と書いたりする. FYI: <a href="/roki.log/2018/07/13/elgamalEncryption/">エルガマル暗号</a><a href="/roki.log/2019/03/15/Relation/#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><span class="math inline">1</span> と自分自身以外の数で割り切れるかを考える. <span class="math inline">1</span> は始点なので, <span class="math inline">1</span> のノードへ向けられる辺はないだろう. <span class="math inline">2</span> について考えてみると, <span class="math inline">1\mid 2,3</span> なら <span class="math inline">1\mid 3</span> であるが, <span class="math inline">4</span> は <span class="math inline">1\mid 2\mid 4</span> である. これを全要素について適用していくと図のようになる.<a href="/roki.log/2019/03/15/Relation/#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>論理記号とは無関係であることに注意.<a href="/roki.log/2019/03/15/Relation/#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote">半順序集合 <span class="math inline">S</span> の任意の要素 <span class="math inline">x, y</span> に対して <span class="math inline">\sup{x,y},\inf{x,y}</span> が存在すれば, <span class="math inline">x, y</span> と順序関係のある <span class="math inline">z\in S</span> に対して
<p>より束の公理を満たす. 双対の原理より双対についても成り立つ.<a href="/roki.log/2019/03/15/Relation/#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote">可補束ついて次の性質が成り立つ.
<p>面倒なので証明略. <a href="/roki.log/2019/05/29/BooleanAlgebra/">ブール代数</a>のエントリにて分配律を用いずに証明しているものがあるので, それで代用できるかと.<a href="/roki.log/2019/03/15/Relation/#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>放物運動</title>
    <link href="https://roki.dev/roki.log/2019/03/7/ParabolicMotion/index.html" />
    <id>https://roki.dev/roki.log/2019/03/7/ParabolicMotion/index.html</id>
    <published>2019-03-07T00:00:00Z</published>
    <updated>2019-03-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>放物運動に関する復習と再現.</p>
<h2 id="等加速度運動をする物体の位置関数の導出">等加速度運動をする物体の位置関数の導出</h2>
<p>時刻 <span class="math inline">t=0</span> における物体の位置を <span class="math inline">{\boldsymbol x_0}</span>, 速度を <span class="math inline">{\boldsymbol v_0}</span> とし, 加速度を考慮しない等速運動の三次元空間上の一点に対する位置関数 <span class="math inline">{\boldsymbol x}(t)</span> を <span class="math display">{\boldsymbol x}(t)={\boldsymbol x_0}+{\boldsymbol v_0}t</span> とおく. このとき, 時間 <span class="math inline">t_1</span> から <span class="math inline">t_2</span> への変化量 <span class="math inline">{\boldsymbol x}(t_2)-{\boldsymbol x}(t_1)</span> を <span class="math inline">\Delta t=t_2-t_1</span> で割れば, 時間経過に対する物体の位置の対比が得られる. これは正しく速度のことであるが, これは時間 <span class="math inline">t_1</span> に位置 <span class="math inline">{\boldsymbol x}(t_1)</span>, 時間 <span class="math inline">t_2</span> に位置 <span class="math inline">{\boldsymbol x}(t_2)</span> にあった物体の平均速度である. いま時間 <span class="math inline">t</span> における物体の瞬間速度を知りたいとすると, <span class="math inline">\Delta t</span> が微小量となるように極限(<span class="math inline">t_2\to t_1\Leftrightarrow \Delta t\to 0</span>)を取れば良い.<!--more--> 従って, 物体の瞬間速度の関数 <span class="math inline">{\boldsymbol v}(t)</span> を <span class="math inline">{\boldsymbol x}(t)</span> の導関数</p>
<p><span class="math display">{\boldsymbol v}(t)=\dot{{\boldsymbol x}}(t)=\frac{d{\boldsymbol x}(t)}{dt}</span></p>
<p>でおけることがわかる. しばしば力学においては, 上のように原始関数の上部に点を記述し, 時間の微分を表現する. なお, いまは速度を一定としているので <span class="math inline">{\boldsymbol v}(t)={\boldsymbol v_0}</span> である.</p>
<p>ここで, 物体の運動が加速することを加味するために, 加速度を導入する. 加速度とは, 平均の速度とその所用時間の対比のことであり, すなわち <span class="math inline">\frac{{\boldsymbol v}(t_2)-{\boldsymbol v}(t_1)}{\Delta t}</span> である. 先と同様, <span class="math inline">\Delta t\to 0</span> としていけば, その瞬間の加速度を得ることができるから, 瞬間加速度の関数 <span class="math inline">{\boldsymbol a}(t)</span> は</p>
<p><span class="math display">{\boldsymbol a}(t)=\dot{{\boldsymbol v}}(t)=\ddot{{\boldsymbol x}}(t)=\frac{d^2{\boldsymbol x}(t)}{dt^2}</span></p>
<p>であり, 結果として 2 次導関数でおかれる. 従って, 一定の加速度 <span class="math inline">{\boldsymbol a}(t)={\boldsymbol a_0}</span> を受けている物体の瞬間速度関数は <span class="math inline">{\boldsymbol w}(t)={\boldsymbol v_0}+{\boldsymbol a_0}t</span> となるから, 時刻 <span class="math inline">t_1</span> から <span class="math inline">t_2</span> 間の移動距離は <span class="math inline">d=\int^{t_2}_{t_1}{\boldsymbol w}(t)dt</span> であり, 経過時刻 <span class="math inline">t</span> に対する物体の移動距離は同様にして <span class="math display">d=\int^t_0{\boldsymbol w}(t)dt={\boldsymbol v_0}t+\frac{{\boldsymbol a_0}t^2}{2}</span> となる. よって初期位置 <span class="math inline">x_0</span> を加えることで等加速度運動をする物体の位置関数 <span class="math inline">{\boldsymbol y}(t)</span> が <span class="math display">{\boldsymbol y}(t)={\boldsymbol x_0}+{\boldsymbol v_0}t+\frac{{\boldsymbol a_0}t^2}{2}\tag{1}</span> と定められる.</p>
<h2 id="重力を踏まえた運動">重力を踏まえた運動</h2>
<p>重力のみの影響を受ける物体の運動について考える. 三次元空間上の上方向を <span class="math inline">z</span> 軸としたとき, 下向きの重力加速度ベクトルは <span class="math inline">{\boldsymbol g}=(0,0,-g)^T</span> である. これは, 地球上において <span class="math inline">g=9.80665{\rm m/s}^2</span> と知られているから, 地球上の質量 <span class="math inline">m</span> の物体は下向きに <span class="math inline">m{\boldsymbol g}</span> の力を受けていることとなる.</p>
<p>いま時刻 <span class="math inline">t=0</span> における初期位置を <span class="math inline">{\boldsymbol x_0}=(x_0,y_0,z_0)^T</span>, 初速度を <span class="math inline">{\boldsymbol v_0}=(v_x,v_y,v_z)^T</span> としたとき, 物体 <span class="math inline">P</span> の位置は <span class="math inline">(1)</span> より <span class="math display">{\boldsymbol x}(t)={\boldsymbol x_0}+{\boldsymbol v_0}t+\frac{{\boldsymbol g}t^2}{2}\tag{2}</span> である. また, 初速度 <span class="math inline">{\boldsymbol v_0}</span> の各成分は, <span class="math inline">x</span> 方向に発射速度 <span class="math inline">v</span> で発射されるとしたとき, 三角関数を思い出せば, <span class="math inline">{\boldsymbol v_0}=(v\cos\theta,0,v\sin\theta)^T</span> であることがいえる.</p>
<h3 id="到達高度に達するとき-到達高度">到達高度に達するとき, 到達高度</h3>
<p>いま物体 <span class="math inline">P</span> が到達高度に達するときと, その高度について考える. 到達高度に達するときとは, 垂直方向の速度が <span class="math inline">0</span> であるときなので, 物体 <span class="math inline">P</span> の時刻 <span class="math inline">t</span> における <span class="math inline">z</span> 成分を <span class="math inline">(2)</span> より <span class="math display">z(t)=z_0+v_zt-\frac{gt^2}{2}\tag{3}</span> とおくと, 次のように微分方程式で表現できる.</p>
<p><span class="math display">\dot{z}(t)=v_z-gt=0\Leftrightarrow t=\frac{v_z}{g}\tag{4}</span></p>
<p>後はこの <span class="math inline">t</span> を <span class="math inline">z(t)</span> に代入すれば</p>
<p><span class="math display">
\begin{aligned}
h&amp;=&amp;z_0+v_z\frac{v_z}{g}-\frac{g}{2}(\frac{v_z}{g})^2\\
&amp;=&amp;z_0+\frac{v_z^2}{g}-\frac{v_z^2}{2g}\\
&amp;=&amp;z_0+\frac{v_z^2}{2g}
\end{aligned}
</span></p>
<p>と到達高度 <span class="math inline">h</span> が求まる. また, 到達高度を <span class="math inline">h</span> にするための発射角度 <span class="math inline">\theta</span> は上式より <span class="math inline">h=\frac{(v\sin\theta)^2}{2g}</span> だから <span class="math display">\sin^2\theta=\frac{2gh}{v^2}\Leftrightarrow\sin\theta=\frac{\sqrt{2gh}}{v}\Leftrightarrow\theta=\sin^{-1}\frac{\sqrt{2gh}}{v}</span> と求まる.</p>
<h3 id="到達距離">到達距離</h3>
<p>水平面 <span class="math inline">z_0=0</span> から物体 <span class="math inline">P</span> が発射されたときを考える. 発射されてから地面につく時刻 <span class="math inline">t</span> は <span class="math inline">(3)</span> より <span class="math display">v_zt-\frac{gt^2}{2}=t(v_z-\frac{gt}{2})=0\Leftrightarrow t=0, \frac{2v_z}{g}</span> であり, 発射した時刻と地面につく時刻の解が得られた. いま関心があるのは <span class="math inline">\frac{2v_z}{g}</span> であるが, これは <span class="math inline">(4)</span> の <span class="math inline">2</span> 倍, すなわち到達高度に達する時間の <span class="math inline">2</span> 倍の時間をかければ地面につくという, 左右対称の扇型の放物線運動を思い浮かべれば, 当然と思える結果が導けた.</p>
<p>従って, 物体 <span class="math inline">P</span> が原点から <span class="math inline">x</span> 軸方向に発射されたとすると, 到達距離 <span class="math inline">l</span> は <span class="math inline">x</span> 方向の移動距離に等しいから</p>
<p><span class="math display">l=v_x\frac{2v_z}{g}</span></p>
<p>となる. また, 到達距離を <span class="math inline">l</span> にするための発射角度 <span class="math inline">\theta</span> は上式より</p>
<p><span class="math display">
\begin{aligned}
l&amp;=&amp;\frac{2(v\cos\theta)(v\sin\theta)}{g}\\
&amp;=&amp; \frac{2v^2}{g}\sin\theta\cos\theta\\
&amp;=&amp; \frac{v^2\sin2\theta}{g}\ (\because\ 2{\rm 倍角の公式:}\ 2\sin\theta\cos\theta=\sin2\theta)
\end{aligned}
</span></p>
<p>だから <span class="math display">\theta=\frac{1}{2}\sin^{-1}\frac{lg}{v^2}</span> ただし, <span class="math inline">\sin(\pi-\theta)=\sin\theta</span> より <span class="math inline">\sin2\theta=\sin(\pi-2\theta)=\sin2(\frac{\pi}{2}-\theta)</span> とすると, <span class="math inline">\frac{\pi}{2}-\theta</span> でも同一の到達距離 <span class="math inline">l</span> となることがわかる. すなわち, 2 つの到達の解があることとなる.</p>
<h3 id="放物運動のシミュレート">放物運動のシミュレート</h3>
ここまで示した内容で, 重力のみが考慮された簡単な物体の放物運動について<em onclick="obj=document.getElementById('openscsim').style; obj.display=(obj.display=='none')?'block':'none';"><a style="font-style: normal; cursor:pointer;">シミュレートできる(クリックで展開).</a></em>
<div id="openscsim" style="display:none;clear:both;width:100%;text-align:center;">
<canvas style="display: inline;" id="canvas" oncontextmenu="event.preventDefault()">
</canvas>
</div>
<script type="text/javascript">
var Module = {
    canvas: (function() { return document.getElementById('canvas'); })()
};
Module['locateFile'] = function(path, prefix) {
    return "/roki.log/2019/03/7/ParabolicMotion/" + path;
}
</script>
<script src="/roki.log/2019/03/7/ParabolicMotion/parabsbc.js"></script>
<p>C++ と SDL2 で書いたものを emscripten で Web Assembly にしているので, 恐らく古いブラウザでは動かないだろう. 操作感でわかると思うが, 初速の指定はボールとのユークリッド距離を元に決めている. このときのボールの回転角度は, arctan の定義そのものである.</p>
<p>一応全体のソースコードは, 次のリポジトリにて公開している.</p>
<div class="box is-shadowless has-text-centered">
<p><i class="fab fa-github mr-2"></i> <a href="https://github.com/falgon/sdl2_wasm_parabolic">falgon/sdl2_wasm_parabolic - For blog posts</a></p>
</div>]]></summary>
</entry>
<entry>
    <title>最小二乗法で始めるカーブフィッティング</title>
    <link href="https://roki.dev/roki.log/2019/01/3/least_squares/index.html" />
    <id>https://roki.dev/roki.log/2019/01/3/least_squares/index.html</id>
    <published>2019-01-03T00:00:00Z</published>
    <updated>2019-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="要旨">要旨</h2>
<p>本エントリー(WIP)はカーブフィッティング全般に関して記述したものであり, それぞれの原理, 性質について学んだ際のメモとして, より単純なものから広く浅く挙げています. 極力ないようにはしていますが, 本内容は独学で得た知見より書いておりますので, 一部正確さが欠けている可能性があることは否めません. 何かありましたら, コメント等で指摘していただけるとありがたいです. また, 本エントリ内における近似およびプロット等に関する実装は次のリポジトリ</p>
<div class="box has-text-centered is-shadowless">
<p><i class="fab fa-github mr-2"></i> <a href="https://github.com/falgon/PlayLinearAlgebra">falgon/PlayLinearAlgebra - My playground about linear albebra: LU decomposition, pseudo inverse, least squared method, etc…</a></p>
</div>
<p>にまとまっています.</p>
<!--more-->
<h2 id="線形回帰">線形回帰</h2>
<p>まずは, 回帰解析のうち最も基本的な手法である最小二乗法について. 次のような散布図<a href="/roki.log/2019/01/3/least_squares/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>を考える.</p>
<figure>
<img src="/roki.log/2019/01/3/least_squares/data.png" title="データセット" width="600" alt /><figcaption>データセット</figcaption>
</figure>
<p>このデータセットは, <a href="https://en.wikipedia.org/wiki/Mile_run">マイルラン</a>という中距離マラソンにおける男子世界記録の遷移を表しており, 横軸が世界記録を更新した年, 縦軸がその記録の秒数となっている. この散布図は負の相関関係があるといえる. まあ, 記録の更新というのは, ゴールするまでのタイムが縮んだということをいうので, これは当たり前の相関関係である.</p>
<p>このような直線的な関係があるようにみえるような散布について, それなりにそれらの点に相応しいような直線, つまり各点からの距離が最も小さくなるような直線を引きたいとしよう. これが本エントリにおける主題である.</p>
<h3 id="線形最小二乗法">線形最小二乗法</h3>
<p>最小二乗法は, 上記のようなデータの組 <span class="math inline">(x_i,y_i)</span> が <span class="math inline">n</span> 組与えられたとき(<span class="math inline">x_i</span> の全てが等しい場合を除いて)に, それらの点に相応しい関数 <span class="math display">y_i=a_i+a_ix^1_1+\cdots+a_ix^n_i\tag{i}</span> の係数(傾きと切片)を決定する方法である(定義式は <span class="math inline">(14)</span>). なお, このときの線形性とは, 係数 <span class="math inline">a_k</span> の線形性を意味しており, すなわち応答変数 <span class="math inline">y</span> は係数 <span class="math inline">a_k</span> の線形関数を表している. まずは最もシンプルな例として, 回帰モデルを <span class="math inline">y=ax+b</span> として考えると, これに対する線形最小二乗法は, 簡単に導出できる:</p>
<p>ある点 <span class="math inline">(x_i, y_i)</span> とモデルとなる直線の誤差, すなわち偏差は <span class="math inline">y_i-(ax_i+b)</span> とかける. このとき, 各点からの距離が最小であってほしいのだから, まず総和を <span class="math display">\epsilon(a,b):=\displaystyle\sum^{n}_{i=1}(y_i-ax_i-b)^2\tag{1}</span> とおくこととする. いまここで二乗したのは, モデルとなる直線よりも下に点があった場合, 符号が負となり, これが誤差を相殺してしまったり, 値を負にしてしまうからである. 絶対値を用いないのは, 後の微分計算を可能にするためである.</p>
<p>さて, いま <span class="math inline">(1)</span> の最小値を求めたいわけだが, 簡単のためにここでまず <span class="math inline">b</span> を固定したと考える. すると, <span class="math inline">(1)</span> は単なる <span class="math inline">a</span> の二次関数と捉えることができる. その係数 <span class="math inline">\displaystyle\sum^{n}_{i=1}x_i^2</span> は正であるので, この二次関数は, 下に凸の放物線を描くことがわかる. よってこの二次関数の最小値は, 接線の傾きを <span class="math inline">0</span> とした値をとることがいえるので, それを</p>
<p><span class="math display">\frac{\partial\epsilon(a,b)}{\partial a}=0</span></p>
<p>とかける. 同様に, <span class="math inline">a</span> を固定したと考えれば, 係数は <span class="math inline">n</span> でこれは正であるから, これも下に凸の放物線を描くことがわかる. つまりこの場合の最小値も,</p>
<p><span class="math display">\frac{\partial\epsilon(a,b)}{\partial b}=0</span></p>
<p>とかける. いま求めたかったのはこのどちらをも満たす <span class="math inline">a,b</span> であるので, これらの連立方程式を解けば良いこととなる. 従って <span class="math inline">(1)</span> より</p>
<p><span class="math display">
\begin{aligned}
&amp;&amp;\begin{cases}
&amp;\displaystyle\frac{\partial\epsilon(a,b)}{\partial a}&amp;=&amp;\displaystyle\sum_{i=1}^{n}2(y_i-(ax_i+b))\cdot(-x_i)&amp;=&amp;0 \\
&amp;\displaystyle\frac{\partial\epsilon(a,b)}{\partial b}&amp;=&amp;\displaystyle\sum_{i=1}^{n}2(y_i-(ax_i+b))&amp;=&amp;0
\end{cases}
\end{aligned}
</span></p>
<p>このような, 線形方程式におけるすべての定数項が <span class="math inline">0</span> であるものを同次線形系(英:homogeneous linear system)という. この両辺を <span class="math inline">2</span> で割って,</p>
<p><span class="math display">
\begin{aligned}
&amp;\leftrightarrow
&amp;\begin{cases}
&amp;\displaystyle\sum_{i=1}^{n}(y_i-(ax_i+b))\cdot x_i&amp;=&amp;0 \\
&amp;\displaystyle\sum_{i=1}^{n}(y_i-(ax_i+b))&amp;=&amp;0
\end{cases} \\
&amp;\leftrightarrow
&amp;\begin{cases}
&amp;\displaystyle a\sum_{i=1}^{n}x^2_i&amp;+&amp;\displaystyle b\sum_{i=1}^{n}x_i&amp;=&amp;\displaystyle\sum_{i=1}^{n}x_i y_i \\
&amp;\displaystyle a\sum_{i=1}^{n}x_i&amp;+&amp;bn&amp;=&amp;\displaystyle\sum_{i=1}^{n}y_i 
\end{cases}
\tag{2}
\end{aligned}
</span></p>
<p>両辺を <span class="math inline">n</span> で割って,</p>
<p><span class="math display">
\begin{aligned}
&amp;\leftrightarrow
&amp;\begin{cases}
&amp;\displaystyle a\frac{\sum_{i=1}^{n}x^2_i}{n}&amp;+&amp;\displaystyle b\frac{\sum_{i=1}^{n}x_i}{n}&amp;=&amp;\displaystyle\frac{\sum_{i=1}^{n}x_i y_i}{n} \\
&amp;\displaystyle a\frac{\sum_{i=1}^n x_i}{n}&amp;+&amp;b&amp;=&amp;\frac{\sum_{i=1}^ny_i}{n}
\end{cases}
\end{aligned}
</span> ここで, <span class="math inline">\frac{\sum_{i=1}^n x_i}{n}</span> は <span class="math inline">x</span> の総和をその個数で割っているので <span class="math inline">x</span> の平均, <span class="math inline">\frac{\sum_{i=1}^ny_i}{n}</span> は <span class="math inline">y</span> の総和をその個数で割っているので <span class="math inline">y</span> の平均であるから, <span class="math inline">\overline{x}=\frac{\sum_{i=1}^{n}x_i}{n}, \overline{y}=\frac{\sum_{i=1}^ny_i}{n}, \overline{x^2}=\frac{\sum_{i=1}^{n}x_i^2}{n}, \overline{xy}=\frac{\sum_{i=1}^{n}x_i y_i}{n}</span> と平均の記号を用いて書くことができる. よって, <span class="math inline">b=-a\overline{x}+\overline{y}</span> を代入すれば <span class="math inline">a</span> も求まるわけだが, 一旦これを行列で表現すると,</p>
<p><span class="math display">
\begin{aligned}
\left(\begin{array}{cc}
\overline{x^2} &amp; \overline{x} \\ \overline{x} &amp; 1
\end{array}\right)
\left(\begin{array}{c}
a \\ b
\end{array}\right)
&amp;=&amp;
\left(\begin{array}{c}
\overline{xy} \\
\overline{y}
\end{array}\right)
\end{aligned}
</span></p>
<p>左辺の行列の行列式</p>
<p><span class="math display">
\begin{aligned}
{\rm det}\left(\begin{array}{cc}
\overline{x^2} &amp; \overline{x} \\ \overline{x} &amp; 1
\end{array}\right)
\end{aligned}
</span></p>
<p>は, <span class="math inline">x_i</span> がすべて等しくない限り <span class="math inline">0</span> とはならない. いまはそのような場合を除いているから, 同行列は正則で</p>
<p><span class="math display">
\begin{aligned}
\left(\begin{array}{c}
a \\ b
\end{array}\right)
&amp;=&amp;\left(\begin{array}{cc}
\overline{x^2} &amp; \overline{x} \\ \overline{x} &amp; 1
\end{array}\right)^{-1}
\left(\begin{array}{c}
\overline{xy} \\
\overline{y}
\end{array}\right) 
\end{aligned}
</span></p>
<p>より <span class="math inline">(a\ b)^T</span> は</p>
<p><span class="math display">
\begin{aligned}
&amp;=&amp;\left(\begin{array}{c}
\frac{\overline{xy}-\overline{x}\cdot\overline{y}}{\overline{x^2}-\overline{x}^2} \\
\frac{\overline{x^2}\cdot\overline{y}-\overline{xy}\cdot\overline{x}}{\overline{x^2}-\overline{x}^2}
\end{array}\right)\tag{3}
\end{aligned}
</span></p>
<p>と求まる. ここで, <span class="math inline">\overline{xy}-\overline{x}\cdot\overline{y}</span> は共分散, <span class="math inline">\overline{x^2}-\overline{x}^2</span> は分散の形になっているので, <span class="math inline">a</span> は <span class="math inline">\frac{\mathrm{Cov}(x,y)}{\sigma_x^2}</span> とまとめることができ, よくみる最小二乗法の定義式の形となった. 実際にプログラムにすることを考えるときは, 平均などはどうでもよくて, 単に <span class="math inline">(3)</span> の各項に <span class="math inline">n</span> を乗じた形で計算すればよい. つまり,</p>
<p><span class="math display">
\begin{aligned}
(2)&amp;\leftrightarrow&amp;
\left(\begin{array}{cc}
\displaystyle \sum_{i=1}^{n}x^2_i &amp;\displaystyle \sum_{i=1}^{n}x_i \\
\displaystyle \sum_{i=1}^{n}x_i &amp;n
\end{array}\right)
\left(\begin{array}{c}
a \\ b
\end{array}\right)&amp;=&amp;
\left(\begin{array}{c}
\displaystyle\sum_{i=1}^{n}x_i y_i \\ \displaystyle\sum_{i=1}^{n}y_i 
\end{array}\right)
\\ 
&amp;\leftrightarrow&amp;
\left(\begin{array}{c}
a \\ b
\end{array}\right)&amp;=&amp;
\left(\begin{array}{cc}
\displaystyle \sum_{i=1}^{n}x^2_i &amp;\displaystyle \sum_{i=1}^{n}x_i \\
\displaystyle \sum_{i=1}^{n}x_i &amp;n
\end{array}\right)^{-1}
\left(\begin{array}{c}
\displaystyle\sum_{i=1}^{n}x_i y_i \\ \displaystyle\sum_{i=1}^{n}y_i 
\end{array}\right) \\
&amp;&amp;&amp;=&amp;\left(\begin{array}{c}
\frac{(\sum^n_{i=1}x_iy_i) n-(\sum^n_{i=1}x_i)(\sum^n_{i=1}y_i)}{(\sum^n_{i=1}x^2_i) n-(\sum^n_{i=1}x_i)^2} \\
\frac{(\sum^n_{i=1}x^2_i)(\sum^n_{i=1}y_i)-(\sum^n_{i=1}x_iy_i)(\sum^n_{i=1}x_i)}{(\sum^n_{i=1}x^2_i) n-(\sum^n_{i=1}x_i)^2}
\end{array}\right)
\end{aligned}
</span></p>
<p>である. これを用いて, 次のように近似できる.</p>
<figure>
<img src="/roki.log/2019/01/3/least_squares/lenarEquations.png" title="lenear equations" width="600" alt /><figcaption>lenear equations</figcaption>
</figure>
<p>というのが, 最も素朴な最小二乗法の例である<a href="/roki.log/2019/01/3/least_squares/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. より一般に, <span class="math inline">y</span> が <span class="math inline">m</span> 次の多項式 <span class="math inline">\displaystyle f(x)=b+\sum_{j=1}^{m}a_j x^{j}</span> として表されるような場合についても, 同様にしていうことができる. この場合, 偏差の二乗和は,</p>
<p><span class="math display">\displaystyle\epsilon=\sum^{n}_{i=1}(y_i-b-\sum_{j=1}^{m}a_j x^{j})^2\tag{4}</span></p>
<p>先と同様, 各変数ごとの偏微分が <span class="math inline">0</span> となる連立方程式を解けば良いから,</p>
<p><span class="math display">
\begin{aligned}
\begin{cases}
&amp;\displaystyle\frac{\partial\epsilon}{\partial b}&amp;=&amp;\displaystyle-\sum_{i=1}^{n}2(y_i-b-\sum_{j=1}^{m}a_j x^{j})&amp;=&amp;0 \\
&amp;\displaystyle\frac{\partial\epsilon}{\partial a_1}&amp;=&amp;\displaystyle-\sum_{i=1}^{n}2x_i(y_i-b-\sum_{j=1}^{m}a_j x^{j})&amp;=&amp;0 \\
&amp;&amp;&amp;\vdots&amp; \\
&amp;\displaystyle\frac{\partial\epsilon}{\partial a_m}&amp;=&amp;\displaystyle-\sum_{i=1}^{n}2x^m_i(y_i-b-\sum_{j=1}^{m}a_j x^{j})&amp;=&amp;0 
\end{cases}
\end{aligned}
</span></p>
<p>先の例に合わせて, 両辺を <span class="math inline">2n</span> で割った行列とすると, 平均の記号を用いて</p>
<p><span class="math display">
\begin{aligned}
\left(\begin{array}{cccc}
1 &amp; \overline{x} &amp; \cdots &amp; \overline{x^m} \\
\overline{x} &amp; \overline{x^2} &amp; \cdots &amp; \overline{x^{m+1}} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\overline{x^m} &amp; \overline{x^{m+1}} &amp; \cdots &amp; \overline{x^{2m}}
\end{array}\right)
\left(\begin{array}{c}
b \\ a_1 \\ \vdots \\ a_m
\end{array}\right)=
\left(\begin{array}{c}
\overline{y} \\
\overline{xy} \\
\vdots \\
\overline{x^my}
\end{array}\right)
\end{aligned}
</span></p>
<p>なので,</p>
<p><span class="math display">
\begin{aligned}
\left(\begin{array}{c}
b \\ a_1 \\ \vdots \\ a_m
\end{array}\right)&amp;=&amp;
\left(\begin{array}{cccc}
1 &amp; \overline{x} &amp; \cdots &amp; \overline{x^m} \\
\overline{x} &amp; \overline{x^2} &amp; \cdots &amp; \overline{x^{m+1}} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\overline{x^m} &amp; \overline{x^{m+1}} &amp; \cdots &amp; \overline{x^{2m}}
\end{array}\right)^{-1}
\left(\begin{array}{c}
\overline{y} \\
\overline{xy} \\
\vdots \\
\overline{x^my}
\end{array}\right) \\
&amp;=&amp;\left(\begin{array}{cccc}
n &amp; \displaystyle\sum^{n}_{i=1}x_i &amp; \cdots &amp; \displaystyle\sum^{n}_{i=1}x^m_i \\
\displaystyle\sum^{n}_{i=1}x_i &amp; \displaystyle\sum^{n}_{i=1}x_i^2 &amp; \cdots &amp; \displaystyle\sum^{n}_{i=1}x_i^{m+1} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\displaystyle\sum^{n}_{i=1}x_i^m &amp; \displaystyle\sum^{n}_{i=1}x_i^{m+1} &amp; \cdots &amp; \displaystyle\sum^{n}_{i=1}x_i^{2m}
\end{array}\right)^{-1}
\left(\begin{array}{c}
\displaystyle\sum^n_{i=1}y_i \\ \displaystyle\sum^n_{i=1}x_iy_i \\ \vdots \\ \displaystyle\sum^n_{i=1}x_i^my_i
\end{array}\right)
\end{aligned}
</span></p>
<p>で求まる. この正確な解を機械的に求める場合には, この逆行列を求めなくとも, ガウスの消去法などを基本とした解法(直接解法)で解ける.</p>
<p>先のデータは直線的であったので, 今度は曲線が引けそうなデータセットとして, <span class="math inline">x_i=i-1, y_i=\sin(x_i)+\epsilon, i=1,2,\cdots,11</span> に対し, フィッティングを試行してみる事とする. ここで <span class="math inline">\epsilon</span> は <span class="math inline">\mathrm{N}(0, 0.2)</span> の正規分布に従う確率変数である. 次のアニメーションでは, 次数 <span class="math inline">1\leq m\leq 9</span> に応じた近似の遷移を観察できる(LU 分解による計算 <span class="math inline">\to</span> <a href="/roki.log/2019/01/1/LUDecomposition/">解説</a>).</p>
<figure>
<img src="/roki.log/2019/01/3/least_squares/out.gif" title="lenear equations" width="600" alt /><figcaption>lenear equations</figcaption>
</figure>
<p>ところで, 冒頭で示した関数 <span class="math inline">(i)</span> の線形回帰モデルは, 次のように表すことができる.</p>
<p><span class="math display">y_i=a_0+\sum^m_{j=1}a_jf_j(x_i^1,x_i^2,\cdots,x_i^n)+u_i,\ i=1,\cdots,m\tag{ii}</span></p>
<p>ここで, <span class="math inline">f_j</span> は独立変数 <span class="math inline">x_{i}^k</span> のスカラー関数, <span class="math inline">u_i</span> は <span class="math inline">i</span> 番目のノイズ項(確率変数)である. 線形最小二乗法は, 単にすべてのデータ値に対する偏差の二乗和を最小化する. すなわち, データに関わらず全ての値が同じように扱われる. これは, すべてのノイズ項 <span class="math inline">u_i</span> の確率分布が同一であると仮定することと同値であり, 従って, すべての <span class="math inline">u_i</span> は無相関かつ <a href="/roki.log/2018/10/28/probabilityTerms/#iid">i.i.d</a> で <span class="math inline">\mathrm{N}(0,\sigma^2)</span> (標準正規分布) に従うことを前提としているといえる<a href="/roki.log/2019/01/3/least_squares/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<h2 id="一般逆行列">一般逆行列</h2>
<p>ここまでは, 回帰直線の考え方に沿って近似曲線/直線を得た訳であるが, そもそも, <span class="math inline">(x_i,y_i)</span> の組があって線形方程式 <span class="math inline">y</span> の <span class="math inline">x</span> に関する関数における“適当な”係数が“直接”求まるような行列があれば良いのではないだろうか. つまり <span class="math inline">m</span> を方程式の個数, <span class="math inline">n'=n+1</span> を未知数の個数とし, <span class="math inline">X{\boldsymbol a}={\boldsymbol y}\ \ {\rm where}\ X\in\mathbb{R}^{m\times n'}, {\boldsymbol a}\in\mathbb{R}^{n'\times 1}, {\boldsymbol y}\in\mathbb{R}^{m\times 1}</span><a href="/roki.log/2019/01/3/least_squares/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> としたとき</p>
<p><span class="math display">
\begin{aligned}
\left(\begin{array}{c}
y_1 \\
y_2 \\
\vdots \\
y_m
\end{array}\right)=
\left(\begin{array}{cccc}
x_1^0 &amp; x_1^1 &amp; \cdots &amp; x_1^n \\
x_2^0 &amp; x_2^1 &amp; \cdots &amp; x_2^n \\
\vdots  &amp; \vdots &amp; \ddots &amp; \vdots \\
x_m^0 &amp; x_m^1 &amp;\cdots &amp; x_m^n
\end{array}\right)
\left(\begin{array}{c}
a_0 \\
a_1 \\
\vdots \\
a_n
\end{array}\right) \\
\left(\begin{array}{cccc}
x_1^0 &amp; x_1^1 &amp; \cdots &amp; x_1^n \\
x_2^0 &amp; x_2^1 &amp; \cdots &amp; x_2^n \\
\vdots  &amp; \vdots &amp; \ddots &amp; \vdots \\
x_m^0 &amp; x_m^1 &amp;\cdots &amp; x_m^n
\end{array}\right)^{-1}
\left(\begin{array}{c}
y_1 \\
y_2 \\
\vdots \\
y_m
\end{array}\right)
=
\left(\begin{array}{c}
a_0 \\
a_1 \\
\vdots \\
a_n
\end{array}\right)\tag{5}
\end{aligned}
</span></p>
<p>を解いて, それが求まれば良いのではないか, ということである(<span class="math inline">n+1</span> と <span class="math inline">m</span> は必ずしも等しくないことに注意<a href="/roki.log/2019/01/3/least_squares/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>). このときに考えられるパターンは, 次のとおりである:</p>
<ol type="1">
<li><span class="math inline">n'=m</span> かつそのランク <span class="math inline">{\rm rank}(X)</span> が <span class="math inline">n'=m</span>(フルランク)ならば, <span class="math inline">X</span> は正則である. 従って, <span class="math inline">X^{-1}X{\boldsymbol a}=X^{-1}{\boldsymbol y}</span> として解が求まる.</li>
<li><span class="math inline">n'\lt m</span> かつそのランクが <span class="math inline">n'</span>(列フルランク)ならば, すべての方程式を満たすような解が存在しないことがいえる. これは, すべての方程式をそれぞれ直線と捉えたときに, それらすべての交点となる一点が存在しないことをイメージするとわかりやすい. 要するに, <span class="math inline">{\boldsymbol a}</span> に対する <span class="math inline">X</span> と <span class="math inline">{\boldsymbol y}</span> の制約が相互的に成立しないのである. ここで <span class="math inline">{\rm rank}(X)\lt n'</span>(ランク落ち)ならば, 方程式のどこかに重複がある.</li>
<li><span class="math inline">m\lt n'</span> かつそのランクが <span class="math inline">m</span>(行フルランク)ならば, 解が一意とならないことがいえる. これも, 方程式を直線に捉えると, <span class="math inline">{\boldsymbol a}</span> に対する制約が足りないことで, 方程式で構成される直線上のすべてが解となりうることから納得できる. ここで <span class="math inline">{\rm rank}(X)\lt m</span>(ランク落ち)ならば, 方程式のどこかに重複がある.</li>
</ol>
<p>いま 2 つの重複がある場合を考えることができたが, 重複を除けば, いま述べたうちのどれかに帰着させることができる. 重複の場合を直線で捉えると, それぞれの方程式が <span class="math inline">x, y</span> の関係に関して全く異なる解を示しているということなので, それぞれの直線は平行の関係にあることとなる.</p>
<p>まとめると, つまり <span class="math inline">X{\boldsymbol a}={\boldsymbol y}</span> というように表される線形方程式には, 以上の 3 つのパターン(重複について考えれば 4 パターン)があることがわかる. これらのすべてのパターンに対して“適当であるような”解を与える逆行列を考えれば, どのような方程式にも“適当であるような”解を与えることができる. このように, 正則でない行列に対する擬似的な逆行列の定義を一般逆行列という.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="GeneralizedInverse">一般逆行列</span>
</p>
</header>
<div class="m-def-content">
次の式を満たす行列 <span class="math inline">X^-\in\mathbb{R}^{m\times n'}</span> を一般逆行列といい, <span class="math inline">X</span> が特異行列ならば <span class="math inline">X^-</span> は一意ではないが常に存在する. <span class="math display">X X^-X = X</span>
</div>
</div>
<p>“適当であるような”解は様々に考えられるように, 一般逆行列の定義も様々である. 以下やや天下り的ではあるが便宜上の理由より示してしまうと, いくらかの一般逆行列は次で定めるムーア・ベンローズ一般逆行列(以下 MP 逆行列)に従っており, 暗に一般逆行列と言ってこの MP 逆行列のことを示すような場合が巷ではある<a href="/roki.log/2019/01/3/least_squares/#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="MPPseudoInverse">Moore-Penrose 一般逆行列</span>
</p>
</header>
<div class="m-def-content">
次のすべての条件を満たす<a href="/roki.log/2019/01/3/least_squares/#GeneralizedInverse">一般逆行列</a> <span class="math inline">X^{\dagger}</span> は Moore-Penrose 一般逆行列(MP 逆行列)といい, その存在は一意<a href="/roki.log/2019/01/3/least_squares/#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>である. <span class="math display">X X^\dagger X=X\tag{6}</span> <span class="math display">X^{\dagger}X X^{\dagger}=X^{\dagger}\tag{7}</span> <span class="math display">(X^{\dagger}X)^T=X^{\dagger}X\tag{8}</span> <span class="math display">(X X^{\dagger})^T=X X^{\dagger}\tag{9}</span>
</div>
</div>
<h3 id="最小二乗形一般逆行列">最小二乗形一般逆行列</h3>
<p>まず, ケース 2 の場合について考える. これは, 最小二乗形一般逆行列といわれる一般逆行列を用いる. これが定める“適当であるような”解とは, その名の通り, すべての方程式の二乗誤差が最小である値であり, まさしく上で述べた最小二乗法の値である.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="LeastSquaresGeneralizedInverse">最小二乗形一般逆行列</span>
</p>
</header>
<div class="m-def-content">
正規方程式 <span class="math display">{\boldsymbol a}=X^-{\boldsymbol y}</span> の解 <span class="math inline">{\boldsymbol a}</span> を二乗誤差最小の値で定める <a href="/roki.log/2019/01/3/least_squares/#GeneralizedInverse">一般逆行列</a> <span class="math display">^\exists X^-\in\mathbb{R}^{m\times n'}\ {\rm s.t.}\ m\gt n'\land(X X^-)^T = X X^-</span> は <span class="math inline">X</span> の最小二乗形一般逆行列である.
</div>
</div>
<p>以下, 最小二乗形一般逆行列の定式を求めるが, 上で既に述べた内容と本質的には全く変わらない. ここで, 少し扱いやすくするために, <span class="math inline">n</span> 次多項式を <span class="math inline">f_n(x)=a_0x^0_i+a_1x^1_i+\cdots+a_nx^n_i=\sum^{n}_{j=0}a_jx^j_i</span>, <span class="math inline">(5)</span> の <span class="math inline">x_i^j</span> についての行列を <span class="math inline">X</span> とする. そしてその <span class="math inline">i</span> 行目を 1 つの縦ベクトルとしたものを <span class="math inline">{\boldsymbol x_i}</span> (<span class="math inline">{\rm e.g.}\ \ {\boldsymbol x_1}=(x_1^0, x_1^1, \cdots, x_1^n )^T</span>) とし, <span class="math inline">(4)</span> の式を</p>
<p><span class="math display">\epsilon=\sum_{i=1}^{m}(y_i-f_n({\boldsymbol x_i}))^2\tag{10}</span></p>
<p>というように表す(これは <span class="math inline">(4)</span> と全く同じことを書いただけである)とする. <span class="math inline">f({\boldsymbol x_i})={\boldsymbol x_i}^T{\boldsymbol a}</span> だから</p>
<p><span class="math display">=\sum_{i=1}^{m}(y_i-{\boldsymbol x_i}^T{\boldsymbol a})^2</span></p>
<p><span class="math inline">({\boldsymbol x_1}^T,{\boldsymbol x_2}^T,\cdots,{\boldsymbol x_m}^T)^T=X</span> なので</p>
<p><span class="math display">=({\boldsymbol y}-X{\boldsymbol a})^T({\boldsymbol y}-X{\boldsymbol a})</span></p>
<p>ここで, 先にやった, 偏微分を考えることで下に凸な二次関数となることを利用し, その値を <span class="math inline">0</span> とした上でそれらすべての連立方程式を求め, 最小値を得たことを思いだし, この式を <span class="math inline">{\boldsymbol a}</span> で微分する(すべての <span class="math inline">{\boldsymbol a_i}</span> で偏微分する, すなわち勾配を求める)と</p>
<p><span class="math display">\nabla\epsilon({\boldsymbol a})=2X^T X{\boldsymbol a}-2X^T{\boldsymbol y}=-2X^T({\boldsymbol y}-X{\boldsymbol a})</span></p>
<p><span class="math inline">\nabla\epsilon({\boldsymbol a})=0</span> とおくと,</p>
<p><span class="math display">X^T X{\boldsymbol a}=X^T{\boldsymbol y}</span></p>
<p>と正規方程式が求まった. ここで, <span class="math inline">n'=m-1</span> のとき <span class="math inline">X</span> はヴァンデルモンド行列<a href="/roki.log/2019/01/3/least_squares/#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>となり, <span class="math inline">{\boldsymbol x_1}, \cdots, {\boldsymbol x_m}</span> が相異なるとき <span class="math inline">X</span> は正則となる. 従って, 正規方程式の解は</p>
<p><span class="math display">{\boldsymbol a}=(X^T X)^{-1}X^T {\boldsymbol y}={X}^{-1}{\boldsymbol y}</span></p>
<p>とかける. <span class="math inline">n'\lt m-1</span> ならば行列 <span class="math inline">X^T X</span> が正則なので, 正規方程式の解は</p>
<p><span class="math display">{\boldsymbol a}=(X^T X)^{-1}X^T{\boldsymbol y}\tag{11}</span></p>
<p>とかける. このとき <span class="math inline">m\lt n</span> ならば, <span class="math inline">X^T X</span> が非正則となってしまうから, 最小二乗形一般逆行列は構成できない. この結果から, 時間計算量は多項式時間 <span class="math inline">\mathrm{O}(n^3)</span> であることがわかる. また, 最小二乗形一般逆行列は, <a href="/roki.log/2019/01/3/least_squares/#MPPseudoInverse">MP 逆行列</a>であることが導出できる<a href="/roki.log/2019/01/3/least_squares/#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
<h3 id="最小ノルム形一般逆行列">最小ノルム形一般逆行列</h3>
<p>次に, ケース 3 の場合を考える. この場合, 最小ノルム形一般逆行列を用いる. ケース 3 は様々な値が解になりうるということであったが, 最小ノルム形一般逆行列は, いまそれを <span class="math inline">X^-</span> としたとき, <span class="math inline">{\boldsymbol a}=X^-{\boldsymbol y}</span> の解 <span class="math inline">{\boldsymbol a}</span> を その <span class="math inline">L^2</span> ノルム <span class="math inline">\mid\mid {\boldsymbol a}\mid\mid_2</span> が最小となるように定める.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="MinimumNormGeneralizedInverse">最小ノルム形一般逆行列</span>
</p>
</header>
<div class="m-def-content">
正規方程式 <span class="math display">{\boldsymbol a}=X^-{\boldsymbol y}</span> の解 <span class="math inline">{\boldsymbol a}</span> をその <span class="math inline">L^2</span> ノルム <span class="math inline">\mid\mid {\boldsymbol a}\mid\mid_2</span> が最小となる値で定める<a href="/roki.log/2019/01/3/least_squares/#GeneralizedInverse">一般逆行列</a> <span class="math display">^\exists X^-\in\mathbb{R}^{m\times n'}\ {\rm s.t.}\ m\lt n'\land(X^- X)^T = X^- X</span> は <span class="math inline">X</span> の最小ノルム形一般逆行列である.
</div>
</div>
<p>つまり, 解くべきは次に示す制約付き最適化問題/条件付き極小値問題である.</p>
<p><span class="math display">\min_{{\boldsymbol a}}\mid\mid{\boldsymbol a}\mid\mid^2_2\ {\rm s.t.}\ {\boldsymbol y}=X{\boldsymbol a}</span></p>
<p>条件付き極値の問題はラグランジュの未定乗数法で解ける. この証明は中々大変なので, 本エントリでは公理として認めた上で用いることとする(TODO). 従って, ラグランジアンを次のように定義する.</p>
<p><span class="math display">\mathcal{L}({\boldsymbol a}, {\boldsymbol \lambda}):=\mid\mid{\boldsymbol a}\mid\mid^2_2+{\boldsymbol \lambda}^T({\boldsymbol y}-X{\boldsymbol a})</span></p>
<p>ラグランジュの未定乗数法に従い, それぞれの偏導関数から求めて</p>
<p><span class="math display">
\begin{aligned}
\begin{cases}
\frac{\partial}{\partial{\boldsymbol a}}\mathcal{L}({\boldsymbol a})&amp;=&amp;2{\boldsymbol a}-X^T{\boldsymbol \lambda}&amp;=&amp;0 \\
\frac{\partial}{\partial{\boldsymbol \lambda}}\mathcal{L}({\boldsymbol a})&amp;=&amp;{\boldsymbol y}-X{\boldsymbol a}&amp;=&amp;0
\end{cases}
\end{aligned}
</span></p>
<p>よって</p>
<p><span class="math display">
\begin{aligned}
\begin{cases}
{\boldsymbol a}&amp;=&amp;\frac{1}{2}X^T\lambda \\
{\boldsymbol y}&amp;=&amp;X{\boldsymbol a}
\end{cases}\leftrightarrow{\boldsymbol y}=\frac{1}{2}X X^T\lambda
\end{aligned}
</span></p>
<p><span class="math inline">m\lt n'</span> ならば <span class="math inline">X X^T</span> は正則なので</p>
<p><span class="math display">\lambda=2(X X^T)^{-1}{\boldsymbol y}\leftrightarrow {\boldsymbol a}=X^T(X X^T)^{-1}{\boldsymbol y}</span></p>
<p><span class="math inline">X{\boldsymbol a}=X\left\{X^T(X X^T)^{-1}{\boldsymbol y}\right\}=(X X^T)(X X^T)^{-1}{\boldsymbol y}={\boldsymbol y}</span> よりこの正規方程式の解が一般逆行列として成立していることが確認できる.</p>
<h3 id="制限つき最小二乗法">制限つき最小二乗法</h3>
<p>最後に, 重複がある(ランク落ちである)ケースを考える. この場合は, <span class="math inline">X^T X, X X^T</span> がともに特異行列となってしまうため, 対象の行列に対してまず特異値分解(以下 SVD)を行う.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="SVG">特異値分解</span>
</p>
</header>
<div class="m-def-content">
<p><span class="math inline">^\forall X\in\mathbb{R}^{m\times n'}</span> に対して <span class="math display">
^\exists U\in\mathbb{R}^{m\times m}, ^\exists V\in\mathbb{R}^{n'\times n'},
^\exists \Sigma\in\mathbb{R}^{n'\times m}\ {\rm s.t.}\ 
X = U\Sigma V^T \\ {\rm where}\ \Sigma=\left(\begin{array}{ccccc}\lambda_1&amp;\cdots&amp;0 \\ \vdots&amp;\ddots&amp;\vdots \\ 0&amp;\cdots&amp;\lambda_{r} \\ &amp;&amp;&amp;0 \\ &amp;&amp;&amp;&amp;0 \end{array}\right), \lambda_1\geq\cdots\geq\lambda_{r}\geq 0,r=\mathrm{rank}(X)=\min(m,n')
</span> このとき <span class="math inline">U\Sigma V^T</span> を <span class="math inline">X</span> の特異値分解 (英: Singular value decomposition) という.</p>
</div>
</div>
<p>これは</p>
<p><span class="math display">
\begin{aligned}
\displaystyle\sum^{r}_{i=1}\lambda_i{\boldsymbol u_i}{\boldsymbol v_i}^T\ {\rm where}
\ \begin{array}{cc}
({\boldsymbol u_1},\cdots,{\boldsymbol u_m})^T
&amp;=&amp;\left(\begin{array}{ccc}
u_{11}&amp;\cdots&amp;u_{1m} \\
\vdots&amp;\ddots&amp;\vdots\\ 
u_{m1}&amp;\cdots&amp;u_{mm}
\end{array}\right)&amp;=&amp;U \\
({\boldsymbol v_1},\cdots,{\boldsymbol v_{n'}})^T
&amp;=&amp;\left(\begin{array}{ccc}
v_{11}&amp;\cdots&amp;v_{1n'} \\
\vdots&amp;\ddots&amp;\vdots\\
v_{n'1}&amp;\cdots&amp;v_{n'n'}
\end{array}\right)&amp;=&amp;V
\end{array}
\end{aligned}
</span></p>
<p>と同値であり, 一般に <span class="math inline">\lambda_i</span> を特異値, <span class="math inline">{\boldsymbol u_i}</span> を左特異ベクトル <span class="math inline">{\boldsymbol v_i}</span> を右特異ベクトルという.</p>
<p><strong>TODO: 詳解を追記</strong></p>
<h3 id="オーバーフィッティングと正則化およびその評価">オーバーフィッティングと正則化およびその評価</h3>
<p>先に, 次数に応じた近似の遷移が観察できるアニメーションを示したが, あまり次数を大きくすると, データ点の間で誤差が大きくなってしまうことがある. これをオーバーフィッティングという. 先と同様, <span class="math inline">x_i=i-1, y_i=\sin(x_i)+\epsilon, i=1,2,\cdots,11</span> に対する各次元での係数を見てみると(<span class="math inline">(5)</span> では, 係数のベクトルを <span class="math inline">(a_0,a_1,\cdots,a_n)^T</span> と並べているが, 下記は <span class="math inline">(a_n,a_{n-1},\cdots,a_0)^T</span> の順である),</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="/roki.log/2019/01/3/least_squares/#cb1-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span>m <span class="op">+</span><span class="dt">Data.Tuple.Extra</span> <span class="dt">Data.Maybe</span> <span class="dt">System.Random</span> <span class="dt">Random.Normal</span> <span class="dt">Control.Monad</span> <span class="dt">ML.Approx.OLS.ByPinv</span> <span class="dt">Utils</span></span>
<span id="cb1-2"><a href="/roki.log/2019/01/3/least_squares/#cb1-2" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> uni <span class="ot">=</span> normalIO' (<span class="dv">0</span>, <span class="fl">0.2</span>)</span>
<span id="cb1-3"><a href="/roki.log/2019/01/3/least_squares/#cb1-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> d <span class="ot">=</span> <span class="fu">zipWith</span> (\x y <span class="ot">-&gt;</span> (x, <span class="fu">sin</span> x<span class="op">+</span>y)) [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">&lt;$&gt;</span> replicateM <span class="dv">11</span> uni</span>
<span id="cb1-4"><a href="/roki.log/2019/01/3/least_squares/#cb1-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> dd <span class="ot">&lt;-</span> d</span>
<span id="cb1-5"><a href="/roki.log/2019/01/3/least_squares/#cb1-5" aria-hidden="true"></a>λ<span class="op">&gt;</span> dd</span>
<span id="cb1-6"><a href="/roki.log/2019/01/3/least_squares/#cb1-6" aria-hidden="true"></a>[(<span class="fl">0.0</span>,<span class="op">-</span><span class="fl">5.563765361160251e-4</span>),(<span class="fl">1.0</span>,<span class="fl">0.9418472638241775</span>),(<span class="fl">2.0</span>,<span class="fl">1.1378051539092622</span>),(<span class="fl">3.0</span>,<span class="fl">0.30341406458452413</span>),(<span class="fl">4.0</span>,<span class="op">-</span><span class="fl">0.8411970236084821</span>),(<span class="fl">5.0</span>,<span class="op">-</span><span class="fl">0.8558604338359868</span>),(<span class="fl">6.0</span>,<span class="op">-</span><span class="fl">0.2586281201459223</span>),(<span class="fl">7.0</span>,<span class="fl">0.8031257237891795</span>),(<span class="fl">8.0</span>,<span class="fl">1.1562504257723663</span>),(<span class="fl">9.0</span>,<span class="fl">0.39633872602316167</span>),(<span class="fl">10.0</span>,<span class="op">-</span><span class="fl">0.8085898217611907</span>)]</span>
<span id="cb1-7"><a href="/roki.log/2019/01/3/least_squares/#cb1-7" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> outCoes i <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">maybe</span> <span class="st">&quot;failed&quot;</span> (((<span class="op">++</span>) <span class="op">$</span> <span class="fu">show</span> i <span class="op">++</span> <span class="st">&quot; -----\n&quot;</span>) <span class="op">.</span> <span class="fu">foldr1</span> (<span class="op">++</span>) <span class="op">.</span> (<span class="fu">map</span> ((<span class="op">++</span> <span class="st">&quot;\n&quot;</span>) <span class="op">.</span> <span class="fu">show</span>))) <span class="op">$</span> resolve i dd</span>
<span id="cb1-8"><a href="/roki.log/2019/01/3/least_squares/#cb1-8" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">mapM_</span> outCoes [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb1-9"><a href="/roki.log/2019/01/3/least_squares/#cb1-9" aria-hidden="true"></a><span class="dv">1</span> <span class="co">-----</span></span>
<span id="cb1-10"><a href="/roki.log/2019/01/3/least_squares/#cb1-10" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">4.168066672607503e-2</span>]</span>
<span id="cb1-11"><a href="/roki.log/2019/01/3/least_squares/#cb1-11" aria-hidden="true"></a>[<span class="fl">0.38785329563173637</span>]</span>
<span id="cb1-12"><a href="/roki.log/2019/01/3/least_squares/#cb1-12" aria-hidden="true"></a></span>
<span id="cb1-13"><a href="/roki.log/2019/01/3/least_squares/#cb1-13" aria-hidden="true"></a><span class="dv">2</span> <span class="co">-----</span></span>
<span id="cb1-14"><a href="/roki.log/2019/01/3/least_squares/#cb1-14" aria-hidden="true"></a>[<span class="fl">6.311957210780993e-3</span>]</span>
<span id="cb1-15"><a href="/roki.log/2019/01/3/least_squares/#cb1-15" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">0.10480023883388496</span>]</span>
<span id="cb1-16"><a href="/roki.log/2019/01/3/least_squares/#cb1-16" aria-hidden="true"></a>[<span class="fl">0.4825326537934513</span>]</span>
<span id="cb1-17"><a href="/roki.log/2019/01/3/least_squares/#cb1-17" aria-hidden="true"></a></span>
<span id="cb1-18"><a href="/roki.log/2019/01/3/least_squares/#cb1-18" aria-hidden="true"></a>(略)</span>
<span id="cb1-19"><a href="/roki.log/2019/01/3/least_squares/#cb1-19" aria-hidden="true"></a></span>
<span id="cb1-20"><a href="/roki.log/2019/01/3/least_squares/#cb1-20" aria-hidden="true"></a><span class="dv">9</span> <span class="co">-----</span></span>
<span id="cb1-21"><a href="/roki.log/2019/01/3/least_squares/#cb1-21" aria-hidden="true"></a>[<span class="fl">6.2497127164502315e-6</span>]</span>
<span id="cb1-22"><a href="/roki.log/2019/01/3/least_squares/#cb1-22" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">2.783924911591259e-4</span>]</span>
<span id="cb1-23"><a href="/roki.log/2019/01/3/least_squares/#cb1-23" aria-hidden="true"></a>[<span class="fl">5.143290075166487e-3</span>]</span>
<span id="cb1-24"><a href="/roki.log/2019/01/3/least_squares/#cb1-24" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">5.026523522855991e-2</span>]</span>
<span id="cb1-25"><a href="/roki.log/2019/01/3/least_squares/#cb1-25" aria-hidden="true"></a>[<span class="fl">0.2724261548894942</span>]</span>
<span id="cb1-26"><a href="/roki.log/2019/01/3/least_squares/#cb1-26" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">0.7770268952402895</span>]</span>
<span id="cb1-27"><a href="/roki.log/2019/01/3/least_squares/#cb1-27" aria-hidden="true"></a>[<span class="fl">1.0147233691594897</span>]</span>
<span id="cb1-28"><a href="/roki.log/2019/01/3/least_squares/#cb1-28" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">0.7860963186273294</span>]</span>
<span id="cb1-29"><a href="/roki.log/2019/01/3/least_squares/#cb1-29" aria-hidden="true"></a>[<span class="fl">1.2602569068891822</span>]</span>
<span id="cb1-30"><a href="/roki.log/2019/01/3/least_squares/#cb1-30" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">2.3687551597216985e-4</span>]</span>
<span id="cb1-31"><a href="/roki.log/2019/01/3/least_squares/#cb1-31" aria-hidden="true"></a></span>
<span id="cb1-32"><a href="/roki.log/2019/01/3/least_squares/#cb1-32" aria-hidden="true"></a><span class="dv">10</span> <span class="co">-----</span></span>
<span id="cb1-33"><a href="/roki.log/2019/01/3/least_squares/#cb1-33" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">1.626701126479776e-5</span>]</span>
<span id="cb1-34"><a href="/roki.log/2019/01/3/least_squares/#cb1-34" aria-hidden="true"></a>[<span class="fl">8.196002759563384e-4</span>]</span>
<span id="cb1-35"><a href="/roki.log/2019/01/3/least_squares/#cb1-35" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">1.7705498506683254e-2</span>]</span>
<span id="cb1-36"><a href="/roki.log/2019/01/3/least_squares/#cb1-36" aria-hidden="true"></a>[<span class="fl">0.21421719275219878</span>]</span>
<span id="cb1-37"><a href="/roki.log/2019/01/3/least_squares/#cb1-37" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">1.5895590768542918</span>]</span>
<span id="cb1-38"><a href="/roki.log/2019/01/3/least_squares/#cb1-38" aria-hidden="true"></a>[<span class="fl">7.43609912277545</span>]</span>
<span id="cb1-39"><a href="/roki.log/2019/01/3/least_squares/#cb1-39" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">21.670288785218535</span>]</span>
<span id="cb1-40"><a href="/roki.log/2019/01/3/least_squares/#cb1-40" aria-hidden="true"></a>[<span class="fl">37.428871273332284</span>]</span>
<span id="cb1-41"><a href="/roki.log/2019/01/3/least_squares/#cb1-41" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">34.68074111840572</span>]</span>
<span id="cb1-42"><a href="/roki.log/2019/01/3/least_squares/#cb1-42" aria-hidden="true"></a>[<span class="fl">13.820707197220901</span>]</span>
<span id="cb1-43"><a href="/roki.log/2019/01/3/least_squares/#cb1-43" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">5.563765361160251e-4</span>]</span></code></pre></div>
<p><span class="math inline">m=10</span> で, <span class="math inline">-21.670\cdots,37.428\cdots,-34.680\cdots,13.820\cdots</span> といった, 絶対値の大きな値が見られる. 実際に <span class="math inline">m=9, 10</span> でプロットしてみると,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="/roki.log/2019/01/3/least_squares/#cb2-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">mapM_</span> (\i <span class="ot">-&gt;</span> plot <span class="op">$</span> <span class="dt">PP</span> (<span class="st">&quot;./image&quot;</span> <span class="op">++</span> <span class="fu">show</span> i <span class="op">++</span> <span class="st">&quot;.png&quot;</span>) (<span class="st">&quot;m = &quot;</span> <span class="op">++</span> <span class="fu">show</span> i) <span class="st">&quot;points&quot;</span> <span class="st">&quot;line&quot;</span> dd <span class="op">$</span> fromJust <span class="op">$</span> implicitFn <span class="op">$</span> fromJust <span class="op">$</span> resolve i dd) [<span class="dv">9</span>, <span class="dv">10</span>]</span></code></pre></div>
<p><span class="math inline">m=10</span> のモデルによる近似は <span class="math inline">m=9</span> の場合と比べて激しく振れていることが見てとれる.</p>
<div class="box has-text-centered is-shadowless">
<p><img src="/roki.log/2019/01/3/least_squares/image9.png" title="non regulared 1" width="320" alt="non regulared 1" /> <img src="/roki.log/2019/01/3/least_squares/image10.png" title="non regulared 2" width="320" alt="non regulared 2" /></p>
</div>
<p>天下り的になってしまうが, このような現象は推定する係数に対して標本数が少ないようなときによく遭遇する. その特徴として, いま示したように, 係数の絶対値が大きくなることが挙げられる. 従って, 次数を適当に固定した上で(この場合 <span class="math inline">n=</span>データ数<span class="math inline">-1</span>, すなわちデータ数から機械的に次数を決定する), 係数を絶対値を制限することができれば, これを防ぐことができるだろう. 具体的な手法として, 式 <span class="math inline">(4)</span> に対してノルムを加え, その最小化を求めるといったような<a href="/roki.log/2019/01/3/least_squares/#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>手法が広く知られている. この手法は, ノルムに対して, 次のように平滑化パラメータ <span class="math inline">\lambda \geq 0</span> を作用させることで正則化の強度を設定することができる.</p>
<p><span class="math display">\epsilon({\boldsymbol a})_\lambda=\sum^m_{i=1}(y_i-f_n({\boldsymbol x}_i))^2+\underbrace{\lambda R({\boldsymbol a})}_{\rm 正則化項}</span></p>
<p>このような最適化を正則化法という. こうすると, モデルの変動が大きくなるにつれて正則化項も大きくなり, それが最小化問題へのペナルティとなって, 結果的に滑らかな曲線の推定に繋がる. ただし, 過剰に大きいパラメータをとると, 高次の項へのペナルティが強くなってしまうことで, 結局, 高次の項を無視するのと同等となってしまい, 低次の関数でモデルを作るのと同等になってしまう. 従って, 依然として適切なパラメータの設定が要されるわけだが, モデルの次数を決定するよりかは楽である.</p>
<p>またパラメータ <span class="math inline">\lambda</span> を標本数で割った形式が取られることもある.</p>
<p><span class="math display">\epsilon({\boldsymbol a})_\lambda=\sum^m_{i=1}(y_i-f_n({\boldsymbol x}_i))^2+\underbrace{\frac{\lambda}{m} R({\boldsymbol a})}_{\rm 正則化項}</span></p>
<p>両者の違いは正則化項の影響度である. 先に, 推定する係数に対して標本数が少ないようなときにオーバーフィッティングはよく起こると述べたが, ならば当然, 標本数が十分である場合には正則化項は必要ない. パラメータ <span class="math inline">\lambda</span> を標本数で割ってやれば, 標本数の増加に従って正則化項の影響度を抑制できる. どちらを用いるかはその時々で選択の余地があるだろう.</p>
<p>例えば, <span class="math inline">\lambda</span> を標本数に依らず直接作用させる形式で <span class="math inline">R({\boldsymbol v})</span> を <span class="math inline">L^2</span> ノルムとする<a href="/roki.log/2019/01/3/least_squares/#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>と,</p>
<p><span class="math display">
\begin{aligned}
\epsilon({\boldsymbol a})_\lambda&amp;=&amp;\sum^m_{i=1}(y_i-f_n({\boldsymbol x}_i))^2+\lambda\sum_{j=0}^{n}a^2_j \\
&amp;=&amp;({\boldsymbol y}-X{\boldsymbol a})^T({\boldsymbol y}-X{\boldsymbol a})+\lambda{\boldsymbol a}^T{\boldsymbol a}
\end{aligned}
</span></p>
<p>先と同様に <span class="math inline">\nabla\epsilon({\boldsymbol a})_\lambda=0</span> とおいて,</p>
<p><span class="math display">
\begin{aligned}
\nabla\epsilon({\boldsymbol a})_\lambda&amp;=&amp;-2X^T({\boldsymbol y}-X{\boldsymbol a})+2\lambda{\boldsymbol a} \\
&amp;=&amp;2(\lambda I+X^T X){\boldsymbol a}-2X^T{\boldsymbol y}\\ &amp;=&amp;0
\end{aligned}
</span></p>
<p>従ってこの正規方程式の解は,</p>
<p><span class="math display">{\boldsymbol a}=(\lambda I+X^T X)^{-1}X^T{\boldsymbol y}</span></p>
<p>となる. <span class="math inline">{\boldsymbol a}</span> を求めるに際する時間計算量について加味すると, 逆行列を計算するよりも LU 分解を行った方が良いので,</p>
<p><span class="math display">(\lambda I+X^T X){\boldsymbol a}=X^T{\boldsymbol y}</span></p>
<p>としておく. この正規方程式を用いて, 平滑化パラメータ <span class="math inline">\lambda=0.1,1,10</span> を適用しプロットすると,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="/roki.log/2019/01/3/least_squares/#cb3-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">mapM_</span> (\i <span class="ot">-&gt;</span> plot <span class="op">$</span> <span class="dt">PP</span> (<span class="st">&quot;./image&quot;</span> <span class="op">++</span> <span class="fu">show</span> i <span class="op">++</span> <span class="st">&quot;.png&quot;</span>) (<span class="st">&quot;parameter = &quot;</span> <span class="op">++</span> <span class="fu">show</span> i) <span class="st">&quot;points&quot;</span> <span class="st">&quot;line&quot;</span> dd <span class="op">$</span> fromJust <span class="op">$</span> implicitFn <span class="op">$</span> fromJust <span class="op">$</span> resolveRegular i dd) [<span class="fl">0.1</span>, <span class="dv">1</span>, <span class="dv">10</span>]</span></code></pre></div>
<p>次のようになる.</p>
<div class="box has-text-centered is-shadowless">
<p><img src="/roki.log/2019/01/3/least_squares/image0.1.png" title="regulared 0.1" width="320" alt="regulared 0.1" /> <img src="/roki.log/2019/01/3/least_squares/image1.0.png" title="regulared 1.0" width="320" alt="regulared 1.0" /> <img src="/roki.log/2019/01/3/least_squares/image10.0.png" title="regulared 10.0" width="320" alt="regulared 10.0" /></p>
</div>
<p>問題は, どのようにしてオーバーフィッティングを評価するかである. データセット <span class="math inline">\bf x</span> に対し, 真の値 <span class="math inline">t_i</span> を <span class="math inline">D=\left\{({\bf x_1},t_1), ({\bf x_2},t_2),\cdots,({\bf x_m},t_m)\right\} {\rm where}\ t_i=g+u_i\ (\because\ \ {\text (ii) より})</span> とし, 回帰分析によって得られるモデル <span class="math inline">\hat{f}_n({\bf y_i})=f_n({\boldsymbol x'_i})\ {\rm where}\ {\boldsymbol x'_i}=({\bf y_i^0},{\bf y_i^1},\cdots,{\bf y_i^n})^T (\because \ {\text (10) より})</span> との差を次のように定義する.</p>
<p><span class="math display">L(t_i, \hat{f}_n({\boldsymbol {\bf x_i}})):=(t_i-\hat{f}_n({\boldsymbol {\bf x_i}}))^2</span></p>
<p>この <span class="math inline">L</span> は損失関数といわれる. ここで, <span class="math inline">\bf x_i</span> と <span class="math inline">t_i</span> が得られる同時確率を考慮すると, 損失の期待値は</p>
<p><span class="math display">
\begin{aligned}
E\left[L(t_i, \hat{f}_n({\bf x_i}))\right]&amp;=&amp;
\int\int(t_i-\hat{f}_n({\bf x_i}))^2P(t_i\cap{\bf x_i})dt_id{\bf x_i} \\
&amp;=&amp;\int\left\{\int(t_i-\hat{f}_n({\bf x_i}))^2P(t_i\mid{\bf x_i})dt_i\right\}P({\bf x_i})d{\bf x_i}\ (\because \href{/roki.log/2018/10/28/probabilityTerms/#MulTheoremConditionalProbability}{\text 条件付き確率の乗法定理})
\end{aligned}
</span></p>
<p><span class="math inline">\int(t_i-\hat{f}_n({\bf x_i}))^2P(t_i|{\bf x_i})</span> を最小化したいので, これを <span class="math inline">g({\bf y})=\int(t_i-\hat{f}_n({\bf y_i}))^2P(t_i|{\bf y_i})</span> とおいて</p>
<p><span class="math display">
\begin{aligned}
\frac{\partial}{\partial \hat{f}_n({\bf x_i})} g({\bf x_i})&amp;=&amp;2\int(t_i-\hat{f}_n({\bf x_i}))P(t\mid{\bf x_i})dt_i \\
&amp;=&amp;2\int\left\{\hat{f}_n({\bf x_i})P(t_i\mid{\bf x_i})\right\}dt_i-2\int t_i P(t_i\mid{\bf x_i})dt_i \\
&amp;=&amp;2\hat{f}_n({\bf x_i})\int P(t_i\mid{\bf x_i})dt_i-2\int t_i P(t_i\mid{\bf x_i})dt_i \\
&amp;=&amp;2\hat{f}_n({\bf x_i})-2\int t_i P(t_i\mid {\bf x_i})dt_i\ (\because \href{/roki.log/2018/10/28/probabilityTerms/#normalizationLaw}{\text 規格化条件})
\end{aligned}
</span></p>
<p><span class="math inline">\therefore</span></p>
<p><span class="math display">
\nabla g({\bf x})=0\leftrightarrow \hat{f}_n({\bf x_i})=\int t_i P(t_i\mid{\bf x_i})=E\left[t_i\mid{\bf x_i}\right]
</span></p>
<p>よって, <span class="math inline">\hat{f}_n</span> は条件付き期待値 <span class="math inline">E\left[t_i\mid{\bf x_i}\right]</span> で決めると最小化されることがわかった. 先に示した損失関数 <span class="math inline">L</span> は, 一つの点における差なので, すべての点における差を次のように定義する(英: mean-square error から).</p>
<p><span class="math display">{\rm MSE}:=\sum^m_{i=1}L(t_i,\hat{f}_n({\bf x_i}))</span></p>
<p>この期待値をできる限り小さくしたい.</p>
<p><span class="math display">E\left[{\rm MSE}\right]=E\left[\sum^m_{i=1}L(t_i,\hat{f}_n({\bf x}))\right]=\sum_{i=1}^mE\left[L(t_i,\hat{f}_n({\bf x}))\right]\ (\because \href{/roki.log/2018/10/28/probabilityTerms/#fn-2}{\text 期待値の線形性})</span></p>
<p><span class="math inline">E\left[L(t_i,\hat{f}_n({\bf x_i}))\right]</span> について展開すると,</p>
<p><span class="math display">
\begin{aligned}
E\left[L(t_i,\hat{f}_n({\bf x_i}))\right]&amp;=&amp;
E\left[(t_i-\hat{f}_n({\bf x_i}))^2\right] \\
&amp;=&amp;E\left[(t_i-E\left[t_i\mid{\bf x_i}\right]+E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x_i}))^2\right] (\because {\rm augmentation\ trick})\\
&amp;=&amp;E\left[\left\{\underbrace{(t_i-E\left[t_i\mid{\bf x_i}\right])}_{a}+\underbrace{(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x_i}))}_{b}\right\}^2\right] \\
&amp;=&amp;E\left[
\begin{array}{c}
(t_i-E\left[t_i\mid{\bf x_i}\right])^2+ \\
(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x_i}))^2+ \\
2(t_i-E\left[t_i\mid{\bf x_i}\right])(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x_i}))
\end{array}\ 
\right] (\because (a+b)^2=a^2+b^2+2ab\tag{12}) \\
&amp;=&amp;
\begin{array}{c}
E\left[(t_i-E\left[t_i\mid{\bf x_i}\right])^2\right] \\
+E\left[(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x_i}))^2\right] \\
+E\left[2(t_i-E\left[t_i\mid{\bf x_i}\right])(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x_i}))\right]
\end{array}
(\because \href{/roki.log/2018/10/28/probabilityTerms/#fn-2}{\text 期待値の線形性})
\end{aligned}
</span></p>
<p>第三項について</p>
<p><span class="math display">
\begin{aligned}
E\left[2(t_i-E\left[t_i\mid{\bf x_i}\right])(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x}))\right]&amp;=&amp;2(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x}))E\left[(t_i-g)\right]\ (\because \href{/roki.log/2018/10/28/probabilityTerms/#mjx-eqn-eq%3Aexaxiom3}{E\left[a A\right]=a E\left[A\right]}) \\
&amp;=&amp;2(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x}))(E\left[t_i\right]-E\left[E\left[t_i\mid{\bf x_i}\right]\right])\ (\because \href{/roki.log/2018/10/28/probabilityTerms/#fn-2}
{\text 期待値の線形性}) \\
&amp;=&amp;2(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x}))(E\left[t_i\right]-E\left[t_i\right]) \ (\because \href{/roki.log/2018/10/28/probabilityTerms/#fn-4}{E\left[B\right]=E\left[E\left[B\mid A\right]\right]}) \\
&amp;=&amp;0
\end{aligned}
</span></p>
<p><span class="math inline">\therefore</span></p>
<p><span class="math display">
\begin{aligned}
E\left[L(t_i,\hat{f}_n({\bf x_i}))\right]&amp;=&amp;
E\left[(t_i-E\left[t_i\mid{\bf x_i}\right])^2\right]+
E\left[(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x}))^2\right] \\
&amp;=&amp;E\left[u^2\right]+E\left[(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x_i}))^2\right]
\end{aligned}
</span></p>
<p>この第一項は, 真の値と最小化された理想の関数の差であるので, ノイズ項に対応することとなる. 従って, 第一項に関してもう少し潜り込んでみると</p>
<p><span class="math display">
\begin{aligned}
E\left[(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x_i}))^2\right]&amp;=&amp;
E\left[(E\left[t_i\mid{\bf x_i}\right]-E\left[\hat{f}_n({\bf x_i})\right]+E\left[\hat{f}_n({\bf x_i})\right]-\hat{f}_n({\bf x_i}))^2\right]\ (\because {\rm augmentation\ trick})\\
&amp;=&amp;E\left[\left\{
\underbrace{(E\left[t_i\mid{\bf x_i}\right]-E\left[\hat{f}_n({\bf x_i})\right])}_{a}+
\underbrace{(E\left[\hat{f}_n({\bf x_i})\right]-\hat{f}_n({\bf x_i}))}_{b}\right
\}^2\right]\\
&amp;=&amp;E\left[
\begin{array}{c}
(E\left[t_i\mid{\bf x_i}\right]-E\left[\hat{f}_n({\bf x_i})\right])^2+\\
(E\left[\hat{f}_n({\bf x_i})\right]-\hat{f}_n({\bf x_i}))^2+\\
2(E\left[t_i\mid{\bf x_i}\right]-E\left[\hat{f}_n({\bf x_i})\right])(E\left[\hat{f}_n({\bf x_i})\right]-\hat{f}_n({\bf x_i}))^2
\end{array}
\right]\ (\because (12)) \\
&amp;=&amp;\begin{array}{c}
E\left[(E\left[t_i\mid{\bf x_i}\right]-E\left[\hat{f}_n({\bf x_i})\right])^2\right]+\\
E\left[(E\left[\hat{f}_n({\bf x_i})\right]-\hat{f}_n({\bf x_i}))^2\right]+\\
2E\left[(E\left[t_i\mid{\bf x_i}\right]-E\left[\hat{f}_n({\bf x_i})\right])(E\left[\hat{f}_n({\bf x_i})\right]-\hat{f}_n({\bf x_i}))^2\right]
\end{array}\ \\
&amp;&amp;(\because \href{/roki.log/2018/10/28/probabilityTerms/#fn-2}{\text 期待値の線形性}, \href{/roki.log/2018/10/28/probabilityTerms/#mjx-eqn-eq%3Aexaxiom3}{E\left[a A\right]=a E\left[A\right]})
\end{aligned}
</span></p>
<p>第三項について</p>
<p><span class="math display">
\begin{aligned}
&amp;2E\left[(E\left[t_i\mid{\bf x_i}\right]-E\left[\hat{f}_n({\bf x_i})\right])(E\left[\hat{f}_n({\bf x_i})\right]-\hat{f}_n({\bf x_i}))^2\right]=
2(
\begin{array}{l}
E\left[E\left[t_i\mid{\bf x_i}\right]E\left[\hat{f}_n({\bf x_i})\right]\right]- \\
E\left[E\left[\hat{f}_n({\bf x_i})\right]^2\right]- \\
E\left[\hat{f}_n({\bf x_i})E\left[t_i\mid{\bf x_i}\right]\right]+ \\
E\left[\hat{f}_n({\bf x_i})E\left[\hat{f}_n({\bf x_i})\right]\right]
\end{array}
)
\tag{13}
\end{aligned}
</span></p>
<p>ここで</p>
<ul>
<li><span class="math inline">\href{/roki.log/2018/10/28/probabilityTerms/#mjx-eqn-eq%3Aexaxiom3}{E\left[a A\right]=a E\left[A\right]} , \href{/roki.log/2018/10/28/probabilityTerms/#consExpisCons}{E\left[a\right]=a} \to E\left[E\left[a\right]\right]=a</span> より <span class="math display">E\left[E\left[t_i\mid{\bf x_i}\right]E\left[\hat{f}_n({\bf x_i})\right]\right]=E\left[t_i\mid{\bf x_i}\right]E\left[\hat{f}_n({\bf x_i})\right]</span></li>
<li><span class="math inline">\href{/roki.log/2018/10/28/probabilityTerms/#consExpisCons}{E\left[a\right]=a} \to E\left[E\left[a\right]\right]=a</span> より <span class="math display">E\left[E\left[\hat{f}_n({\bf x_i})\right]^2\right]=E\left[\hat{f}_n({\bf x_i})\right]^2</span></li>
<li><span class="math inline">\href{/roki.log/2018/10/28/probabilityTerms/#mjx-eqn-eq%3Aexaxiom3}{E\left[a A\right]=a E\left[A\right]}</span> より <span class="math display">E\left[\hat{f}_n({\bf x_i})E\left[t_i\mid{\bf x_i}\right]\right]=E\left[t_i\mid{\bf x_i}\right]E\left[\hat{f}_n({\bf x_i})\right]</span></li>
<li><span class="math inline">\href{/roki.log/2018/10/28/probabilityTerms/#mjx-eqn-eq%3Aexaxiom3}{E\left[a A\right]=a E\left[A\right]}</span> より <span class="math display">E\left[\hat{f}_n({\bf x_i})E\left[\hat{f}_n({\bf x_i})\right]\right]=E\left[\hat{f}_n({\bf x_i})\right]^2</span></li>
</ul>
<p>よって</p>
<p><span class="math display">
=
2(
E\left[t_i\mid{\bf x_i}\right]E\left[\hat{f}_n({\bf x_i})\right]-
E\left[\hat{f}_n({\bf x_i})\right]^2-
E\left[t_i\mid{\bf x_i}\right]E\left[\hat{f}_n({\bf x_i})\right]+
E\left[\hat{f}_n({\bf x_i})\right]^2
)
=0
</span></p>
<p><span class="math inline">\therefore</span></p>
<p><span class="math display">
\begin{aligned}
E\left[(E\left[t_i\mid{\bf x_i}\right]-\hat{f}_n({\bf x_i}))^2\right]
&amp;=&amp;
E\left[(E\left[t_i\mid{\bf x_i}\right]-E\left[\hat{f}_n({\bf x_i})\right])^2\right]+E\left[(E\left[\hat{f}_n({\bf x_i})\right]-\hat{f}_n({\bf x_i}))^2\right] \\
&amp;=&amp;
{\rm Bias}\left[\hat{f}_n({\bf x_i})\right]^2+{\rm Var}\left[\hat{f}_n({\bf x_i})\right]
\end{aligned}
</span></p>
<p>また</p>
<p><span class="math display">
\begin{aligned}
E\left[L(t_i,\hat{f}_n({\bf x_i}))\right]={\rm Bias}\left[\hat{f}_n({\bf x_i})\right]^2+{\rm Var}\left[\hat{f}_n({\bf x_i})\right]+\sigma^2
\end{aligned}
</span></p>
<p>この一連の展開作業は, バイアス-バリアンス分解といわれる. バイアスは, 損失の期待値を最小化する <span class="math inline">E\left[t|{\bf x_i}\right]</span> とのずれの期待値である. 従って, 関数モデルを複雑にするほど値は減少する. バリアンスはモデルの分散であり, モデルの複雑さを表す指標である. 従って, 関数モデルを複雑にするほど値は増加する. 両者のこの関係性をバイアスとバリアンスのトレードオフという. 多くの場合, これらが同時に可能な限り低い値をとるモデルのことを, データセットに対する適切なモデルと言うことができるだろう.</p>
<p>ここで, 先に示したデータセットに対して, 4 次元と 9 次元の線形関数による近似を行い, それぞれのバイアスとバリアンスを比較する.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="/roki.log/2019/01/3/least_squares/#cb4-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span><span class="ot"> bias ::</span> (<span class="dt">Real</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a; bias fh f il <span class="ot">=</span> (<span class="op">/</span>(<span class="fu">fromIntegral</span> <span class="op">$</span> <span class="fu">length</span> il)) <span class="op">$</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">map</span> ((<span class="op">^^</span><span class="dv">2</span>) <span class="op">.</span> <span class="fu">uncurry</span> (<span class="op">-</span>) <span class="op">.</span> first f <span class="op">.</span> second fh <span class="op">.</span> dupe) il</span>
<span id="cb4-2"><a href="/roki.log/2019/01/3/least_squares/#cb4-2" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span><span class="ot"> var ::</span> (<span class="dt">Real</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a; var fh il <span class="ot">=</span> <span class="kw">let</span> len <span class="ot">=</span> <span class="fu">fromIntegral</span>  <span class="op">$</span> <span class="fu">length</span> il; s <span class="ot">=</span> (<span class="op">/</span>len) <span class="op">$</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">map</span> fh il <span class="kw">in</span> (<span class="op">/</span>len) <span class="op">$</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">map</span> ((<span class="op">^^</span><span class="dv">2</span>) <span class="op">.</span> fh) il</span>
<span id="cb4-3"><a href="/roki.log/2019/01/3/least_squares/#cb4-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> f <span class="ot">=</span> <span class="fu">sin</span></span>
<span id="cb4-4"><a href="/roki.log/2019/01/3/least_squares/#cb4-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> fhat <span class="ot">=</span> fromJust <span class="op">.</span> implicitFn <span class="op">.</span> fromJust <span class="op">.</span> <span class="fu">flip</span> resolve dd</span>
<span id="cb4-5"><a href="/roki.log/2019/01/3/least_squares/#cb4-5" aria-hidden="true"></a>λ<span class="op">&gt;</span> bias (fhat <span class="dv">4</span>) f [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">&gt;</span> bias (fhat <span class="dv">9</span>) f [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb4-6"><a href="/roki.log/2019/01/3/least_squares/#cb4-6" aria-hidden="true"></a><span class="dt">True</span></span>
<span id="cb4-7"><a href="/roki.log/2019/01/3/least_squares/#cb4-7" aria-hidden="true"></a>λ<span class="op">&gt;</span> var (fhat <span class="dv">4</span>) [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">&lt;</span> var (fhat <span class="dv">9</span>) [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb4-8"><a href="/roki.log/2019/01/3/least_squares/#cb4-8" aria-hidden="true"></a><span class="dt">True</span></span></code></pre></div>
<p>先にオーバーフィッティングしてしまった, 10 次元のモデルと 9 次元のモデルのバイアスとバリアンスを比較する.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="/roki.log/2019/01/3/least_squares/#cb5-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> bias (fhat <span class="dv">9</span>) f [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">&gt;</span> bias (fhat <span class="dv">10</span>) f [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb5-2"><a href="/roki.log/2019/01/3/least_squares/#cb5-2" aria-hidden="true"></a><span class="dt">True</span></span>
<span id="cb5-3"><a href="/roki.log/2019/01/3/least_squares/#cb5-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> var (fhat <span class="dv">9</span>) [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">&lt;</span> var (fhat <span class="dv">10</span>) [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb5-4"><a href="/roki.log/2019/01/3/least_squares/#cb5-4" aria-hidden="true"></a><span class="dt">True</span></span></code></pre></div>
<p><span class="math inline">L^2</span> 正則化(<span class="math inline">\lambda=0.1,1,10</span>)を施した場合を見てみる.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="/roki.log/2019/01/3/least_squares/#cb6-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">ML.Approx.Regularization.L2</span> <span class="kw">as</span> <span class="dt">Reg</span></span>
<span id="cb6-2"><a href="/roki.log/2019/01/3/least_squares/#cb6-2" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> fhat' <span class="ot">=</span> fromJust <span class="op">.</span> implicitFn <span class="op">.</span> fromJust <span class="op">.</span> <span class="fu">flip</span> Reg.resolve dd</span>
<span id="cb6-3"><a href="/roki.log/2019/01/3/least_squares/#cb6-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">mapM_</span> (<span class="fu">print</span> <span class="op">.</span> (<span class="fu">flip</span> (<span class="fu">flip</span> bias f) [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>]) <span class="op">.</span> fhat') [<span class="fl">0.1</span>, <span class="dv">1</span>, <span class="dv">10</span>]</span>
<span id="cb6-4"><a href="/roki.log/2019/01/3/least_squares/#cb6-4" aria-hidden="true"></a><span class="fl">1.9110967187955293e-2</span></span>
<span id="cb6-5"><a href="/roki.log/2019/01/3/least_squares/#cb6-5" aria-hidden="true"></a><span class="fl">2.283386765131595e-2</span></span>
<span id="cb6-6"><a href="/roki.log/2019/01/3/least_squares/#cb6-6" aria-hidden="true"></a><span class="fl">4.427871557982087e-2</span></span>
<span id="cb6-7"><a href="/roki.log/2019/01/3/least_squares/#cb6-7" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">mapM_</span> (<span class="fu">print</span> <span class="op">.</span> (<span class="fu">flip</span> var [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>]) <span class="op">.</span> fhat') [<span class="fl">0.1</span>, <span class="dv">1</span>, <span class="dv">10</span>]</span>
<span id="cb6-8"><a href="/roki.log/2019/01/3/least_squares/#cb6-8" aria-hidden="true"></a><span class="fl">0.5855240280868919</span></span>
<span id="cb6-9"><a href="/roki.log/2019/01/3/least_squares/#cb6-9" aria-hidden="true"></a><span class="fl">0.5530852362842676</span></span>
<span id="cb6-10"><a href="/roki.log/2019/01/3/least_squares/#cb6-10" aria-hidden="true"></a><span class="fl">0.4586444106136849</span></span></code></pre></div>
<h3 id="誤差分布が正規分布でない場合の線形回帰">誤差分布が正規分布でない場合の線形回帰</h3>
<p>式 \(\) 等で, 線形最小二乗法がすべてのノイズ項の確率分布を同一視することを示した. この仮定により, 誤差の分布が非対称, あるいは外れ値が顕著に見られるようなデータセットに対する線形最小二乗法の適用結果は, パラメータの推定, 信頼区間およびその統計量について信頼できなくなる.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="/roki.log/2019/01/3/least_squares/#cb7-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> d n n' p <span class="ot">=</span> <span class="fu">zipWith</span> (\x y <span class="ot">-&gt;</span> (x, <span class="dv">2</span><span class="op">*</span>x<span class="op">+</span>y)) [n<span class="op">..</span><span class="fu">fromIntegral</span> n'] <span class="op">&lt;$&gt;</span> <span class="kw">let</span> uni <span class="ot">=</span> normalIO' p <span class="kw">in</span> replicateM (<span class="fu">succ</span> n') uni</span>
<span id="cb7-2"><a href="/roki.log/2019/01/3/least_squares/#cb7-2" aria-hidden="true"></a>λ<span class="op">&gt;</span> dleft <span class="ot">&lt;-</span> d <span class="dv">0</span> <span class="dv">10</span> (<span class="dv">0</span>,<span class="fl">0.2</span>)</span>
<span id="cb7-3"><a href="/roki.log/2019/01/3/least_squares/#cb7-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> dright <span class="ot">&lt;-</span> d <span class="dv">15</span> <span class="dv">25</span> (<span class="dv">0</span>, <span class="fl">0.2</span>)</span>
<span id="cb7-4"><a href="/roki.log/2019/01/3/least_squares/#cb7-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> dd <span class="ot">=</span> dleft <span class="op">++</span> [(x, <span class="dv">60</span>) <span class="op">|</span> x <span class="ot">&lt;-</span> <span class="fu">take</span> <span class="dv">4</span> [<span class="fu">succ</span> <span class="op">$</span> <span class="fu">fst</span> <span class="op">$</span> <span class="fu">last</span> dleft <span class="op">..</span>]] <span class="op">++</span> dright</span>
<span id="cb7-5"><a href="/roki.log/2019/01/3/least_squares/#cb7-5" aria-hidden="true"></a>λ<span class="op">&gt;</span> plot <span class="op">$</span> <span class="dt">PP</span> <span class="st">&quot;./image.png&quot;</span> <span class="st">&quot;Figure&quot;</span> <span class="st">&quot;points&quot;</span> <span class="st">&quot;line&quot;</span> dd <span class="op">$</span> fromJust <span class="op">$</span> implicitFn <span class="op">$</span> fromJust <span class="op">$</span> resolve <span class="dv">1</span> dd</span></code></pre></div>
<p><span class="math inline">\mathrm{N}(0,0.2)</span> の確率誤差の他に, 4 つの外れ値<a href="/roki.log/2019/01/3/least_squares/#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>を仕込んだこのデータへ線形最小二乗法(<span class="math inline">n=1</span>)を施すと, 外れ値に影響された推定が行われることがわかる.</p>
<figure>
<img src="/roki.log/2019/01/3/least_squares/outliers.png" title="lenear equations" width="600" alt /><figcaption>lenear equations</figcaption>
</figure>
<p>これを防ぐ方法はいくつか存在する. 以下, 説明のために改めて, <span class="math inline">p</span> 個の独立変数を有する多重線形回帰モデルを <span class="math display">{\boldsymbol y}=X'{\boldsymbol \beta}+{\boldsymbol u}</span> とする. ここで <span class="math inline">{\boldsymbol \beta}={\boldsymbol a}</span> で <span class="math inline">X'</span> は説明変数の行 <span class="math inline">{\boldsymbol x'_i}=(x'_{i1}, x'_{i2},\cdots,x'_{ip})^T</span> を有するフルランク行列 <span class="math inline">X'\in\mathbb{R}^{m\times p}</span> であり, <span class="math inline">{\boldsymbol u}</span> は <a href="/roki.log/2018/10/28/probabilityTerms/#iid">i.i.d</a> かつ <span class="math inline">\mathrm{N}(0,\sigma^2)</span> に従う確率誤差のベクトル <span class="math inline">{\boldsymbol u}=(u_1,u_2,\cdots,u_m)^T\in\mathbb{R}^{m\times 1}</span> とする. なおこの定義に従うと, (Ordinary least squares より)通常の最小二乗法は次の式で定義できる.</p>
<p><span class="math display">
\begin{aligned}
\mathrm{OLS}(X',{\boldsymbol y})&amp;:=&amp;\mathrm{arg}\min_{\boldsymbol {\boldsymbol \beta}}\sum^m_{i=1}r({\boldsymbol \beta})^2_i \tag{14} \\
&amp;=&amp;(11)
\end{aligned}
</span></p>
<p>ここで <span class="math inline">r({\boldsymbol \beta})_i</span> は <span class="math inline">r({\boldsymbol \beta})_i=y_i-{\boldsymbol x}_i{\boldsymbol \beta}</span> である(<span class="math inline">(4)</span> の偏差の部分). 以下, パラメータのベクトル <span class="math inline">{\boldsymbol \beta}</span> を明示的に示す必要がないときには <span class="math inline">r({\boldsymbol \beta})_i</span> を <span class="math inline">r_i</span> と示すこととする.</p>
<h3 id="最小刈込み二乗法">最小刈込み二乗法</h3>
<p>一言でいえば, この方法は単純に外れ値を最小二乗法の対象から除外してしまう方法である(以下 Least trimmed squares<a href="/roki.log/2019/01/3/least_squares/#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> より LTS と記述)といわれる.</p>
<p><span class="math display">
\begin{aligned}
\mathrm{LTS}(X,{\boldsymbol y},k)&amp;:=&amp;\mathrm{arg}\min_{\boldsymbol \beta}\sum^k_{i=1}r({\boldsymbol \beta})^2_{(i)} \\
&amp;&amp;{\rm s.t.\ } r({\boldsymbol \beta})^2_{(1)}\leq r({\boldsymbol \beta})^2_{(2)}\leq\cdots\leq r({\boldsymbol \beta})^2_{(m)}
\end{aligned}
</span></p>
<p>ここで <span class="math inline">r({\boldsymbol \beta})_{(i)}</span> は <span class="math inline">i</span> 番目に小さい残差を示す. 要するに, <span class="math inline">m</span> 個の偏差の二乗を昇順で並べ, 適当なパラメータ <span class="math inline">k\ (k\leq m)</span> に対して <span class="math inline">\sum^k_{i=1}(r^2)_{i:m}</span> を最小化する回帰係数を求めることをいう. 当然, <span class="math inline">k=m</span> とすると, 通常の最小二乗法と同じ結果となるが, <span class="math inline">k\lt m</span> で設定することで <span class="math inline">m-k</span> 個の大きな偏差をもつデータを無視できる. LTS は次の手順で実行する.</p>
<p><strong>TODO: LTS の手順</strong></p>
<p><strong>TODO: LTS による近似の実装</strong></p>
<p>また, 各データ点に対して重み(確率分布)を付与し, それらを単なる算術平均として捉えるのではなく, 期待値として捉えるようにする方法が思いつく. 実際にこれらはそれぞれ名前がついていて, 前者は最小刈り込み二乗法, 後者はロバスト推定といわれる.</p>
<p><strong>TODO: 最小刈り込みに情報, ロバスト推定による近似の実装</strong></p>
<h3 id="参考文献">参考文献</h3>
<ol type="1">
<li>「<a href="https://mathtrain.jp/seikiequ">正規方程式の導出と計算例 - 高校数学の美しい物語</a>」 2018 年 11 月 2 日アクセス.</li>
<li>「<a id="ref1" href="http://tekenuko.hatenablog.com/entry/2017/11/18/214317">Rでスパースモデリング：Elastic Net回帰についてまとめてみる</a>」 2018 年 11 月 5 日アクセス.</li>
<li>川野　秀一, 廣瀬　慧, 立石　正平, 小西　貞則 (2010)「<a href="http://svr4.terrapub.co.jp/journals/jjssj/pdf/3902/39020211.pdf">回帰モデリングと <span class="math inline">L_1</span> 型正則化法の最近の展開</a>」, 日本統計学会誌 第 39 巻, 第 2 号, 211 頁 〜 242 頁 pp.211~215, 2018 年 11 月 5 日アクセス.</li>
<li>「<a href="https://nagahara-masaaki.github.io/assets/pdfs/lecture13.pdf">数値計算 大阪大学基礎工学部</a>」 2018 年 11 月 5 日アクセス.</li>
<li>美添　泰人 (2010)「<a href="https://www.terrapub.co.jp/journals/jjssj/pdf/3902/39020161.pdf" id="ref3">経済と統計の間で</a>」, 日本統計学会誌 第 38 巻, 第 2 号, 161 頁 〜 179 頁 pp.173~175 2018 年 11 月 10 日アクセス.</li>
<li>「<a href="https://www.hellocybernetics.tech/entry/2017/01/24/100415">バイアス-バリアンス分解：機械学習の性能評価 - HELLO CYBERNETICS</a>」 2018 年 11 月 13 日アクセス.</li>
<li>Jurgen A. Doornik (2011) “<a id="ref2" class="disabled">Robust Estimation Using Least Trimmed Squares</a>”, Institute for Economic Modelling, Oxford Martin School, and Economics Department, University of Oxford, UK</li>
<li>Rousseeuw and B.C. Van Zomeren (1990) “<a id="ref4" class="disabled">Unmasking multivariate outliers and leverage points</a>”, Journal of the American Statistical Association, pp.633–639</li>
<li>Vincenzo Verardi “<a id="ref5" href="https://www.stata.com/meeting/uk08/VerardiRobustStatisticsinStata.pdf">Robust Statistics Statistics in Stata</a>”, 2018 年 11 月 17 日アクセス.</li>
</ol>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>データセットは, <a href="http://math.arizona.edu/~dsl/bmile.htm">Data Set for CHAPTER 2 - DIFFERENTIAL EQUATIONS graphics, models, data</a> を利用させていただいた.<a href="/roki.log/2019/01/3/least_squares/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>最小二乗法の定義により「<span class="math inline">\mathrm{Cov}(x,y)\gt 0\leftrightarrow</span>最小二乗法による直線の傾きが正」がいえることで, 「相関係数が <span class="math inline">0</span> であるとき, 各 <span class="math inline">x_i,y_i</span> に相関関係がない」を数学的に説明できたと捉えることができる.<a href="/roki.log/2019/01/3/least_squares/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote">したがって, 式に起こすと以下の通り:
<p>また, <span class="math display">V\left[y_i\right]=V\left[\sum^m_{j=0}a_jf_j(x_i^0,x_i^1,\cdots,x_i^n)+\epsilon_i\right]=V\left[\epsilon_i\right]=\sigma^2</span><a href="/roki.log/2019/01/3/least_squares/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>複素行列について扱う場合, 転置行列を随伴行列, 直交行列をユニタリ行列にすれば同様にして求まる.<a href="/roki.log/2019/01/3/least_squares/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><span class="math inline">n'=m</span> で, 同行列のような各行が初項 <span class="math inline">1</span> の等比数列であるような正方行列をヴァンデルモンド行列という.<a href="/roki.log/2019/01/3/least_squares/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>例えば, Wolfram 言語では<a href="https://reference.wolfram.com/language/ref/PseudoInverse.html"><code>PseudoInverse</code></a>という組み込みシンボルがあるが, これは MP 逆行列を算出する. また R 言語の<a href="https://www.rdocumentation.org/packages/pracma/versions/1.9.9/topics/pinv"><code>pinv</code></a>関数も同様.<a href="/roki.log/2019/01/3/least_squares/#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>一意性の証明: いま <span class="math inline">X</span> に 2 つの相異なる MP 逆行列 <span class="math inline">A^{\dagger}\not =B^{\dagger}</span> が存在すると仮定する. まず <span class="math inline">A^{\dagger}</span> について, <span class="math inline">A^{\dagger} = A^{\dagger} X A^\dagger = A^\dagger(X A^\dagger)^T=A^\dagger(X B^\dagger X A^\dagger)^T=A^\dagger(X A^\dagger)^T(X B^\dagger)^T= A^\dagger X A^\dagger X B^\dagger=A^\dagger X B^\dagger</span>. 次に <span class="math inline">B^\dagger</span> について, <span class="math inline">B^\dagger = B^\dagger X B^\dagger = (B^\dagger X)^T B^\dagger = (B^\dagger X A^\dagger X)^T B^\dagger = (A^\dagger X)^T (B^\dagger X)^T B^\dagger = A^\dagger X B^\dagger X B^\dagger = A^\dagger X B^\dagger</span>. 背理により, <span class="math inline">A^\dagger=B^\dagger</span>. <span class="math inline">\square</span><a href="/roki.log/2019/01/3/least_squares/#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><span class="math inline">n'=m</span> で, 同行列のような各行が初項 <span class="math inline">1</span> の等比数列であるような正方行列をヴァンデルモンド行列という.<a href="/roki.log/2019/01/3/least_squares/#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote">最小二乗形一般逆行列が MP 逆行列であることの証明: <span class="math inline">X^{\dagger}X=\underbrace{(X^T X)^{-1}X^T}_{X^\dagger} X=I</span> だから <span class="math inline">(6),(7),(8),(9)</span> より
<p>なお最後の式変形では, <span class="math inline">(A B)^T =B^T A^T, (A^{-1})^T=(A^T)^{-1}</span> を用いた. <span class="math inline">\square</span><a href="/roki.log/2019/01/3/least_squares/#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>このような, <span class="math inline">\lambda\sum_{j=0}^{n}\left|a_j\right|^q</span> で <span class="math inline">q=2</span> の場合を Ridge 回帰という. また <span class="math inline">q=1</span> のとき(すなわち正則化項が <span class="math inline">L^1</span> ノルム)を Lasso 回帰という. さらに, これらの正則化項の線形結合の形式をとる Elastic Net 回帰というモデルもある(Elastic Net 回帰に関する<a href="/roki.log/2019/01/3/least_squares/#ref1">参考文献2</a>). この形式で表せる正則化項を用いる回帰をブリッジ回帰という.<a href="/roki.log/2019/01/3/least_squares/#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>このような, <span class="math inline">\lambda\sum_{j=0}^{n}\left|a_j\right|^q</span> で <span class="math inline">q=2</span> の場合を Ridge 回帰という. また <span class="math inline">q=1</span> のとき(すなわち正則化項が <span class="math inline">L^1</span> ノルム)を Lasso 回帰という. さらに, これらの正則化項の線形結合の形式をとる Elastic Net 回帰というモデルもある(Elastic Net 回帰に関する<a href="/roki.log/2019/01/3/least_squares/#ref1">参考文献2</a>). この形式で表せる正則化項を用いる回帰をブリッジ回帰という.<a href="/roki.log/2019/01/3/least_squares/#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>このような, 線形性の見られるデータセットに従わず, かつ直交座標系における <span class="math inline">Y</span> 軸方向にデータポイント <span class="math inline">(x'_{ij},y_i)</span> が外れているような点を垂直外れ値(英: vertical outlier)という. また同状況下で <span class="math inline">X</span> 軸方向に大きく外れているような点を悪いレバレッジ点(英: bad leverage point)という. さらに, <span class="math inline">(x'_{ij},y_i)</span> が大多数のパターンに従うとき, それを良いレバレッジ点(英: good leverage point)という(<span class="math inline">\to</span><a href="/roki.log/2019/01/3/least_squares/#ref4">参考文献8</a>, <a href="/roki.log/2019/01/3/least_squares/#ref5">参考文献9</a>).<a href="/roki.log/2019/01/3/least_squares/#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>LTS の歴史的背景および専門家らによる認識に関する言及: <i>Peter Rousseeuw introduced several robust regression estimators, including least median of squares (LMS) and least trimmed squares (LTS), see Rousseeuw (1984) as well as the monograph Rousseeuw and Leroy (1987). LTS converges at rate <span class="math inline">n^{\frac{1}{2}}</span> with the same assymptotic efficiency under normalityas Huber’s skip estimator. The LMS convergence rate is <span class="math inline">n^{\frac{1}{3}}</span> and its objective function is less smooth than LTS. As a consequence, as argued in Rousseeuw and van Driessen (2006), LTS is now preferred over LMS.</i> – <a href="/roki.log/2019/01/3/least_squares/#ref2">参考文献7 pp.2</a>, <i>この他にも残差の 2 乗のメディアンを最少にする LMS (least median of squares) などが提案されているが，いずれも収束が遅く，効率も高くないこともあり，Huber (2009) は根本的な問題の検討が必要と指摘している．</i> – <a href="/roki.log/2019/01/3/least_squares/#ref3">参考文献5 pp.174</a><a href="/roki.log/2019/01/3/least_squares/#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>LU 分解</title>
    <link href="https://roki.dev/roki.log/2019/01/1/lu_decomposition/index.html" />
    <id>https://roki.dev/roki.log/2019/01/1/lu_decomposition/index.html</id>
    <published>2019-01-01T00:00:00Z</published>
    <updated>2019-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>LU 分解に関して初歩的な内容から網羅的にまとめた.</p>
<!--more-->
<h2 id="ガウスの消去法">ガウスの消去法</h2>
<p>ガウスの消去法は, 前進消去による上三角行列の形成と後退代入の組み合わせのことをいい, その本質は行列の行基本変形, すなわち中学校で習う連立方程式の解法そのものである. 例えば, 何の芸もないが, 次の連立方程式</p>
<p><span class="math display">
\begin{aligned}
\begin{cases}
x+2y&amp;=&amp;3  \\
3x+4y&amp;=&amp;5
\end{cases}\leftrightarrow
\left(\begin{array}{cc|c}
1 &amp; 2 &amp; 3 \\
3 &amp; 4 &amp; 5
\end{array}\right)\tag{1}
\end{aligned}
</span></p>
<p>をガウスの消去法では次のようにして解くのであった.</p>
<p><span class="math display">
\left(\begin{array}{cc|c}
1 &amp; 2 &amp; 3 \\
3 &amp; 4 &amp; 5
\end{array}\right)\to
\underbrace{
\left(\begin{array}{cc|c}
\overbrace{1}^{\times (-3)} &amp; \overbrace{2}^{\times (-3)} &amp; \overbrace{3}^{\times (-3)} \\
\underline{3} &amp; 4 &amp; 5
\end{array}\right)
}_{\rm 前進消去}\to
\left(\begin{array}{cc|c}
1 &amp; 2 &amp; 3 \\
0 &amp; -2 &amp; -4
\end{array}\right)\to
\underbrace{
\left(\begin{array}{cc|c}
1 &amp; \underline{2} &amp; 3 \\
\overbrace{0}^{\times 1} &amp; \overbrace{-2}^{\times 1} &amp; \overbrace{-4}^{\times 1}
\end{array}\right)
}_{\rm 後退代入} \\ \to
\left(\begin{array}{cc|c}
1 &amp; 0 &amp; -1 \\
0 &amp; -2 &amp; -4
\end{array}\right) \\
\therefore (x,y)=(-1\div 1,-4\div (-2))=(-1,2)
</span></p>
<p>この前進消去の操作は次のように行列の積で表現できる.</p>
<p><span class="math display">
\left(\begin{array}{cc}
1 &amp; 0 \\
-3 &amp; 1
\end{array}\right)
\left(\begin{array}{cc}
1 &amp; 2 \\
3 &amp; 4
\end{array}\right)=
\left(\begin{array}{cc}
1 &amp; 2 \\
0 &amp; -2
\end{array}\right)
</span></p>
<p>これを理解しておくと後述する LU 分解の理解に容易くなる. ここで, この時間計算量について, 一般の <span class="math inline">n</span> 次線形連立方程式 <span class="math inline">X{\boldsymbol a}={\boldsymbol y}\ {\rm where}\ X\in\mathbb{R}^{n\times n}, {\boldsymbol a}\in\mathbb{R}^{n\times 1}, {\boldsymbol y}\in\mathbb{R}^{n\times 1}</span> を用いて考えるする.</p>
<p><span class="math display">\left(\begin{array}{ccccc}
x_{11} &amp; x_{12} &amp; x_{13} &amp; \cdots &amp; x_{1n} \\
x_{21} &amp; x_{22} &amp; x_{23} &amp; \cdots &amp; x_{2n} \\
x_{31} &amp; x_{32} &amp; x_{33} &amp; \cdots &amp; x_{3n} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n1} &amp; x_{n2} &amp; x_{n3} &amp; \cdots &amp; x_{nn}
\end{array}\right)
\left(\begin{array}{c}a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_n\end{array}\right)=
\left(\begin{array}{c}y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_n\end{array}\right)
</span></p>
<p>まず前進消去の操作について考える. 前進消去では, <span class="math inline">x_{11}</span> を使って残りの <span class="math inline">x_{21}, x_{31}, \cdots, x_{n1}</span> を掃き出していくのであった. ただし <span class="math inline">x_{21}, x_{31}, \cdots, x_{n1}</span> は必ず <span class="math inline">0</span> となるのだから, これは実質の計算量として考える必要はないだろう. すると <span class="math inline">x_{21}, x_{31}, \cdots, x_{n1}</span> を掃きだすのに伴って, 実際の計算を要される部分というのは</p>
<p><span class="math display">
\begin{array}{cccc}
x_{22} &amp; x_{23} &amp; \cdots &amp; x_{2n} \\
x_{32} &amp; x_{33} &amp; \cdots &amp; x_{3n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
x_{n2} &amp; x_{n3} &amp; \cdots &amp; x_{nn}
\end{array}
</span></p>
<p>の箇所であることがいえる. この部分の成分数は <span class="math inline">(n-1)^2</span> なので, 一回目の前進消去では <span class="math inline">(n-1)^2</span> 回の計算を行うことがわかる. 次に, 二回目の前進消去では <span class="math inline">x_{22}</span> を使って, それと同列のそれよりも下の行の成分 <span class="math inline">x_{32},\cdots,x_{n2}</span> を先と同様に消していくわけだが, ここでも同様, <span class="math inline">x_{32},\cdots,x_{n2}</span> は必ず <span class="math inline">0</span> なので, 実際に計算を行う部分は</p>
<p><span class="math display">
\begin{array}{ccc}
x_{33} &amp; \cdots &amp; x_{3n} \\
\vdots &amp; \ddots &amp; \vdots \\
x_{n3} &amp; \cdots &amp; x_{nn}
\end{array}
</span></p>
<p>の箇所である. この部分の成分数は <span class="math inline">(n-2)^2</span> なので, 二回目の全身消去では <span class="math inline">(n-2)^2</span> 回の計算を行うことがわかる. これを繰り返すと, 計算を行う部分が残り一成分となるまで同様の計算回数がかかることがわかるから</p>
<p><span class="math display">(n-1)^2+(n-2)^2+\cdots+2^2+1^2
=\sum^{n}_{i=1}(i-1)^2</span></p>
<p>ここで, 高校数学の教科書にも載っている定理(証明略) <span class="math inline">\sum^n_{j=1}j^2=\frac{n(n+1)(2n+1)}{6}</span> を思い出せば, 先の式は <span class="math inline">\sum^n_{i=1}(i-1)^2=\frac{n^3}{3}+n^2</span> と表せることがわかる.</p>
<p>続いて, 後退代入について考える. 後退代入は, 上三角行列となっている係数行列に対して代入を繰り返し, 対角行列を形成していく操作であった.</p>
<p><span class="math display">\left(\begin{array}{ccccc}
x_{11} &amp; x_{12} &amp; x_{13} &amp; \cdots &amp; x_{1n} \\
&amp; x_{22} &amp; x_{23} &amp; \cdots &amp; x_{2n} \\
&amp; &amp; x_{33} &amp; \cdots &amp; x_{3n} \\
&amp; &amp; &amp; \ddots &amp; \vdots \\
&amp;&amp;&amp;&amp; x_{nn}
\end{array}\right)
\left(\begin{array}{c}a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_n\end{array}\right)=
\left(\begin{array}{c}y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_n\end{array}\right)
</span></p>
<p>この場合, まず <span class="math inline">x_{nn}</span> を使って, <span class="math inline">x_{1n},x_{2n},x_{3n},\cdots,x_{(n-1)n}</span> を消していくわけだが, この際, 係数行列に対する操作というのはただ <span class="math inline">0</span> にしていくということだけである. これを <span class="math inline">x_{22}</span> まで繰り返し行うわけだが, その間の係数行列に関する操作はただ <span class="math inline">0</span> にしていくということだけなので, これを計算量に含む必要はない. 実際に計算が発生するのは, 右辺ベクトルの部分である. まず <span class="math inline">y_n</span> に対する計算は, 後退代入の操作を考えれば, 当然なにもする必要はない. 次に <span class="math inline">y_{n-1}</span> に対する計算は <span class="math inline">(y_{n-1})'=y_{n-1}-\frac{x_{(n-1)n}}{x_{nn}}y_n</span> であり, 減算, 除算, 積算が各一回ずつ行われることがいえる. 次の <span class="math inline">y_{n-2}</span> に対する計算も同様 <span class="math inline">y_{n-2}-\frac{x_{(n-2)n}}{x_{(n-1)n}}(y_{n-1})'</span> であり, 計算の形式は先と全く同じであるが, その前の後退代入の結果 <span class="math inline">(y_{n-1})'</span> を用いている点で計算量は異なる. つまり, いま計算したい右辺ベクトルの成分を計算するのには, その一つ下の右辺ベクトルの成分に対する計算結果が必要となる(後退代入の操作そのもの)ことから, これが <span class="math inline">y_1</span> にまで及ぶことを考えると, 後退代入の総回数は</p>
<p><span class="math display">1+2+\cdots+(n-1)=\frac{n(n-1)}{2}</span></p>
<p>とかける(右辺への式変形の証明は高校数学の教科書で扱われているので略). ガウスの消去法は前進消去と後退代入の組み合わせであるので, その時間計算量は,</p>
<p><span class="math display">O(\frac{n^3}{3}+\frac{n(n-1)}{2})\tag{2}</span></p>
<p>ただし各項の中で最高次の係数だけを考えればよいので, ガウスの消去法の時間計算量は</p>
<p><span class="math display">\frac{1}{3}O(n^3)</span></p>
<p>である.</p>
<h2 id="ガウスジョルダン法">ガウス・ジョルダン法</h2>
<p>ガウスの名がつく行列を用いた線形方程式の直接解法には, 今述べたガウスの消去法のほかにガウス・ジョルダン法というものがある. これらは明確に区別されたところであまり意味がないような気もするが, ガウスの消去法が上記のように係数行列となる部分を単位行列でない対角行列へと変形していったのに対し, ガウス・ジョルダン法はそれを直接単位行列となるように変形していく点で異なる. ガウス・ジョルダン法で同様にして計算していくと,</p>
<p><span class="math display">
\left(\begin{array}{cc|c}
1 &amp; 2 &amp; 3 \\
3 &amp; 4 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cc|c}
\overbrace{1}^{\times (-3)} &amp; \overbrace{2}^{\times (-3)} &amp; \overbrace{3}^{\times (-3)} \\
\underline{3} &amp; 4 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cc|c}
1 &amp; 2 &amp; 3 \\
0 &amp; -2 &amp; -4
\end{array}\right)\to
\left(\begin{array}{cc|c}
1 &amp; 2 &amp; 3 \\
\overbrace{0}^{\times (-\frac{1}{2})} &amp; \overbrace{-2}^{\times (-\frac{1}{2})} &amp; \overbrace{-4}^{\times (-\frac{1}{2})}
\end{array}\right) \\ \to
\left(\begin{array}{cc|c}
1 &amp; 2 &amp; 3 \\
0 &amp; 1 &amp; 2
\end{array}\right)\to
\left(\begin{array}{cc|c}
1 &amp; \underline{2} &amp; 3 \\
\overbrace{0}^{\times (-2)} &amp; \overbrace{1}^{\times (-2)} &amp; \overbrace{2}^{\times (-2)}
\end{array}\right)\to
\left(\begin{array}{cc|c}
1 &amp; 0 &amp; -1 \\
0 &amp; 1 &amp; 2
\end{array}\right) \\
\therefore (x,y)=(-1,2)
</span></p>
<p>これは掃き出し法とも言われることがある. ガウス・ジョルダン法の計算量は <span class="math inline">\frac{1}{2}O(n^3)</span> なので(導出は省略), ガウス・ジョルダン法をわざわざ用いるシーンはあまりない.</p>
<h2 id="ピボッティング">ピボッティング</h2>
<p>ところで, いま示したガウスの消去法, ガウスジョルダン法の手順は, このままでは困る場合がある. 例えば, 次の線形方程式をガウスの消去法で解いてみると</p>
<p><span class="math display">
\left(\begin{array}{cccc|c}
1 &amp; 2 &amp; 7 &amp; 6 &amp; 6 \\
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
1 &amp; 8 &amp; 5 &amp; 2 &amp; 12 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cccc|c}
\overbrace{1}^{\times (-2)} &amp; \overbrace{2}^{\times (-2)} &amp; \overbrace{7}^{\times (-2)} &amp; \overbrace{6}^{\times (-2)} &amp; \overbrace{6}^{\times (-2)} \\
\underline{2} &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
1 &amp; 8 &amp; 5 &amp; 2 &amp; 12 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cccc|c}
1 &amp; 2 &amp; 7 &amp; 6 &amp; 6 \\
0 &amp; 0 &amp; -10 &amp; -10 &amp; -10 \\
1 &amp; 8 &amp; 5 &amp; 2 &amp; 12 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right) \\ \to
\left(\begin{array}{cccc|c}
\overbrace{1}^{\times (-1)} &amp; \overbrace{2}^{\times (-1)} &amp; \overbrace{7}^{\times (-1)} &amp; \overbrace{6}^{\times (-1)} &amp; \overbrace{6}^{\times (-1)} \\
0 &amp; 0 &amp; -10 &amp; -10 &amp; -10 \\
\underline{1} &amp; 8 &amp; 5 &amp; 2 &amp; 12 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cccc|c}
1 &amp; 2 &amp; 7 &amp; 6 &amp; 6 \\
0 &amp; 0 &amp; -10 &amp; -10 &amp; -10 \\
0 &amp; 6 &amp; -2 &amp; -4 &amp; 6 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cccc|c}
\overbrace{1}^{\times (-2)} &amp; \overbrace{2}^{\times (-2)} &amp; \overbrace{7}^{\times (-2)} &amp; \overbrace{6}^{\times (-2)} &amp; \overbrace{6}^{\times (-2)} \\
0 &amp; 0 &amp; -10 &amp; -10 &amp; -10 \\
0 &amp; 6 &amp; -2 &amp; -4 &amp; 6 \\
\underline{2} &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right) \\ \to
\left(\begin{array}{cccc|c}
1 &amp; 2 &amp; 7 &amp; 6 &amp; 6 \\
0 &amp; 0 &amp; -10 &amp; -10 &amp; -10 \\
0 &amp; 6 &amp; -2 &amp; -4 &amp; 6 \\
0 &amp; 0 &amp; -11 &amp; -9 &amp; -7
\end{array}\right)\to
\left(\begin{array}{cccc|c}
1 &amp; 2 &amp; 7 &amp; 6 &amp; 6 \\
0 &amp; \overbrace{0}^{\times (-\frac{6}{0})} &amp; \overbrace{-10}^{\times (-\frac{6}{0})} &amp; \overbrace{-10}^{\times (-\frac{6}{0})} &amp; \overbrace{-10}^{\times (-\frac{6}{0})} \\
0 &amp; \underline{6} &amp; -2 &amp; -4 &amp; 6 \\
0 &amp; 0 &amp; -11 &amp; -9 &amp; -7
\end{array}\right)
</span></p>
<p>というように <span class="math inline">0</span> で割るということが起きてしまうのである. これを防ぐために考えられる方法としては, 掃きだすのに利用する値がその列の中で絶対値最大となるように行を入れ替える. これは, 部分ピボット選択付きガウスの消去法といわれる. ピボットとは, いま述べた掃きだすのに利用する値のことである. 部分ピボット選択といわれる理由は, 入れ替えの操作が行に対してのみ行われるからである. 列に対する入れ替え操作をも含んだ方法は完全ピボット選択といわれるが, 当然それは行基本変形の範疇でないので, そのまま計算を続行して単に右辺ベクトルを取り出せばよいという話ではなくなる. 完全ピボット選択は, 絶対値最大の値の選択の余地が部分ピボット選択よりも当然広がるので, 直感的に, より大きな絶対値の値をピボットとして選択できる確率が上がることは考えられるだろう. しかしながら, このアドバンテージは当然行列に依存したものであり, プログラムの複雑度が上がることに釣り合っていないため, 実際に用いられるようなことはあまりないと思われる.</p>
というわけで, 下記に部分ピボット選択付きガウスの消去法による計算過程を省略することなく書き下したが, とくに面白みもない上に長いので隠しておいた. <em onclick="obj=document.getElementById('open_gaussian_piv_com').style; obj.display=(obj.display=='none')?'block':'none';"> <a style="font-style: normal; cursor:pointer;">クリックで展開.</a> </em>
<div id="open_gaussian_piv_com" style="display:none;clear:both;">
<p><span class="math display">
\left(\begin{array}{cccc|c}
1 &amp; 2 &amp; 7 &amp; 6 &amp; 6 \\
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
1 &amp; 8 &amp; 5 &amp; 2 &amp; 12 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
1 &amp; 2 &amp; 7 &amp; 6 &amp; 6 \\
1 &amp; 8 &amp; 5 &amp; 2 &amp; 12 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cccc|c}
\overbrace{2}^{\times(-\frac{1}{2})} &amp; \overbrace{4}^{\times(-\frac{1}{2})} &amp; \overbrace{4}^{\times(-\frac{1}{2})} &amp; \overbrace{2}^{\times(-\frac{1}{2})} &amp; \overbrace{2}^{\times(-\frac{1}{2})} \\
\underline{1} &amp; 2 &amp; 7 &amp; 6 &amp; 6 \\
1 &amp; 8 &amp; 5 &amp; 2 &amp; 12 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\\ \to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
1 &amp; 8 &amp; 5 &amp; 2 &amp; 12 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cccc|c}
\overbrace{2}^{\times(-\frac{1}{2})} &amp; \overbrace{4}^{\times(-\frac{1}{2})} &amp; \overbrace{4}^{\times(-\frac{1}{2})} &amp; \overbrace{2}^{\times(-\frac{1}{2})} &amp; \overbrace{2}^{\times(-\frac{1}{2})} \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
\underline{1} &amp; 8 &amp; 5 &amp; 2 &amp; 12 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 6 &amp; 3 &amp; 1 &amp; 11 \\
2 &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\\ \to
\left(\begin{array}{cccc|c}
\overbrace{2}^{\times (-1)} &amp; \overbrace{4}^{\times (-1)} &amp; \overbrace{4}^{\times (-1)} &amp; \overbrace{2}^{\times (-1)} &amp; \overbrace{2}^{\times (-1)} \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 6 &amp; 3 &amp; 1 &amp; 11 \\
\underline{2} &amp; 4 &amp; 3 &amp; 3 &amp; 5
\end{array}\right)\to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 6 &amp; 3 &amp; 1 &amp; 11 \\
0 &amp; 0 &amp; -1 &amp; 1 &amp; 3
\end{array}\right)\to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
0 &amp; 6 &amp; 3 &amp; 1 &amp; 11 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 0 &amp; -1 &amp; 1 &amp; 3
\end{array}\right) \\ \to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
0 &amp; 6 &amp; 3 &amp; 1 &amp; 11 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 0 &amp; -1 &amp; 1 &amp; 3
\end{array}\right)\to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
0 &amp; 6 &amp; 3 &amp; 1 &amp; 11 \\
0 &amp; 0 &amp; \overbrace{5}^{\times\frac{1}{5}} &amp; \overbrace{5}^{\times\frac{1}{5}} &amp; \overbrace{5}^{\times\frac{1}{5}} \\
0 &amp; 0 &amp; \underline{-1} &amp; 1 &amp; 3
\end{array}\right)\to
\underbrace{\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 2 &amp; 2 \\
0 &amp; 6 &amp; 3 &amp; 1 &amp; 11 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right)}_{上三角行列} \\ \to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; \underline{2} &amp; 2 \\
0 &amp; 6 &amp; 3 &amp; 1 &amp; 11 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 0 &amp; 0 &amp; \overbrace{2}^{\times(-1)} &amp; \overbrace{4}^{\times(-1)}
\end{array}\right) \to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 0 &amp; -2 \\
0 &amp; 6 &amp; 3 &amp; 1 &amp; 11 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right)\to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 0 &amp; -2 \\
0 &amp; 6 &amp; 3 &amp; \underline{1} &amp; 11 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 0 &amp; 0 &amp; \overbrace{2}^{\times (-\frac{1}{2})} &amp; \overbrace{4}^{\times (-\frac{1}{2})}
\end{array}\right) \\ \to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 0 &amp; -2 \\
0 &amp; 6 &amp; 3 &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; 5 &amp; 5 &amp; 5 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right)\to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 0 &amp; -2 \\
0 &amp; 6 &amp; 3 &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; 5 &amp; \underline{5} &amp; 5 \\
0 &amp; 0 &amp; 0 &amp; \overbrace{2}^{\times (-\frac{5}{2})} &amp; \overbrace{4}^{\times (-\frac{5}{2})}
\end{array}\right)\to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 4 &amp; 0 &amp; -2 \\
0 &amp; 6 &amp; 3 &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; 5 &amp; 0 &amp; -5 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right) \\ \to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; \underline{4} &amp; 0 &amp; -2 \\
0 &amp; 6 &amp; 3 &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; \overbrace{5}^{\times (-\frac{4}{5})} &amp; \overbrace{0}^{\times (-\frac{4}{5})} &amp; \overbrace{-5}^{\times (-\frac{4}{5})} \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right) \to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 0 &amp; 0 &amp; 2 \\
0 &amp; 6 &amp; 3 &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; 5 &amp; 0 &amp; -5 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right) \to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 0 &amp; 0 &amp; 2 \\
0 &amp; 6 &amp; \underline{3} &amp; 0 &amp; 9 \\
0 &amp; 0 &amp; \overbrace{5}^{\times (-\frac{3}{5})} &amp; \overbrace{0}^{\times (-\frac{3}{5})} &amp; \overbrace{-5}^{\times (-\frac{3}{5})} \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right) \\ \to
\left(\begin{array}{cccc|c}
2 &amp; 4 &amp; 0 &amp; 0 &amp; 2 \\
0 &amp; 6 &amp; 0 &amp; 0 &amp; 12 \\
0 &amp; 0 &amp; 5 &amp; 0 &amp; -5 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right) \to
\left(\begin{array}{cccc|c}
2 &amp; \underline{4} &amp; 0 &amp; 0 &amp; 2 \\
0 &amp; \overbrace{6}^{\times(-\frac{2}{3})} &amp; \overbrace{0}^{\times(-\frac{2}{3})} &amp; \overbrace{0}^{\times(-\frac{2}{3})} &amp; \overbrace{12}^{\times(-\frac{2}{3})} \\
0 &amp; 0 &amp; 5 &amp; 0 &amp; -5 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right) \to
\left(\begin{array}{cccc|c}
2 &amp; 0 &amp; 0 &amp; 0 &amp; -6 \\
0 &amp; 6 &amp; 0 &amp; 0 &amp; 12 \\
0 &amp; 0 &amp; 5 &amp; 0 &amp; -5 \\
0 &amp; 0 &amp; 0 &amp; 2 &amp; 4
\end{array}\right) \\
\therefore (-6\div 2,12\div 6, -5\div 0, 4\div 2)^T =(-3,2,-1,2)^T
</span></p>
</div>
<h2 id="lu-分解">LU 分解</h2>
<p>漸く本題の LU 分解(LR 分解, 三角分解)について. 簡単のために式 <span class="math inline">(1)</span> を使って LU 分解の導出をする. 式 <span class="math inline">(1)</span> は次の式と同値である.</p>
<p><span class="math display">
A^{(0)}\left(\begin{array}{c}x \\ y\end{array}\right)={\boldsymbol v}
\ {\rm where}\ A^{(0)}=\left(\begin{array}{cc}1 &amp; 2 \\ 3 &amp; 4\end{array}\right),{\boldsymbol v}=\left(\begin{array}{c}3\\ 5\end{array}\right)
</span></p>
<p><span class="math inline">{A^{(0)}}^{-1}{\boldsymbol v}</span> とすれば <span class="math inline">(x,y)^T</span> は求まるが, 逆行列の計算はガウスの消去法により <span class="math inline">\frac{1}{3}O(n^3)</span> の時間計算量がかかる. 一定の条件下でそれよりも高速に求める方法を考えることとする. いま <span class="math inline">A^{(0)}</span> を徐に上三角行列にすることを考えると, ガウスの消去法の前進消去より</p>
<p><span class="math display">
A^{(1)}=L^{(1)}A^{(0)}=\left(\begin{array}{cc}1 &amp; 2 \\ 0 &amp; -2\end{array}\right)
\leftrightarrow
A^{(0)}={L^{(1)}}^{-1}A^{(1)}
\ {\rm where}\ L^{(1)}=\left(\begin{array}{cc}1 &amp; 0 \\ -3 &amp; 1\end{array}\right)
</span></p>
<p>従って</p>
<p><span class="math display">
{L^{(1)}}^{-1}A^{(1)}\left(\begin{array}{c}x \\ y\end{array}\right)={\boldsymbol v}
</span></p>
<p>ここで, <span class="math inline">{\boldsymbol b}=A^{(1)}(x,y)^T</span> とおくと, 上の式は <span class="math inline">{L^{(1)}}^{-1}{\boldsymbol b}={\boldsymbol v}</span> と同値であり, この式を用いて <span class="math inline">{\boldsymbol b}</span> について解くことができる. まずこの時間計算量を考えるとする. <span class="math inline">L^{(1)}</span> は元々前進消去のための行列であり, それは必ず下三角行列である. 正則な下三角行列の逆行列は下三角行列であり(証明略), いま <span class="math inline">L^{(1)}</span> が正則であるとする(これが特異となるような場合には後述する PLU 分解が有効)と, その計算は前進代入(上記後退代入の下三角行列バージョンと考えればよい)を実行すればよいので, 時間計算量は <span class="math inline">\frac{1}{2}O(n^2)\ \because</span> となる.</p>
<p>その後に <span class="math inline">A^{(1)}(x,y)^T={\boldsymbol b}</span> を <span class="math inline">(x,y)^T</span> について解くわけであるが, <span class="math inline">A^{(1)}</span> は上三角行列であるので, その計算にはガウスの消去法の後退代入を実行すれば良く, 従ってその時間計算量は <span class="math inline">\frac{1}{2}O(n^2)\ \because</span> である.</p>
<p>よって, この一連の操作における時間計算量は <span class="math inline">\frac{1}{3}O(n^3)</span> であり, 部分ピボットつきガウスの消去法を実行した場合と変わらない.</p>
<p>しかし, <span class="math inline">L U</span> を流用できる(つまり, 共通の <span class="math inline">A^{(0)}</span> に対し異なる右辺ベクトル <span class="math inline">{\boldsymbol v}</span> から成る連立方程式を解く)とすればどうだろう. この場合, やらなければならない計算は前進代入および後退代入のみなので, 全体の時間計算量は <span class="math inline">\frac{1}{2}O(n^2)</span> となり, 先よりも高速に解を得ることができる.</p>
<p>いまの説明では, 式 \(\) において <span class="math inline">A^{(0)}</span> を <span class="math inline">{L^{(1)}}^{-1}</span> と <span class="math inline">A^{(1)}</span> に分解したが, これを LU 分解(<span class="math inline">L={L^{(1)}}^{-1},U=A^{(1)}</span>)といい, <span class="math inline">L^{(i)}</span> が正則ならば, 一般の場合においても同様にしていうことができる.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="LU">LU 分解 (外積形式ガウス法)</span>
</p>
</header>
<div class="m-def-content">
<p>すべての前進消去の行列 <span class="math inline">L^{(i)}</span> が正則ならば <span class="math inline">A\in\mathbb{R}^{m\times n}</span> に対する LU 分解は <span class="math display">A=A^{(0)}=L U\ {\rm where}\ L=\prod_{i=1}^{n-1}{L^{(i)}}^{-1}, U=A^{(n-1)}</span></p>
</div>
</div>
<p>補足すると, <span class="math inline">A^{(0)}</span> に対し <span class="math inline">n-1</span> 回の前進消去をするというのは, <span class="math inline">L^{(n-1)}\cdots L^{(2)}L^{(1)}A^{(0)}</span> ということであり, <span class="math inline">\lambda=L^{(n-1)}\cdots L^{(2)}L^{(1)}</span> とおくと <span class="math inline">\lambda A^{(0)}=U=A^{(n-1)}</span> だから <span class="math inline">A^{(0)}=\lambda^{-1}U</span>. ここで逆行列の公式 <span class="math inline">(X Y)^{-1}=Y^{-1} X^{-1}</span> より(証明略)上式となる. 一般論を得たところで, 実際に一つ LU 分解を実践してみることとする.</p>
<p><span class="math display">
A^{(0)}=
\left(\begin{array}{ccc}
3 &amp; 1 &amp; 0 \\
6 &amp; 1 &amp; -2 \\
-3 &amp; 0 &amp; 3
\end{array}\right)\to
\underbrace{\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
-2 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1
\end{array}\right)}_{L^{(1)}}
\left(\begin{array}{ccc}
3 &amp; 1 &amp; 0 \\
6 &amp; 1 &amp; -2 \\
-3 &amp; 0 &amp; 3
\end{array}\right)=
\underbrace{
\left(\begin{array}{ccc}
3 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; -2 \\
0 &amp; 1 &amp; 3
\end{array}\right)
}_{A^{(1)}} \\
\to
\underbrace{
\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 1
\end{array}\right)
}_{L^{(2)}}
A^{(1)}=
\underbrace{
\left(\begin{array}{ccc}
3 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; -2 \\
0 &amp; 0 &amp; 1
\end{array}\right)}_{A^{(2)}}
</span></p>
<p>より <span class="math display">L=(L^{(2)}L^{(1)})^{-1}=\left(\begin{array}{ccc} 1 &amp; 0 &amp; 0 \\ 2 &amp; 1 &amp; 0 \\ -1 &amp; -1 &amp; 1 \end{array}\right),U=A^{(2)}</span> 実際には, すべてを減算で考えることで, <span class="math inline">(L^{(2)}L^{(1)})^{-1}</span> の計算は楽に済む(つまり <span class="math inline">A^{0}=({\boldsymbol a_1}^T,{\boldsymbol a_2}^T,{\boldsymbol a_3}^T)^T</span> としたとき <span class="math inline">\underline{2}{\boldsymbol a_1}-{\boldsymbol a_2}, \underline{-1}{\boldsymbol a_1}-{\boldsymbol a_3}, \underline{-1}{\boldsymbol a_2}-{\boldsymbol a_3}</span> より <span class="math inline">L</span> が導けるということ).</p>
<p>この導出過程を見ればなんとなく LU 分解が一意となることは直感的にも納得できるが, 一応証明を与えておく.</p>
<div class="m-thm">
<header class="m-thm-title">
<span id="theorem1">
<p>
定理 1
</p>
</span>
</header>
<div class="m-thm-content">
<p>LU 分解された <span class="math inline">L,U</span> は一意に決まる</p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
定理 1
</p>
</header>
<div class="m-proof-content">
<p>正則行列 <span class="math inline">A</span> の LU 分解 <span class="math inline">A= L U</span> に対して <span class="math inline">A= L_{1}U_{1} = L_{2}U_{2} \leftrightarrow L_{2}^{-1}L_{1} = U_{2}U_{1}^{-1}</span> とおく. <span class="math inline">L</span> は元々下三角行列であり下三角行列の逆行列は下三角行列, また下三角行列の積は下三角行列だから <span class="math inline">L_{2}^{-1}L_{1}</span> は下三角行列である. <span class="math inline">U</span> は元々上三角行列であり上三角行列の逆行列は上三角行列, また上三角行列の積は上三角行列だから <span class="math inline">U_{2}U_{1}^{-1}</span> は上三角行列である. 従って, 両行列は上および下三角行列でなければならず, それを満たす唯一の行列は対角行列であり, <span class="math inline">L</span> の対角成分は元々 <span class="math inline">1</span> であるから <span class="math inline">L_{2}^{-1}L_{1} = I = U_{2}U_{1}^{-1}</span>. 故に <span class="math inline">L_{2}=L_{1}, U_{2}=U_{1}</span>.</p>
</div>
</div>
<p>次に, 次のような行列に対する LU 分解を考えてみる.</p>
<p><span class="math display">
\begin{aligned}
A=\left(\begin{array}{ccc}
0 &amp; 1 &amp; 0 \\
-8 &amp; 8 &amp; 1 \\
2 &amp; -2 &amp; 0
\end{array}\right)
\end{aligned}
</span></p>
<p>見てわかるように, 前進消去の段階で <span class="math inline">-8\div 0</span> となってしまい計算できない. しかし, これも部分ピボット選択付きガウスの消去法と同様に, 絶対値最大の値がピボットとなるように行を予め入れ替えておけば, 計算が続行できる. そのような手続きのある LU 分解は PLU 分解といわれ, 置換行列 <span class="math inline">P\in\mathbb{R}^{m\times n}</span> をつかって, <span class="math inline">A=P L U</span> とする. 以下 <span class="math inline">A</span> をつかって導出してみることとする. <span class="math inline">{\boldsymbol a_1}^T</span> と <span class="math inline">{\boldsymbol a_2}^T</span> を入れ替えれば良いので,</p>
<p><span class="math display">
\begin{aligned}
\underbrace{\left(\begin{array}{ccc}
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right)}_{P^{(1)}}A=
\underbrace{\left(\begin{array}{ccc}
-8 &amp; 8 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
2 &amp; -2 &amp; 0
\end{array}\right)}_{A'}\to
\underbrace{\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
\frac{1}{4} &amp; 0 &amp; 1
\end{array}\right)}_{L^{(1)}}A'=
\underbrace{\left(\begin{array}{ccc}
-8 &amp; 8 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; \frac{1}{4}
\end{array}\right)}_{A'^{(1)}}
\end{aligned}
</span></p>
<p>より</p>
<p><span class="math display">L = {L^{(1)}}^{-1}=\left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ -\frac{1}{4} &amp; 0 &amp; 1\end{array}\right),U={A'}^{(1)}</span></p>
<p>とおくと <span class="math inline">A'={L^{(1)}}^{-1}{A'}^{(1)}</span> だから</p>
<p><span class="math display">P^{(1)}A=L U</span></p>
<p><span class="math inline">P^{(1)}</span> は元々置換行列であるから正則であり, また直行行列でもある. すなわち <span class="math inline">{P=P^{(1)}}^{-1}={P^{(1)}}^T</span> とおけて</p>
<p><span class="math display">
\begin{aligned}
A&amp;=&amp;P L U\\
\left(\begin{array}{ccc}
0 &amp; 1 &amp; 0 \\
-8 &amp; 8 &amp; 1 \\
2 &amp; -2 &amp; 0
\end{array}\right)&amp;=&amp;
\left(\begin{array}{ccc}
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1
\end{array}\right)
\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
-\frac{1}{4} &amp; 0 &amp; 1
\end{array}\right)
\left(\begin{array}{ccc}
-8 &amp; 8 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; \frac{1}{4}
\end{array}\right)
\end{aligned}
</span></p>
<p>ここで <span class="math inline">{\boldsymbol a}\in\mathbb{R}^{n\times 1},{\boldsymbol v}\in\mathbb{R}^{n\times 1}</span> に対して <span class="math inline">P L U {\boldsymbol a}={\boldsymbol v}</span> というように, PLU 分解を用いて連立方程式解くことを考えると, <span class="math inline">L\underbrace{(U{\boldsymbol a})}_{{\boldsymbol b}}=P^{-1}{\boldsymbol v}</span> だから先と同様にまず前進代入によって <span class="math inline">{\boldsymbol b}</span> を求め(このときの <span class="math inline">P^{-1}{\boldsymbol v}</span> は <span class="math inline">P^{-1}=P^{(1)}</span> であり, また置換行列であるので, その計算は単に <span class="math inline">{\boldsymbol v}</span> を並び替えるだけである), <span class="math inline">U{\boldsymbol a}={\boldsymbol b}</span> を <span class="math inline">{\boldsymbol a}</span> について後退代入によって求めればよい.</p>
<p>さて, 数学的な言葉では, 以上のように書き下すことで十分であるが, これをプログラムで組むことを考えると, 様々な工夫やアプローチが考えられる. まず <span class="math inline">L, U</span> はそれぞれ必ず上三角行列, 下三角行列であり <span class="math inline">0</span> や <span class="math inline">1</span> の部分をそのまま持っているのは無駄である. 従って <span class="math inline">L, U</span> の値は次のように一つの行列として持っておけば十分.</p>
<p><span class="math display">
\left(\begin{array}{ccc}
-8 &amp; 8 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
-\frac{1}{4} &amp; 0 &amp; \frac{1}{4}
\end{array}\right)
</span></p>
また, 置換行列 <span class="math inline">P</span> はただの並び替えでなので, これも各インデックスへの対応関係をテーブルにでもしておけば十分. サンプル実装, 実行例を下記に示す. Haskell で書いたわけだが, 普通の ST モナドによる実装とリストによる実装をそれぞれ行った. <em onclick="obj=document.getElementById('open_lu').style; obj.display=(obj.display=='none')?'block':'none';"> <a style="font-style: normal; cursor:pointer;">クリックで実装を開く.</a> </em>
<div id="open_lu" style="display:none;clear:both;">
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2FPlayLinearAlgebra%2Fblob%2F7a387f803e1ee30d3e7e83915b88eea18d7e096b%2Fsrc%2FMath%2FMatrix%2FCore.hs%23L139-L217&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span>m <span class="dt">Data.Array</span> <span class="dt">Math.Matrix.LU</span></span>
<span id="cb1-2"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-2" aria-hidden="true"></a>λ<span class="op">&gt;</span> lu [[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>],[<span class="op">-</span><span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="op">-</span><span class="dv">2</span>,<span class="dv">0</span>]]<span class="ot"> ::</span> <span class="dt">Maybe</span> (<span class="dt">PLU</span> <span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Double</span>)</span>
<span id="cb1-3"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-3" aria-hidden="true"></a><span class="dt">Just</span> (array (<span class="dv">0</span>,<span class="dv">2</span>) [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">2</span>,<span class="dv">2</span>)],</span>
<span id="cb1-4"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-4" aria-hidden="true"></a>{       <span class="op">-</span><span class="fl">8.0</span>    <span class="fl">8.0</span>     <span class="fl">1.0</span>     }</span>
<span id="cb1-5"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-5" aria-hidden="true"></a>{       <span class="op">-</span><span class="fl">0.0</span>    <span class="fl">1.0</span>     <span class="fl">0.0</span>     }</span>
<span id="cb1-6"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-6" aria-hidden="true"></a>{       <span class="op">-</span><span class="fl">0.25</span>   <span class="fl">0.0</span>     <span class="fl">0.25</span>    }</span>
<span id="cb1-7"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-7" aria-hidden="true"></a>)</span>
<span id="cb1-8"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-8" aria-hidden="true"></a>λ<span class="op">&gt;</span> luST' [[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>],[<span class="op">-</span><span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="op">-</span><span class="dv">2</span>,<span class="dv">0</span>]]<span class="ot"> ::</span> <span class="dt">Maybe</span> (<span class="dt">PLU</span> <span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Double</span>)</span>
<span id="cb1-9"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-9" aria-hidden="true"></a><span class="dt">Just</span> (array (<span class="dv">0</span>,<span class="dv">2</span>) [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">0</span>),(<span class="dv">2</span>,<span class="dv">2</span>)],</span>
<span id="cb1-10"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-10" aria-hidden="true"></a>{       <span class="op">-</span><span class="fl">8.0</span>    <span class="fl">8.0</span>     <span class="fl">1.0</span>     }</span>
<span id="cb1-11"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-11" aria-hidden="true"></a>{       <span class="op">-</span><span class="fl">0.0</span>    <span class="fl">1.0</span>     <span class="fl">0.0</span>     }</span>
<span id="cb1-12"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-12" aria-hidden="true"></a>{       <span class="op">-</span><span class="fl">0.25</span>   <span class="fl">0.0</span>     <span class="fl">0.25</span>    }</span>
<span id="cb1-13"><a href="/roki.log/2019/01/1/lu_decomposition/#cb1-13" aria-hidden="true"></a>)</span></code></pre></div>
連立方程式を解く. <em onclick="obj=document.getElementById('open_resolveLinearEq').style; obj.display=(obj.display=='none')?'block':'none';"> <a style="font-style: normal; cursor:pointer;">クリックで実装を開く.</a> </em>
<div id="open_resolveLinearEq" style="display:none;clear:both;">
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2FPlayLinearAlgebra%2Fblob%2F7a387f803e1ee30d3e7e83915b88eea18d7e096b%2Fsrc%2FMath%2FMatrix%2FCore.hs%23L259-L305&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> resolveLinearEq' [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">7</span>,<span class="dv">6</span>],[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">5</span>,<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">3</span>]] [<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">12</span>,<span class="dv">5</span>]<span class="ot"> ::</span> <span class="dt">Maybe</span> (<span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Rational</span>)</span>
<span id="cb2-2"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-2" aria-hidden="true"></a><span class="dt">Just</span> (array (<span class="dv">0</span>,<span class="dv">3</span>) [(<span class="dv">0</span>,(<span class="op">-</span><span class="dv">3</span>) <span class="op">%</span> <span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span> <span class="op">%</span> <span class="dv">1</span>),(<span class="dv">2</span>,(<span class="op">-</span><span class="dv">1</span>) <span class="op">%</span> <span class="dv">1</span>),(<span class="dv">3</span>,<span class="dv">2</span> <span class="op">%</span> <span class="dv">1</span>)])</span>
<span id="cb2-3"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> plu <span class="ot">=</span> luST' [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">7</span>,<span class="dv">6</span>],[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">5</span>,<span class="dv">2</span>],[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">3</span>]]<span class="ot"> ::</span> <span class="dt">Maybe</span> (<span class="dt">PLU</span> <span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Double</span>)</span>
<span id="cb2-4"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> plu</span>
<span id="cb2-5"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-5" aria-hidden="true"></a><span class="dt">Just</span> (array (<span class="dv">0</span>,<span class="dv">3</span>) [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">3</span>,<span class="dv">3</span>)],</span>
<span id="cb2-6"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-6" aria-hidden="true"></a>{       <span class="fl">2.0</span>     <span class="fl">4.0</span>     <span class="fl">4.0</span>     <span class="fl">2.0</span>     }</span>
<span id="cb2-7"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-7" aria-hidden="true"></a>{       <span class="fl">0.5</span>     <span class="fl">6.0</span>     <span class="fl">3.0</span>     <span class="fl">1.0</span>     }</span>
<span id="cb2-8"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-8" aria-hidden="true"></a>{       <span class="fl">0.5</span>     <span class="fl">0.0</span>     <span class="fl">5.0</span>     <span class="fl">5.0</span>     }</span>
<span id="cb2-9"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-9" aria-hidden="true"></a>{       <span class="fl">1.0</span>     <span class="fl">0.0</span>     <span class="op">-</span><span class="fl">0.2</span>    <span class="fl">2.0</span>     }</span>
<span id="cb2-10"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-10" aria-hidden="true"></a>)</span>
<span id="cb2-11"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-11" aria-hidden="true"></a>λ<span class="op">&gt;</span> fromJust plu <span class="ot">`assign`</span> (listArray (<span class="dv">0</span>, <span class="dv">3</span>) [<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">12</span>,<span class="dv">5</span>])<span class="ot"> ::</span> <span class="dt">Maybe</span> (<span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Double</span>)</span>
<span id="cb2-12"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-12" aria-hidden="true"></a><span class="dt">Just</span> (array (<span class="dv">0</span>,<span class="dv">3</span>) [(<span class="dv">0</span>,<span class="op">-</span><span class="fl">3.0</span>),(<span class="dv">1</span>,<span class="fl">2.0</span>),(<span class="dv">2</span>,<span class="op">-</span><span class="fl">1.0</span>),(<span class="dv">3</span>,<span class="fl">2.0</span>)])</span>
<span id="cb2-13"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-13" aria-hidden="true"></a>λ<span class="op">&gt;</span> fromJust plu <span class="ot">`assign`</span> (listArray (<span class="dv">0</span>, <span class="dv">3</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>])<span class="ot"> ::</span> <span class="dt">Maybe</span> (<span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Double</span>)</span>
<span id="cb2-14"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-14" aria-hidden="true"></a><span class="dt">Just</span> (array (<span class="dv">0</span>,<span class="dv">3</span>) [(<span class="dv">0</span>,<span class="fl">0.6666666666666667</span>),(<span class="dv">1</span>,<span class="fl">0.6666666666666666</span>),(<span class="dv">2</span>,<span class="op">-</span><span class="fl">1.0</span>),(<span class="dv">3</span>,<span class="fl">1.0</span>)])</span>
<span id="cb2-15"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-15" aria-hidden="true"></a>λ<span class="op">&gt;</span> fromJust plu <span class="ot">`assign`</span> (listArray (<span class="dv">0</span>, <span class="dv">3</span>) [<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>])<span class="ot"> ::</span> <span class="dt">Maybe</span> (<span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Double</span>)</span>
<span id="cb2-16"><a href="/roki.log/2019/01/1/lu_decomposition/#cb2-16" aria-hidden="true"></a><span class="dt">Just</span> (array (<span class="dv">0</span>,<span class="dv">3</span>) [(<span class="dv">0</span>,<span class="fl">1.666666666666667</span>),(<span class="dv">1</span>,<span class="fl">0.8666666666666667</span>),(<span class="dv">2</span>,<span class="op">-</span><span class="fl">0.8</span>),(<span class="dv">3</span>,<span class="fl">1.2</span>)])</span></code></pre></div>
ところで, LU 分解をしておくと逆行列も簡単に求めることがすぐに示せる. 逆行列とはそもそも <span class="math inline">A A^{-1} =I</span> であり, <span class="math inline">A^{-1}=({\boldsymbol a^{-1}_1},{\boldsymbol a^{-1}_2},\cdots,{\boldsymbol a^{-1}}_m), I=({\boldsymbol I_1},{\boldsymbol I_2},\cdots,{\boldsymbol I_m})</span> とすると行列の積の定義より <span class="math inline">A {\boldsymbol a^{-1}_i}={\boldsymbol I_i}\ {\rm where\ } i\in\mathbb{Z}^{+}, 1\leq i\leq m</span> だから, <span class="math inline">A=L U</span> と分解して <span class="math inline">1</span> から <span class="math inline">m</span> までのすべての <span class="math inline">{\boldsymbol a^{-1}}_i</span> を得てそれらをそのまま 1 つの行列とすればよい. 当然ながら, 構成される方程式のうち変わる部分は <span class="math inline">{\boldsymbol a^{-1}}_i</span> と <span class="math inline">I_i</span> の部分だけなので, LU 分解は一度行うだけで済む. プログラムでの実行例. <em onclick="obj=document.getElementById('open_inverse').style; obj.display=(obj.display=='none')?'block':'none';"> <a style="font-style: normal; cursor:pointer;">クリックで実装を開く.</a> </em>
<div id="open_inverse" style="display:none;clear:both;">
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2FPlayLinearAlgebra%2Fblob%2F7a387f803e1ee30d3e7e83915b88eea18d7e096b%2Fsrc%2FMath%2FMatrix%2FCore.hs%23L307-L324&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="/roki.log/2019/01/1/lu_decomposition/#cb3-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> inverse' [[<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">3</span>],[<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">1</span>]]<span class="ot"> ::</span> <span class="dt">Maybe</span> (<span class="dt">Matrix</span> <span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Rational</span>)</span>
<span id="cb3-2"><a href="/roki.log/2019/01/1/lu_decomposition/#cb3-2" aria-hidden="true"></a><span class="dt">Just</span></span>
<span id="cb3-3"><a href="/roki.log/2019/01/1/lu_decomposition/#cb3-3" aria-hidden="true"></a>{       <span class="dv">1</span> <span class="op">%</span> <span class="dv">2</span>   (<span class="op">-</span><span class="dv">1</span>) <span class="op">%</span> <span class="dv">2</span>        <span class="dv">1</span> <span class="op">%</span> <span class="dv">1</span>   }</span>
<span id="cb3-4"><a href="/roki.log/2019/01/1/lu_decomposition/#cb3-4" aria-hidden="true"></a>{       <span class="dv">1</span> <span class="op">%</span> <span class="dv">2</span>   <span class="dv">1</span> <span class="op">%</span> <span class="dv">2</span>   (<span class="op">-</span><span class="dv">2</span>) <span class="op">%</span> <span class="dv">1</span>        }</span>
<span id="cb3-5"><a href="/roki.log/2019/01/1/lu_decomposition/#cb3-5" aria-hidden="true"></a>{       (<span class="op">-</span><span class="dv">1</span>) <span class="op">%</span> <span class="dv">1</span>        <span class="dv">1</span> <span class="op">%</span> <span class="dv">1</span>   (<span class="op">-</span><span class="dv">1</span>) <span class="op">%</span> <span class="dv">1</span>        }</span></code></pre></div>
<p>ただし, 逆行列の計算には今述べたようにすべての <span class="math inline">{\boldsymbol I^{-1}}_i</span> に関して代入操作を行わなければならないので, <span class="math inline">A{\boldsymbol x}={\boldsymbol v}</span> といった方程式を解く目的で逆行列 <span class="math inline">A^{-1}</span> を求めることはただの愚行である.</p>
また, LU 分解は行列式の計算も簡単にする. <span class="math inline">A= L U</span> ならば積の行列式は行列式の積(証明略)なので <span class="math inline">\left|A\right|=\left|L U\right|=\left|L\right|\left|U\right|</span> であるが, 上および下三角行列の行列式は対角成分の積(証明略)であるので <span class="math inline">\left|L\right|=1</span> である. よって <span class="math inline">\left|A\right|=\prod_{i=1}^{n}{\boldsymbol u}_{ii}</span> である. 置換行列 <span class="math inline">P</span> を考慮すれば, いま <span class="math inline">S</span> を LU 分解の過程で行の入れ替えを行った回数としたとき, <span class="math inline">\left|A\right|=\left|P\right|\left|L\right|\left|U\right|=(-1)^S \prod_{i=1}^{n}{\boldsymbol u}_{ii}</span> となる. また, 後述する Crout 法では <span class="math inline">U</span> のすべての対角成分を <span class="math inline">1</span> とするので, その場合 <span class="math inline">\left|A\right| = (-1)^S \prod_{i=1}^{n}{\boldsymbol l}_{ii}</span> となる. <em onclick="obj=document.getElementById('open_det').style; obj.display=(obj.display=='none')?'block':'none';"> <a style="font-style: normal; cursor:pointer;">クリックで実装を開く.</a> </em>
<div id="open_det" style="display:none;clear:both;">
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2FPlayLinearAlgebra%2Fblob%2F7a387f803e1ee30d3e7e83915b88eea18d7e096b%2Fsrc%2FMath%2FMatrix%2FCore.hs%23L327-L340&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="/roki.log/2019/01/1/lu_decomposition/#cb4-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> determinant <span class="op">$</span> toMat <span class="op">$</span> listArray ((<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">2</span>,<span class="dv">2</span>)) [<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">1</span>]</span>
<span id="cb4-2"><a href="/roki.log/2019/01/1/lu_decomposition/#cb4-2" aria-hidden="true"></a><span class="fl">2.0</span></span>
<span id="cb4-3"><a href="/roki.log/2019/01/1/lu_decomposition/#cb4-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> determinant <span class="op">$</span> toMat <span class="op">$</span> listArray ((<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">3</span>,<span class="dv">3</span>)) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">3</span>]</span>
<span id="cb4-4"><a href="/roki.log/2019/01/1/lu_decomposition/#cb4-4" aria-hidden="true"></a><span class="fl">120.0</span></span></code></pre></div>
<p>なお, LU 分解は LDU 分解ともいわれることがある. その場合, 上記の <span class="math inline">U</span> に含まれる対角成分を対角行列 <span class="math inline">D</span> に分離して <span class="math inline">A = L D U</span> とする.</p>
<p><span class="math display">
L D U=
\left(\begin{array}{cccc}
1 &amp; 0 &amp; \cdots &amp; 0 \\
l_{21} &amp; 1 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
l_{m1} &amp; l_{m2} &amp; \cdots &amp; 1
\end{array}\right)
\mathrm{diag}(d_1,\cdots,d_m)
\left(\begin{array}{cccc}
1 &amp; u_{12} &amp; \cdots &amp; u_{1n} \\
0 &amp; 1 &amp; \cdots &amp; u_{2n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 
0 &amp; 0 &amp; \cdots &amp; 1
\end{array}\right)
</span></p>
<p>ところで, <span class="math inline">A\in\mathbb{R}^{m\times n}</span> が対称行列ならば, この LDU 分解は <span class="math inline">A=L D L^{T}</span> と計算することができる.</p>
<div class="m-thm">
<header class="m-thm-title">
<p>
<span id="theorem2">定理 2</span>
</p>
</header>
<div class="m-thm-content">
<p><span class="math inline">A=A^T\ {\rm where}\ A\in\mathbb{R}^{m\times n}</span> ならば <span class="math inline">A</span> の LDU 分解は <span class="math inline">A=L D L^{T}</span></p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
定理 2
</p>
</header>
<div class="m-proof-content">
<p><span class="math inline">M^T = D^{-1}U</span> とし <span class="math inline">A</span> の LDU 分解を <span class="math inline">A= L D M^T</span> とおくと <span class="math display">A = A^T = (L D M^T)^T = M D L^T = L U</span> ここで, 第二辺から第三辺への変形は, 積の転置は積の左右を入れ替えた転置の積なる公式を用いた. このとき <span class="math inline">M(D L^T)</span> と <span class="math inline">L U</span> は LU 分解の 2 つの表現であるが, <a href="/roki.log/2019/01/1/lu_decomposition/#theorem1">定理 1</a> より LU 分解は一意であるから <span class="math inline">M=L</span> でなければならない(後述する Crout 法の LU 分解ならば <span class="math inline">M=L D</span> でなければならない. 導かれる結論は同じ). 従って <span class="math inline">L D M^T = L D L^T</span>.</p>
</div>
</div>
<p>ここまで述べてきた LU 分解の方法は, 外積形式ガウス法といわれるものであるが, LU 分解の他の方法として内積形式ガウス法(以下 Doolittle 法), クラウト法がある. 簡単のために <span class="math inline">n=3</span> として, 行列 <span class="math inline">X</span> を次のように下三角行列 <span class="math inline">L\in\mathbb{R}^{3\times 3}</span> と上三角行列 <span class="math inline">U\in\mathbb{R}^{3\times 3}</span> に分解することを考える. このとき <span class="math inline">X = L' D U'</span> に対して <span class="math inline">L = L' D</span> とおいて <span class="math inline">X = L U'</span> というように分解できることを過程して行列 <span class="math inline">L,U'</span> を導出することを Doolittle 法, また <span class="math inline">U=D U'</span> とおいて <span class="math inline">X = L' U</span> というように分解できることを過程して行列 <span class="math inline">L' U</span> を導出することを Crout 法という.</p>
<p><span class="math display">
\begin{aligned}
X= L U'\leftrightarrow 
\left(\begin{array}{ccc}
x_{11} &amp; x_{12} &amp; x_{13} \\
x_{21} &amp; x_{22} &amp; x_{23} \\
x_{31} &amp; x_{32} &amp; x_{33}
\end{array}\right)=\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
l_{21} &amp; 1 &amp; 0 \\
l_{31} &amp; l_{32} &amp; 1
\end{array}\right)\left(\begin{array}{ccc}
u_{11} &amp; u_{12} &amp; u_{13} \\
0 &amp; u_{22} &amp; u_{23} \\
0 &amp; 0 &amp; u_{33}
\end{array}\right)&amp;:=&amp;{\rm Doolittle\ 法} \\
X= L' U\leftrightarrow 
\left(\begin{array}{ccc}
x_{11} &amp; x_{12} &amp; x_{13} \\
x_{21} &amp; x_{22} &amp; x_{23} \\
x_{31} &amp; x_{32} &amp; x_{33}
\end{array}\right)=\left(\begin{array}{ccc} 
l_{11} &amp; 0 &amp; 0 \\
l_{21} &amp; l_{22} &amp; 0 \\
l_{31} &amp; l_{32} &amp; l_{33} 
\end{array}\right)\left(\begin{array}{ccc}
1 &amp; u_{12} &amp; u_{13} \\
0 &amp; 1 &amp; u_{23} \\
0 &amp; 0 &amp; 1
\end{array}\right)&amp;:=&amp;{\rm Crout\ 法}
\end{aligned}
</span></p>
<p>いま行列 <span class="math inline">X</span> を Doolittle 法により LU 分解できたならば <span class="math inline">L U'</span> を単に計算して <span class="math inline">X=L U'</span> は次のようにかけるはずである.</p>
<p><span class="math display">
\left(\begin{array}{ccc}
u_{11} &amp; u_{12} &amp; u_{13} \\
l_{21}u_{11} &amp; l_{21}u_{12}+u_{22} &amp; l_{21}u_{13}+u_{23} \\
l_{31}u_{11} &amp; l_{31}u_{12}+l_{32}u_{22} &amp; l_{31}u_{13}+l_{32}u_{23}+u_{33}
\end{array}\right)=
\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
l_{21} &amp; 1 &amp; 0 \\
l_{31} &amp; l_{32} &amp; 1
\end{array}\right)\left(\begin{array}{ccc}
u_{11} &amp; u_{12} &amp; u_{13} \\
0 &amp; u_{22} &amp; u_{23} \\
0 &amp; 0 &amp; u_{33}
\end{array}\right)
</span></p>
<p>よって, 行列 <span class="math inline">X</span> の成分で行列 <span class="math inline">L, U'</span> を次のように書き換えることができる.</p>
<p><span class="math display">
\begin{aligned}
\left(\begin{array}{ccc}
x_{11} &amp; x_{12} &amp; x_{13} \\
x_{21} &amp; x_{22} &amp; x_{23} \\
x_{31} &amp; x_{32} &amp; x_{33} 
\end{array}\right)&amp;=&amp;
\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\ 
\frac{x_{21}}{u_{11}} &amp; 1 &amp; 0 \\
\frac{x_{31}}{u_{11}} &amp; l_{32} &amp; 1
\end{array}\right)
\left(\begin{array}{ccc}
u_{11} &amp; u_{12} &amp; u_{13} \\
0 &amp; u_{22} &amp; u_{23} \\
0 &amp; 0 &amp; u_{33}
\end{array}\right)\because
\begin{array}{l}
x_{21}=l_{21}u_{11}\leftrightarrow l_{21}=\frac{x_{21}}{u_{11}}, \\
l_{31}\ {\rm についても同様}
\end{array} \\
&amp;=&amp;
\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
\frac{x_{21}}{x_{11}} &amp; 1 &amp; 0 \\
\frac{x_{31}}{x_{11}} &amp; l_{32} &amp; 1
\end{array}\right)\left(\begin{array}{ccc}
x_{11} &amp; x_{12} &amp; x_{13} \\
0 &amp; u_{22} &amp; u_{23} \\
0 &amp; 0 &amp; u_{33}
\end{array}\right)\because\ u_{11}=x_{11},u_{12}=x_{12},u_{13}=x_{13} \\
&amp;=&amp; 
\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
\frac{x_{21}}{x_{11}} &amp; 1 &amp; 0 \\
\frac{x_{31}}{x_{11}} &amp; l_{32} &amp; 1
\end{array}\right)\left(\begin{array}{ccc}
x_{11} &amp; x_{12} &amp; x_{13} \\
0 &amp; x_{22}-\frac{x_{21}}{x_{11}}x_{12} &amp; x_{23}-\frac{x_{21}}{x_{11}}x_{13} \\
0 &amp; 0 &amp; u_{33} 
\end{array}\right)\because
\begin{array}{l}
x_{22}=l_{21}u_{12}+u_{22} \leftrightarrow u_{22}=x_{22}-l_{21}u_{12},\\
u_{23}\ {\rm についても同様}
\end{array} \\
&amp;=&amp; 
\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
\frac{x_{21}}{x_{11}} &amp; 1 &amp; 0 \\
\frac{x_{31}}{x_{11}} &amp; \frac{x_{32}-\frac{x_{31}}{x_{11}}x_{12}}{x_{22}-\frac{x_{21}}{x_{11}}x_{12}} &amp; 1
\end{array}\right)\left(\begin{array}{ccc}
x_{11} &amp; x_{12} &amp; x_{13} \\
0 &amp; x_{22}-\frac{x_{21}}{x_{11}}x_{12} &amp; x_{23}-\frac{x_{21}}{x_{11}}x_{13} \\
0 &amp; 0 &amp; x_{33}-\frac{x_{31}}{x_{11}}x_{13}-\frac{x_{32}-\frac{x_{31}}{x_{11}}x_{12}}{x_{22}-\frac{x_{21}}{x_{11}}x_{12}}(x_{23}-\frac{x_{21}}{x_{11}}x_{13})
\end{array}\right)\\
&amp;\because&amp;
\begin{array}{l}
x_{32}=l_{31}u_{12}+l_{32}u_{22}\leftrightarrow l_{32}=\frac{x_{32}-l_{31}u_{12}}{u_{22}}, \\
u_{33}\ {\rm についても同様}
\end{array}
\end{aligned}
</span></p>
<p>これをみると, 一行目, 一列目, 二行目, 二列目 <span class="math inline">\cdots</span> と展開していくことで, 芋づる式に <span class="math inline">L,U'</span> が決まっていくことがわかる. この作業を一般化すると, <span class="math inline">u_{ij}</span> の導出およびそれによって得られた値で <span class="math inline">l_{ij}</span> を導出する部分に分けることができる. それぞれをいま漸化式で書くと</p>
<p><span class="math display">
\begin{aligned}
{\rm Doolittle 法} &amp;:=&amp;
\begin{cases}
\begin{cases}
u_{1k}&amp;=&amp;x_{1k} \\
u_{ik}&amp;=&amp;x_{1k}-\sum^{i-1}_{j=1}l_{ij}u_{jk},\ (i=2,3,\cdots,k)
\end{cases} \\
l_{ik}=\frac{(x_{ik}-\sum^{k-1}_{j=1}l_{ij}u_{jk})}{u_{kk}},\ (i=k+1,k+2,\cdots,n)
\end{cases}
\end{aligned}
</span></p>
<p>ただし <span class="math inline">u_{kk}=0</span> の場合は計算できないので, 実際にはピボッティングを要することになるわけであるが, <span class="math inline">U</span> の <span class="math inline">k</span> 番目の行が <span class="math inline">L</span> の対応する列の前に計算されるという Doolittle 法の性質上, このままではどの行が <span class="math inline">k</span> 番目に来るのかを処理以前に知ることができない. この問題は <span class="math inline">l_{ik}</span> の分子を次のように計算することで自明に克服できる.</p>
<p><span class="math display">s_i = x_{ik}-\sum^{k-1}_{j=1}l_{ij}u_{jk},\ (i=k,\cdots,n)</span></p>
<p>これにより <span class="math inline">s_i</span> の最大値を求め, 対応する行を入れ替えて最大の要素を <span class="math inline">k</span> 行目に入れることができる. 交換後は <span class="math inline">u_{kk}=s_{k}</span> となるが, <span class="math inline">U</span> の <span class="math inline">k</span> 番目の行の他の要素はそれ以前と同様に計算することができ, 対応する <span class="math inline">L</span> の要素は <span class="math inline">l_{ik}=\frac{s_i}{u_{kk}}</span> と得られる.</p>
<p>Crout 法も同様に, <span class="math inline">X=L' U</span> を次のように書けるはずなので,</p>
<p><span class="math display">
\begin{aligned}
\left(\begin{array}{ccc}
l_{11} &amp; l_{11}u_{12} &amp; l_{11}u_{13} \\
l_{21} &amp; l_{21}u_{12}+l_{22} &amp; l_{21}u_{13}+l_{22}u_{23} \\
l_{31} &amp; l_{31}u_{12}+l_{32} &amp; l_{31}u_{13}+l_{32}u_{23}+l_{33}
\end{array}\right)=
\left(\begin{array}{ccc}
l_{11} &amp; 0 &amp; 0 \\
l_{21} &amp; l_{22} &amp; 0 \\
l_{31} &amp; l_{32} &amp; l_{33}
\end{array}\right)
\left(\begin{array}{ccc}
1 &amp; u_{12} &amp; u_{13} \\
0 &amp; 1 &amp; u_{23} \\
0 &amp; 0 &amp; 1
\end{array}\right)
\end{aligned}
</span></p>
<p>従ってこの作業の一般形は結果的に</p>
<p><span class="math display">
\begin{aligned}
{\rm Crout 法} &amp;:=&amp;
\begin{cases}
l_{ik}&amp;=&amp;x_{ik}-\sum^{k-1}_{j=1}l_{ij}u_{jk},\ (i=k,k+1,\cdots,n)\\
u_{kj}&amp;=&amp;\frac{(x_{kj}-\sum^{k-1}_{i=1}l_{ki}u_{ij})}{l_{kk}},\ (j=k,k+1,\cdots,n)
\end{cases}
\end{aligned}
</span></p>
<p><span class="math inline">L</span> の <span class="math inline">k</span> 番目の列の要素を計算した後に最大値を求め, <span class="math inline">L</span> の要素を含む最初の <span class="math inline">k-1</span> 列に対応する行列の行を交換できるため, Crout 法はピボットを簡単に選択できる.</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>Richard Hamming (1987) “Numerical Methods for Scientists and Engineers (Dover Books on Mathematics)” Dover Publications, ISBN 9780486652412</li>
</ul>]]></summary>
</entry>
<entry>
    <title>ニュートン法の視覚化</title>
    <link href="https://roki.dev/roki.log/2018/12/24/newtonRaphson/index.html" />
    <id>https://roki.dev/roki.log/2018/12/24/newtonRaphson/index.html</id>
    <published>2018-12-24T16:20:00Z</published>
    <updated>2018-12-24T16:20:00Z</updated>
    <summary type="html"><![CDATA[<p>久しぶりにまた<a href="/roki.log/2018/12/24/newtonRaphson/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>なにか d3.js で視覚化してみたくなったのだが, このエントリがポストされる次の日は<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%82%A4%E3%82%B6%E3%83%83%E3%82%AF%E3%83%BB%E3%83%8B%E3%83%A5%E3%83%BC%E3%83%88%E3%83%B3">アイザック・ニュートン</a>の誕生日らしいので, 今回はニュートン法 (Newton Raphson 法) を視覚化してみることにした. 早速であるが以下がその成果物である<a href="/roki.log/2018/12/24/newtonRaphson/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. <span class="math inline">f(x)=0</span> となる関数 <span class="math inline">f(x)</span> とその導関数 <span class="math inline">f'(x)</span> 及びニュートン法の初期値を受け付け, 実行をクリックすると関数とニュートン法の計算過程における接線がプロットされる. デフォルトでは, <span class="math inline">\sqrt{2}</span> の値を計算するように設定してある. 入力された関数を元に数値微分をしても良かったのだが, なんとなく導関数を入力したかったので, そのようなことはしなかった.</p>
<div id="vis" class="mb-4" style="width:400px; height: 310px; margin: 0 auto;">

</div>
<div class="content">
<div id="success_panel" class="message is-primary" style="display: none;">
<div class="message-header">
<p>
Success
</p>
</div>
<div class="message-body" style="text-align: center;">
<p id="success_message">
</p>
</div>
</div>
<div id="error_panel" class="message is-danger" style="display: none;">
<div class="message-header">
<p>
Fail
</p>
</div>
<div class="message-body" style="text-align: center;">
<p id="error_message">
</p>
</div>
</div>
<div id="formula" class="box has-text-centered is-shadowless">
<form class="form-inline text-center" role="form">
<div class="form-group">
<p><label><span class="math inline">f(x)=</span></label> <input id="func" type="text" class="input" style="max-width: 200px;" value="x^2-2" placeholder="e.g: x^2 - 2"></p>
</div>
<br>
<div class="form-group" style="margin-top: 10px;">
<p><label><span class="math inline">f'(x)=</span></label> <input id="func_differential" type="text" class="input" style="max-width: 200px;" value="2*x" placeholder="e.g: 2 * x"></p>
</div>
<br>
<div class="form-group" style="margin-top: 10px;">
<p><label>初期値: </label> <input id="initial_value" type="text" class="input" style="max-width: 200px;" value="5" placeholder="e.g: 5"></p>
</div>
<br> <input style="margin-top: 10px;" id="startNewtonRaph" class="button is-link is-light" type="button" value="実行" onclick="update()" />
</form>
</div>
</div>
<p><br /></p>
<!--more-->
<p>これで終わってしまうと何とも寂しいので, 一応簡単にニュートン法について書く. ニュートン法はとても有名な方程式の近似解を求める方法の 1 つである. 連続的関数<a href="/roki.log/2018/12/24/newtonRaphson/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> <span class="math inline">f(x)</span> が <span class="math inline">f(x)=0</span> となるような <span class="math inline">x</span> を求めるときに, 予め決めた, あるいは事前の計算で求まった切片 <span class="math inline">x_{n}</span> における関数 <span class="math inline">f(x)</span> への接線 <span class="math inline">f'(x_{n})</span> の切片 <span class="math inline">x_{n+1}</span> を用いて再帰的に <span class="math inline">f(x)=0</span> に近づけていくことで求める. 同手法は非常に単純ながらも効率的な近似解法であり, 同手法から発展されたいくつかの手法が考えられている. いまニュートン法の漸化式を導出することを考える. 計算で必要となるのは <span class="math inline">f'(x_{n})</span> に対する切片 <span class="math inline">x_{n+1}</span> であるから, いま三点 <span class="math inline">(x_{n},0), (x_{n},f(x_{n})), (x_{n+1}, 0)</span> の成す直角三角形について考えると, <span class="math inline">f'(x_{n})=\frac{(x_{n})}{x_{n}-x_{n+1}}</span> より <span class="math display">x_{n+1}=x_{n}-\frac{f(x_{n})}{f'(x_{n})}</span> 例えば <span class="math inline">\sqrt{2}</span> を例にとると, <span class="math inline">x^2=2\Leftrightarrow x^2-2=0</span> なので <span class="math inline">f(x)=x^2-2,f'(x)=2x</span> とおいて <span class="math inline">x_{n}-\frac{x^2_{n}-2}{2x_{n}}</span> を計算すればよい. なお <span class="math inline">f'(x_{n})</span> が <span class="math inline">0</span> であると, ゼロ除算になってしまうため計算することができない. この事実は, 傾きのない場合にどちらに進んでいけば良いのかわからないという直感的な考えにおいても筋が通る.</p>
<p>また, <span class="math inline">f(x)</span> の解が複数あるとき, 初期値によっては望まない解が導かれることがある. いま <span class="math inline">\sqrt{2}</span> の正の解を得たいとき, 初期値を <span class="math inline">-1</span> で実行してしまうと, 得られる解は <span class="math inline">-\sqrt{2}</span> となる. 直感的には決められた初期値の傾き <span class="math inline">f'(x_0)</span> によって近づいていく方向が定まってしまうからといえる. 従って同手法を適用する際は, できる限り求めたい解に近い初期値を設定するのが望ましい.</p>
<p>なおニュートン法は 1 変数関数のみならず多変数関数に対しても同様にして解を求めることができる. あまり厳密には書かないが, まずは簡単のために 2 変数の関数 <span class="math inline">f_{1}(x,y),f_{2}(x,y)</span> を用いてそれを示すこととする. <span class="math inline">f_{1}(x,y),f_{2}(x,y)</span> は曲面の定義そのものであり, この 2 つの曲面の交わる曲線を辿っていくことで解が求まる. 1 変数のニュートン法の場合と同様に漸化式を求めていけば, 多変数関数に対するニュートン法の漸化式も関数の値をその傾きで割る部分が出てくるが, いま変数は複数であるので, 各方向への微小変化に対する変化量を求める必要がある. これを求めるには<a href="/roki.log/2018/10/4/jacobian/">全微分</a>をすればよいので, 結局</p>
<p><span class="math display">
(x_{n+1},y_{n+1})=(x_{n},y_{n})^T-{\partial f(x_{n},y_{n})}^{-1}(f_{1}(x_{n}, y_{n}),f_{2}(x_{n},y_{n}))^T
</span></p>
<p>ここで</p>
<p><span class="math display">
\begin{aligned}\partial f(x,y):=
\left(\begin{array}{cc}
\frac{\partial f_{1}(x,y)}{\partial x} &amp; \frac{\partial f_{1}(x,y)}{\partial y} \\
\frac{\partial f_{2}(x,y)}{\partial x} &amp; \frac{\partial f_{2}(x,y)}{\partial y}
\end{array}\right)
\end{aligned}
</span></p>
<p>なお <span class="math inline">\partial f(x,y)</span> はヤコビ行列といわれる. 実際にコンピュータで計算する際には, <span class="math inline">{\partial f(x_{n},y_{n})}^{-1}(f_{1}(x_{n}, y_{n}),f_{2}(x_{n},y_{n}))^T</span> を求めるのは計算量と誤差の観点から見て困難なので, <span class="math inline">\partial f(x_{n},y_{n}){\boldsymbol a}=(f_{1}(x_{n}, y_{n}),f_{2}(x_{n},y_{n}))^T</span> を LU 分解などで解き <span class="math inline">(x_n,y_n)^T-{\boldsymbol a}</span> と解くことになる.</p>
<p>因みに, 上記で描画される接線は, 単純に ラグランジュの補完公式より <span class="math inline">y-y_{1}=\frac{y_{2}-y_{1}}{x_{2}-x_{1}}(x-x_{1})</span> を用いて描いている. 具体的には接線の関数を <span class="math inline">g(x^{\star})</span> としたとき, 接点と <span class="math inline">y_{2}=0</span> であるときの 2 点 <span class="math inline">(x,f(x)),(x-\frac{f(x)}{f'(x)},0)</span> を使って</p>
<p><span class="math display">
\begin{aligned}
g(x^{\star})&amp;=&amp;\frac{f(x)}{\frac{f(x)}{f'(x)}}(x^{\star}-x+\frac{f(x)}{f'(x)}) \\
&amp;=&amp;f'(x)(x^{\star}-x+\frac{f(x)}{f'(x)}) \\
&amp;=&amp;f'(x)x^{\star}-f'(x)x+f(x)
\end{aligned}
</span></p>
<p>と導ける.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>以前のエントリ, <a href="/roki.log/posts/2018/04/20/Bezier-curve/">ベジェ曲線</a>では d3.js を用いて二次ベジェ曲線が描かれていく過程を書いた.<a href="/roki.log/2018/12/24/newtonRaphson/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://github.com/falgon/roki.log/blob/gh-pages/js/newtonRaphson.js">実装</a>. ここで懺悔すると, 実はグラフの描画の実装についてはそこそこ手抜きをしている. 例えば解が第 1, 2 象限であるものの関数 <span class="math inline">f(x)</span> の値の多くが第 3, 4 象限にあると接線が見えない. 勿論計算結果そのものは影響しない.<a href="/roki.log/2018/12/24/newtonRaphson/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>連続性に関する論法 <span class="math inline">\to</span> <a href="/roki.log/2018/10/4/jacobian/#epsilonDelta-definitionOfLimit"><span class="math inline">\epsilon-\delta</span> 論法</a>.<a href="/roki.log/2018/12/24/newtonRaphson/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>確率論で用いられる言葉の整理</title>
    <link href="https://roki.dev/roki.log/2018/10/28/probabilityTerms/index.html" />
    <id>https://roki.dev/roki.log/2018/10/28/probabilityTerms/index.html</id>
    <published>2018-10-28T00:00:00Z</published>
    <updated>2018-10-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>当ブログ内では, 既に確率論の話題として<a href="/roki.log/2018/07/26/bayestheorem/">ベイズの定理</a>のエントリが存在するが, 今後同様にして確率論の話題を本ブログで取り上げる際に, 用語へのリファレンスを self-contained で張れるよう, 本エントリにて一度整理しておくこととした.</p>
<!--more-->
<h2 id="確率の定義">確率の定義</h2>
<p>そもそも一言に「確率」といえども, それは古典的確率, 統計的確率, 公理的確率というように大別できる.</p>
<h3 id="古典的確率">古典的確率</h3>
<p>古典的確率は, <span class="math inline">\Omega</span> の要素数といま注目している事象の場合の数の比を用いるもので, すべての事象が等確率で発生することを前提条件とする. 理想的なサイコロの出目の確率などがこれに当てはまる.</p>
<h3 id="統計的確率">統計的確率</h3>
<p>統計的確率は, 「<span class="math inline">\Omega</span> の部分集合 = 事象」の発生回数と, その試行回数の比を用いるもので, 打率などがこれに当てはまる.</p>
<h3 id="公理的確率">公理的確率</h3>
<p>公理的確率とは, 確率の公理により定義された確率であり, 同公理における理論体系上では各事象の発生する確率が異なるものをも扱うことができる. この確率の公理では集合論, 測度論の言葉が使われるが, 同理論に関して深堀りすると本エントリの主題から大きく逸れてしまうため, ここではあまり深くは触れずに持ち出すこととしている.</p>
<p>集合のあつまりを一般に集合族というが, 次に示すのはその 1 種である<a href="/roki.log/2018/10/28/probabilityTerms/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="CompletelyAdditiveClass"><span class="math inline">\sigma</span>-加法族</span>
</p>
</header>
<div class="m-def-content">
標本空間 <span class="math inline">\Omega</span> の部分集合族 <span class="math inline">\mathcal{F}</span> が次の 3 つの性質を満足するとき, <span class="math inline">\mathcal{F}</span> は <span class="math inline">\sigma</span>-加法族という.
<ol>
<li>
<span class="math inline">\emptyset\in \mathcal{F}</span>
</li>
<li>
<span class="math inline">A\in\mathcal{F}\Rightarrow A^{c}\in\mathcal{F}</span>
</li>
<li>
<span class="math inline">\displaystyle A_1,A_2,\cdots\in\mathcal{F}\Rightarrow \bigcup^{\infty}_{i=1}A_i \in\mathcal{F}</span>
</li>
</ol>
<p>ここで, <span class="math inline">A^{c}</span> は集合 <span class="math inline">A</span> の補集合.</p>
</div>
</div>
<p><span class="math inline">\sigma</span>-加法族は, 空集合と補集合, 加算無限個の集合の和集合について閉じることを要請し, 確率の公理は, この <span class="math inline">\sigma</span>-加法族の関数に対して次の条件を付与する.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="KolmogorovAxioms">コルモゴロフの公理</span>
</p>
</header>
<div class="m-def-content">
<span class="math inline">\sigma</span>-加法族 <span class="math inline">\mathcal{F}</span> 上の関数 <span class="math inline">P</span> が次の 3 つの性質を満足するとき, <span class="math inline">P</span> を確率関数という.
<ol>
<li>
<span class="math inline">0\leq P(A)\leq 1,\ ^\forall A\in\mathcal{F}</span>
</li>
<li>
<span class="math inline">P(\Omega) = 1</span>
</li>
<li>
<span class="math inline">A_1,A_2,\cdots\in\mathcal{F}</span> があって, <span class="math inline">\displaystyle \bigcap^{\infty}_{i=1}A_i = \emptyset</span>(互いに排反) <span class="math inline">\displaystyle\Rightarrow P(\bigcup_{i=1}^\infty A_i)=\sum_{i=1}^\infty P(A_i)</span>
</li>
</ol>
</div>
</div>
<p>可算無限個の事象が互いに排反な事象の和集合の値は, 各事象の値の和となる.</p>
<p>なお, 標本空間を <span class="math inline">\Omega ={x_1,x_2,\cdots,x_n}</span>, <span class="math inline">p_1,\dots,p_n</span> がそれぞれ <span class="math inline">\displaystyle 0\leq p_{i}\leq 1</span> で, <span class="math inline">\displaystyle \sum_{i=1}^{n}p_{i}=1</span> であるとき, <span class="math inline">\Omega</span> の部分集合 <span class="math inline">A</span> に対して関数 <span class="math inline">P</span> を <span class="math inline">P(A)=\displaystyle\sum_{{i\ |\ x_i\in A}}p_i</span> とすると <span class="math inline">P</span> は確率関数となるから, 統計的確率論の問題は公理的確率論の問題として扱うことができるといえ, 自ずと公理的確率論が統計的確率論の拡張であることがいえる.</p>
<h3 id="基本的な言葉">基本的な言葉</h3>
<div class="table-container">
<table class="table">
<thead>
<tr>
<th scope="col">
用語
</th>
<th scope="col">
意味
</th>
<th scope="col">
表現
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
標本空間
</td>
<td>
試行に付随して決まる, 試行の取りうるすべての結果から成る <span class="math inline">\emptyset</span> でない集合.
</td>
<td>
<span class="math inline">\Omega</span>
</td>
</tr>
<tr>
<td>
標本
</td>
<td>
標本空間の元. 試行の結果発生しうる個々の事柄.
</td>
<td>
<span class="math inline">\omega\in\Omega</span>
</td>
</tr>
<tr>
<td>
事象
</td>
<td>
標本空間の部分集合. 試行の結果発生しうる事柄.
</td>
<td>
<span class="math inline">A\subset\Omega</span>
</td>
</tr>
<tr>
<td>
確率変数
</td>
<td>
ある事象が確率的に取りうる数.
<ul>
<li>
確率変数 <span class="math inline">X</span> の取りうる値 <span class="math inline">x_1, x_2,\cdots</span> それぞれに対応する確率 <span class="math inline">p_1, p_2,\cdots</span> が存在する場合, 隣り合う数の間に値が存在しない確率変数(サイコロの出目など)をとくに離散型確率変数といい, 離散確率変数 <span class="math inline">X</span> がある値 <span class="math inline">x</span> をとるとき, 標本から実現値 <span class="math inline">\mathbb{R}</span> への関数 <span class="math inline">f(x)</span> を確率質量関数という.
</li>
<li>
離散型確率変数でない確率型変数を連続型確率変数という (<a href="/roki.log/2018/10/4/jacobian/#epsilonDelta-definitionOfLimit"><span class="math inline">\epsilon-\delta</span> 論法</a>で厳密に説明できる).
</li>
</ul>
</td>
<td>
<span class="math inline">X</span>
</td>
</tr>
<tr>
<td>
実現値
</td>
<td>
確率変数がとる具体的な値.
</td>
<td>
<span class="math inline">x_n</span>
</td>
</tr>
<tr>
<td>
確率分布
</td>
<td>
確率変数がある値となる確率, 又はある集合に属する確率を与える関数 (JIS 規格より).
</td>
<td>
<span class="math inline">P(A)</span>
</td>
</tr>
<tr id="iid">
<td>
「独立同一分布に従う」
</td>
<td>
確率変数 <span class="math inline">X_1,X_2,\cdots,X_n</span> が互いに<a href="/roki.log/2018/10/28/probabilityTerms/#isIndependence">独立</a>で, かつそれらが同一の確率分布に従うことをいう.
<ul>
<li>
注意されたいのが, 「独立同一分布」といわれる分布はない. この用例は, 「独立同一分布」という分布に従うというようにも捉えられるかもしれないが, そのような意味ではない.
</li>
<li>
<span class="math inline">\rm i.i.d</span> 標本 <span class="math inline">X_1,X_2,\cdots,X_n</span> の同時の確率密度関数は <span class="math inline">f(x_1,x_2,\cdots,x_n)=g(x_1)g(x_2)\cdots g(x_n)</span>.
</li>
</ul>
</td>
<td>
<span class="math inline">\rm i.i.d</span>, independent and identically distributed.
</td>
</tr>
<tr>
<td>
<ul class="min100">
<li>
算術平均
</li>
<li>
相加平均
</li>
<li>
単純平均
</li>
&lt;/ulL
</td>
<td>
全体の総和をそれらの個数で割った値. <span class="math inline">\displaystyle\dfrac{1}{n}\sum^{n}_{i=1}X_i</span>.
</td>
<td>
<ul>
<li>
確率変数 <span class="math inline">X</span> の平均: <span class="math inline">\overline{X}</span>
</li>
<li>
母平均: <span class="math inline">\mu</span>
</li>
</ul>
</td>
</tr>
<tr>
<td>
期待値
</td>
<td>
確率変数のとりうる値にそれが起こる確率を掛けた値の総和のこと(加重平均). すなわち, 確率変数 <span class="math inline">X</span> の取り得る値 <span class="math inline">x</span> に関する確率 <span class="math inline">P(x_i)</span> があって, <span class="math display">
\begin{cases}
\displaystyle\sum^{n}_{i=1}x_i P(x_i) &amp;:X {\rm は離散的確率変数}\\
\displaystyle\int^\infty_{-\infty} xP(x)dx &amp;:X {\rm は連続的確率変数}
\end{cases}</span>
<ul>
<li id="LinearityExpectedValue">
離散, 連続共に和の期待値は期待値の和(期待値の線形性)<a href="/roki.log/2018/10/28/probabilityTerms/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>: <span class="math inline">\displaystyle E\left[\sum_{i=1}^nX_i\right]=\sum_{i=1}^nE\left[X_i\right]</span>, 連続の場合も同様.
</li>
</ul>
<dl>
<dt>
離散
</dt>
<dd>
<ul>
<li>
<span class="math inline">n</span> 個の <span class="math inline">P(x_1),P(x_2),\cdots,P(x_n)</span> がすべて等しいとき <span class="math inline">P_i=\dfrac{1}{n}\ (1\leq i\leq n)</span> となり, <span class="math inline">\overline{X}</span> と等しくなる.
</li>
</ul>
</dd>
<dt>
連続
</dt>
<dd>
<ul>
<li>
<span class="math inline">f(x)=xP(x)</span> としたとき, <span class="math inline">f(x)</span> は確率密度関数といわれる.
</li>
<li>
連続型確率変数がある 1 点の値をとる確率は 0 である (0 でなければ, 連続量とはいえない: <span class="math inline">P(X=a)=\int^{a}_{a}f(x)dx=0</span>) から, 事象 <span class="math inline">X</span> の確率については <span class="math inline">a\leq X\leq b</span> と幅を持たせて表す必要がある. 従って, (連続量が表されたグラフを思い浮かべれば想像に容易いが)その <span class="math inline">[a,b]</span> 間の面積が求まれば, 事象 <span class="math inline">X</span> に対する確率が求まることとなるので, 事象 <span class="math inline">X</span> が <span class="math inline">a</span> 以上 <span class="math inline">b</span> 以下となる確率を <span class="math inline">P(a\leq X\leq b)=\int_a^bf(x)dx</span> とかける.
</li>
<li id="normalizationLaw">
<a href="/roki.log/2018/10/28/probabilityTerms/#KolmogorovAxioms">コルモゴロフの公理</a>より <span class="math inline">\int_{-\infty}^{\infty}f(x)dx=1</span> がいえ, これを規格化条件という.
</li>
<li id="consExpIsCons">
定数 <span class="math inline">a</span> の期待値は <span class="math inline">a</span> である: <span class="math inline">E\left[a\right]=\int^\infty_{-\infty}aP(x)dx=a\int^\infty_{-\infty}P(x)dx</span> だから <span class="math display">E\left[a\right]=a\tag{i}</span>
</li>
<li>
定数 <span class="math inline">a</span> と確率変数 <span class="math inline">X</span> の和の期待値は, 確率変数 <span class="math inline">X</span> の期待値に定数 <span class="math inline">a</span> を加えた値である: <span class="math inline">E\left[a+X\right]=\int^\infty_{-\infty}(a+x)P(x)dx=\int^\infty_{-\infty}aP(x)dx+\int^\infty_{-\infty}xP(x)dx</span> だから <span class="math display">E\left[a+X\right]=a+E\left[X\right]\tag{ii}</span>
</li>
<li>
定数 <span class="math inline">b</span> と確率変数 <span class="math inline">X</span> の積の期待値は, 確率変数 <span class="math inline">X</span> の期待値の <span class="math inline">b</span> 倍の値である: <span class="math inline">E\left[bX\right]=\int^\infty_{-\infty}bxP(x)dx=b\int^\infty_{-\infty}xP(x)dx</span> だから <span class="math display">E\left[bX\right]=bE\left[X\right]\tag{iii}</span>
</li>
<li>
定数 <span class="math inline">b</span> と確率変数の積に定数 <span class="math inline">a</span> を加えた値の期待値は, 確率変数 <span class="math inline">X</span> の期待値の <span class="math inline">b</span> 倍に <span class="math inline">a</span> を加えた値である: <span class="math inline">(i),(iii)</span> より <span class="math display">E\left[bX+a\right]=bE\left[X\right]+a\tag{iv}</span>
</ul>
</dd>
</dl>
</td>
<td>
<ul>
<li>
確率変数 <span class="math inline">X</span> の期待値: <span class="math inline">E\left[X\right]</span>
</li>
<li>
標本平均 <span class="math inline">\overline{X}</span> の期待値<a href="/roki.log/2018/10/28/probabilityTerms/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>: <span class="math inline">\mu</span>
</ul>
</td>
</tr>
<tr>
<td>
条件付き確率
</td>
<td>
ある事象が起きる条件のもとで, 別のある事象が起こる確率. <span class="math display">P(A\mid B)=\dfrac{P(A\cap B)}{P(B)}\ (\because P(A\cap B):=A\ {\rm および}\ B\ {\rm が発生する確率})</span>
<ul>
<li id="isIndependence">
2 つの事象の確率について, 相互が一方の事象の発生確率がもう一方の事象の発生確率に影響を与えないとき, これを独立であるという. すなわち <span class="math inline">P(A\mid B)=P(A)</span>
</li>
<li>
2 つの事象について, 一方の事象が発生したときに, もう一方の事象は発生しないことがいえるとき, これを排反であるという. すなわち <span class="math inline">P(A\mid B)=0</span>
</li>
<li id="MulTheoremConditionalProbability">
<span class="math inline">P(A\cap B)=P(B)P(A\mid B)</span> を条件付き確率の乗法定理という.
</li>
<li>
<a href="/roki.log/2018/07/26/bayestheorem">ベイズの定理</a>
</li>
</ul>
</td>
<td>
<span class="math inline">B</span> の下で <span class="math inline">A</span> が発生する確率: <span class="math inline">P(A\mid B)</span>
</td>
</tr>
<tr>
<td>
条件付き期待値
</td>
<td>
確率変数 <span class="math inline">X</span> の値が <span class="math inline">x</span> であるときの <span class="math inline">Y</span> の期待値. <span class="math inline">E\left[Y|X=x\right]</span> <span class="math display">E\left[Y|X=x\right]=\sum^{n}_{i=1}y_i\dfrac{P(Y=y_i,X=x)}{P(X=x)}</span>
<ul>
<li>
<span class="math inline">E\left[Y\right]=E\left[E\left[Y|X\right]\right]</span> が成りたつ<a href="/roki.log/2018/10/28/probabilityTerms/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.
</li>
</ul>
</td>
<td>
<span class="math inline">E\left[Y|X\right],\ E_Y\left[Y|X\right]</span>
</td>
</tr>
<tr>
<td>
条件付き分散
</td>
<td>
<span class="math inline">V[X\mid Y]=E[X^2\mid Y]-E[X\mid Y]^2</span>
<ul>
<li>
<span class="math inline">V\left[Y\right]=E\left[V\left[Y|X\right]\right]+V\left[E\left[Y|X\right]\right]</span> が成り立つ (証明略).
</li>
</ul>
</td>
<td>
<span class="math inline">V\left[Y|X\right],\ V_Y\left[Y|X\right]</span>
</td>
</tr>
<tr>
<td>
<ul class="min100">
<li>
規格化
</li>
<li>
正規化
</li>
</ul>
</td>
<td>
ある関数が規格化条件を満足するように定数倍すること. 平均を引いて, 標準偏差で割る (<span class="math inline">\dfrac{X-\mu}{\sigma}</span>)<a href="/roki.log/2018/10/28/probabilityTerms/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> こと.
<ul>
<li>
連続的確率変数を扱う場合にのみ使われる言葉.
</li>
<li>
例えば, <span class="math inline">f(x)=x</span> は <span class="math inline">[0,1]</span> 上で <span class="math inline">\int_0^1xdx=\dfrac{1}{2}</span> となってしまうため, 規格化条件を満たさないが, 全体を 2 倍して <span class="math inline">f(x)=2x</span> とすると, 全区間で積分して <span class="math inline">1</span> になるので規格化条件を満たす. 従って, <span class="math inline">f(x)=2x</span> は確率度関数となる.
</li>
</ul>
</td>
<td>
N/A
</td>
</tr>
<tr>
<td>
<ul class="min100">
<li>
分散
</li>
<li>
標本分散
</li>
</ul>
</td>
<td>
期待値とのずれを表す指標の 1 つ. ずれの総計で各々が相殺しないように二乗和をとり, その個数 <span class="math inline">n</span> で割った値. すなわち, <span class="math display">\dfrac{1}{n}\displaystyle\sum_{i=1}^n(X_i-E\left[X\right])^2=E\left[(X-E\left[X\right])^2\right]</span>
<ul>
<li>
ここで, 確率変数 <span class="math inline">X_1,X_2,\cdots,X_n</span> の確率分布がすべて等しいとき, <span class="math inline">\displaystyle\dfrac{1}{n}\sum^{n}_{i=1}(X_i-\overline{X})^2=\overline{X^2}-\overline{X}^2</span> と高校数学でよくみる形式でかける.
</li>
<li>
定数の分散は <span class="math inline">0</span> である: <span class="math inline">V\left[a\right]=E\left[(a-E\left[a\right])^2\right]=E\left[(a-a)^2\right]</span> だから <span class="math display">E\left[0\right]=0\tag{v}</span>
</li>
<li>
定数 <span class="math inline">a</span> と確率変数 <span class="math inline">X</span> の和の分散は, 確率変数 <span class="math inline">X</span> の分散である: <span class="math display">\begin{aligned}
V\left[a+X\right]&amp;=&amp;E\left[(a+X-E\left[a+X\right])^2\right] \\
&amp;=&amp;E\left[(a+X-E\left[a\right]-E\left[X\right])^2\right] \\
&amp;=&amp;E\left[(a+X-a-E\left[X\right])^2\right]\\
&amp;=&amp;E\left[(X-E\left[X\right])^2\right]
\end{aligned}</span> だから <span class="math display">V\left[a+X\right]=V\left[X\right]\tag{vi}</span>
</li>
<li>
定数 <span class="math inline">b</span> と確率変数 <span class="math inline">X</span> の積の分散は, 確率変数 <span class="math inline">X</span> の分散と <span class="math inline">b</span> の二乗の積である: <span class="math display">
\begin{aligned}
V\left[bX\right]&amp;=&amp;E\left[(bX-E\left[bX\right])^2\right] \\
&amp;=&amp;E\left[(bX-bE\left[X\right])^2\right] \\
&amp;=&amp;E\left[{b(X-E\left[X\right])}^2\right] \\
&amp;=&amp;E\left[b^2(X-E\left[X\right])^2\right] \\
&amp;=&amp;b^2E\left[(X-E\left[X\right])^2\right]
\end{aligned}</span> だから <span class="math display">V\left[bX\right]=b^2V\left[X\right]\tag{vii}</span>
</li>
<li>
定数 <span class="math inline">b</span> と確率変数 <span class="math inline">X</span> の積と <span class="math inline">a</span> の和の分散は, 確率変数 <span class="math inline">X</span> の分散と定数 <span class="math inline">b</span> の二乗の積である: <span class="math inline">{\rm (vi), (vii)}</span> より <span class="math display">V\left[bX+a\right]=b^2V\left[X\right]\tag{viii}</span>
</li>
</ul>
</td>
<td>
<ul>
<li>
確率変数 <span class="math inline">X</span> の分散: <span class="math inline">V\left[X\right]</span>
</li>
<li>
母集団の分散: <span class="math inline">\sigma^2</span>
</li>
<li>
標本分散: <span class="math inline">s^2</span>
</li>
<li>
標本平均の分散<a href="/roki.log/2018/10/28/probabilityTerms/#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>: <span class="math inline">V\left[\overline{X}\right]=\dfrac{\sigma^2}{n}</span>
</li>
</ul>
</td>
</tr>
<tr>
<td>
<ul>
<li>
分散
</li>
<li>
不偏分散
</li>
</ul>
</td>
<td>
標本数 <span class="math inline">n</span> で割ったのに対し, <span class="math inline">n-1</span> で割った値. 標本分散の期待値が母分散に等しくなるように補正したもの(詳細は<a href="/roki.log/2018/10/28/probabilityTerms/#unbiasedVariance">下記</a>): <span class="math inline">\displaystyle\dfrac{1}{n-1}\sum^n_{i=1}(X_i-E\left[X\right])^2</span>
</td>
<td>
<span class="math inline">U^2,\hat{\sigma}^2</span>
</td>
</tr>
<tr>
<td>
標準偏差
</td>
<td>
分散の計算で行われた二乗を外した形.
</td>
<td>
<span class="math inline">\sqrt{V[X]},\sigma,s</span>. 各記号は, 分散の記号と同様にして用いられる慣習がある.
</td>
</tr>
</tbody>
</table>
</div>
<h2 id="不偏分散">不偏分散</h2>
<p>上記の表で示した通り, 不偏分散は, 標本分散の期待値が母分散に等しくなるように補正したもののことをいう. 標本分散は, 標本のばらつきの指標を得ることが主な目的であったのに対して, 不偏分散は, 標本から母分散の推定値を得ることが主な目的であり, その点において両者は異なる. その目的に従って, 標本分散の期待値 <span class="math inline">E\left[s^2\right]</span> は, 母分散の <span class="math inline">\dfrac{n-1}{n}</span> 倍となっているという事実(<span class="math inline">E\left[s^2\right]=\dfrac{n-1}{n}\sigma^2\not =\sigma^2</span>)から, 標本分散を <span class="math inline">\dfrac{n}{n-1}</span> 倍する(しかしながら, サンプル数 <span class="math inline">n</span> が十分に大きいとき, 両者は近似的に等しくなることが<a href="/roki.log/2018/10/28/probabilityTerms/#lawOfLargeNumbers">大数の弱法則</a>よりいえる). この形が不偏分散である.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="unbiasedVariance">不偏分散</span>
</p>
</header>
<div class="m-def-content">
<span class="math display">\displaystyle\dfrac{1}{n-1}\sum^n_{i=1}(X_i-E\left[X\right])^2</span>
</div>
</div>
<div class="m-prop">
<header class="m-prop-title">
<p>
命題 1
</p>
</header>
<div class="m-prop-content">
<p><span class="math display">E\left[s^2\right]=\dfrac{n-1}{n}\sigma^2</span></p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
命題 1
</p>
</header>
<div class="m-proof-content">
<p>いま <span class="math inline">\rm i.i.d</span> 標本 <span class="math inline">X_1,X_2,\cdots,X_n</span> について考えると, この標本分散は上記の表で示した通り <span class="math inline">\displaystyle s^2=\overline{X^2}-\overline{X}^2=\dfrac{1}{n}\sum^{n}_{i=1}(X_i-\overline{X})^2</span> で, 母分散は <span class="math inline">\sigma^2=E\left[(X-\mu)^2\right]</span> である. ここで, <span class="math inline">X_i-\overline{X}=X_i-\mu-\overline{X}+\mu</span> とおくと,</p>
<p><span class="math display">
\begin{aligned}
&amp;=&amp;\dfrac{1}{n}\left[{(X_1-\mu)-(\overline{X}-\mu)}^2+\cdots+{(X_n-\mu)-(\overline{X}-\mu)}^2\right] \\
&amp;=&amp;\dfrac{1}{n}{(X_1-\mu)^2-2(X_1-\mu)(\overline{X}-\mu)+(\overline{X}-\mu)^2+\cdots+(X_n-\mu)^2-2(X_n-\mu)(\overline{X}-\mu)+(\overline{X}-\mu)^2} \\
&amp;=&amp;\dfrac{1}{n}\sum_{i=1}^n(X_i-\mu)^2-2\dfrac{1}{n}\sum_{j=1}^{n}(X_j-\mu)(\overline{X}-\mu)+(\overline{X}-\mu)^2 \\
&amp;=&amp;\dfrac{1}{n}\sum_{i=1}^n(X_i-\mu)^2-2(\overline{X}-\mu)^2+(\overline{X}-\mu)^2 \\
&amp;=&amp;\dfrac{1}{n}\sum_{i=1}^n(X_i-\mu)^2-(\overline{X}-\mu)^2 
\end{aligned}
</span></p>
<p>である. この期待値は</p>
<p><span class="math display">
\begin{aligned}
E\left[s^2\right]&amp;=&amp;\dfrac{1}{n}\sum_{i=1}^nE\left[(X_i-\mu)^2\right]-E\left[(\overline{X}-\mu)\right] \\
&amp;=&amp;\sigma^2-E\left[(\overline{X}-\mu)^2\right] \tag{1}
\end{aligned}
</span></p>
<p>で, \(\) の第二項は標本平均分散だから,</p>
<p><span class="math display">
\begin{aligned}
E\left[s^2\right]&amp;=&amp;\sigma^2-\dfrac{\sigma^2}{n}\\
&amp;=&amp;\dfrac{n-1}{n}\sigma^2
\end{aligned}
</span></p>
</div>
</div>
<h2 id="正規分布-ガウス分布">正規分布, ガウス分布</h2>
<figure>
<img src="/roki.log/2018/10/28/probabilityTerms/norm.png" title="正規分布/ガウス分布" width="350" alt /><figcaption>正規分布/ガウス分布</figcaption>
</figure>
<p>上図<a href="/roki.log/2018/10/28/probabilityTerms/#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>のような, 連続型の確率分布が左右対称である分布を正規分布といい, その陰関数は <span class="math inline">f(x)=\dfrac{1}{\sqrt{2\pi}}\exp(-\dfrac{1}{2}(\dfrac{x-\mu}{\sigma})^2)</span> であり, これを <span class="math inline">N(\mu,\sigma)</span> とも書く. また, その確率密度関数は</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="ProbabilityDensityFunctionOfTheNormalDistribution">正規分布の確率密度関数</span>
</p>
</header>
<div class="m-def-content">
標準偏差 <span class="math inline">\sigma</span>, 母平均 <span class="math inline">\mu</span>, 分散 <span class="math inline">\sigma^2</span> に対して, <span class="math display">f(x)=\dfrac{1}{\sqrt{2\pi}\sigma}\exp(-\dfrac{(x-\mu)^2}{2\sigma^2})\tag{2}</span>
</div>
</div>
<p>である.</p>
<p>また <span class="math inline">\mu=0,\sigma=1</span> である正規分布をとくに標準正規分布といい(上図青で描かれた分布がそれに該当する), その場合の陰関数は <span class="math inline">f(x)=\dfrac{1}{\sqrt{2\pi}}\exp(-\dfrac{1}{2}x^2)</span> となる. また, これを <span class="math inline">N(\mu,\sigma)=N(0,1)</span> とも書く. ここで一度, 式 \(\) が規格化条件を満たすことを確認する. 確認には, <a href="/roki.log/2018/09/26/GaussianIntegral/#SimilarGaussianIntegral1">ガウス積分の公式</a>を用いる.</p>
<div class="m-prop">
<header class="m-prop-title">
<p>
命題 2
</p>
</header>
<div class="m-prop-content">
<p><span class="math inline">(2)</span> は規格化条件を満たす.</p>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
命題 2
</p>
</header>
<div class="m-proof-content">
<p><span class="math inline">(2)</span> が規格化条件を満たすことは次の式を満たすことである. <span class="math display">\displaystyle\int_{-\infty}^{\infty}f(x)dx=\dfrac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^{\infty}\exp(-\dfrac{(x-\mu)^2}{2\sigma^2})dx</span></p>
<p>ここで, <span class="math inline">x-\mu=y</span> と変数変換すると <span class="math display">\dfrac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^{\infty}\exp(-\dfrac{y^2}{2\sigma^2})dy</span> この積分部分は<a href="/roki.log/2018/09/26/GaussianIntegral/#SimilarGaussianIntegral1">ガウス積分の公式</a>より, <span class="math inline">\sqrt{2\sigma^2\pi}</span> となり <span class="math inline">f(x)</span> を全区間で積分すると 1 となる. よって, <span class="math inline">(2)</span> は規格化条件を満たす.</p>
</div>
</div>
<p>正規分布においては, 区間 <span class="math inline">[-\sigma,\sigma]</span> を 1 シグマ区間という. 平均 <span class="math inline">\pm{1\sigma}</span> 内に収まる確率は <span class="math inline">68</span> %, 平均 <span class="math inline">\pm{2\sigma}</span> 内に収まる確率は <span class="math inline">95</span> %, 平均 <span class="math inline">\pm{3\sigma}</span> 内に収まる確率は <span class="math inline">99.7</span> % であると知られている.</p>
<h2 id="大数の法則">大数の法則</h2>
<p>大数の法則は,</p>
<div class="m-thm">
<header class="m-thm-title">
<p>
<span id="lawOfLargeNumbers">大数の法則</span>
</p>
</header>
<div class="m-thm-content">
期待値 <span class="math inline">\mu</span> の <span class="math inline">\rm i.i.d</span> 無限列 <span class="math inline">X_1,X_2,\cdots</span> の標本平均 <span class="math inline">\displaystyle\overline{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i</span> と定数 <span class="math inline">^\forall c\gt 0</span> に対して, <span class="math display">\lim_{n\to\infty}P(\left|\overline{X}_{n}-\mu\right|\gt c)=0</span> がいえる. これを大数の弱法則という. また <span class="math display"> P(\lim_{n\to\infty}\overline{X}_n=\mu)=1 </span> がいえる. これを大数の強法則という.
</div>
</div>
<p>である. なお, この法則を確率論の用語で, <span class="math inline">\overline{X}_n</span> が <span class="math inline">\mu</span> に確率収束するという. 端折って解釈すると, ある母集団から無作為抽出するサンプル数を十分に大きくしたとき, それらから成る標本の平均は, 母平均そのものとみなしてもよいという主張である. 例えば, サイコロの目の理論的な平均値は <span class="math inline">\frac{\sum^{6}_{i=1} i}{6}=3.5</span> であるが, サイコロを例えば 2 回降っただけではこの通りの平均値にならないかもしれない. しかしながら, これを無限回行えば, その平均は <span class="math inline">3.5</span> に限りなく近くということである. ここでは簡単のために大数の弱法則についてのみの証明とする. そのために, まずマルコフの不等式, チェビシェフの不等式の証明を行う.</p>
<div class="m-thm">
<header class="m-thm-title">
<p>
<span id="MarkovsInequality">マルコフの不等式</span>
</p>
</header>
<div class="m-thm-content">
任意の確率変数 <span class="math inline">X</span> と定数 <span class="math inline">c\gt 0</span> に対して, <span class="math display"> P(\left|X\right|\geq c)\leq \dfrac{E\left[\left|X\right|\right]}{c}</span>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
マルコフの不等式
</p>
</header>
<div class="m-proof-content">
<p><span class="math inline">X</span> を連続型確率変数とすると, 確率密度関数 <span class="math inline">f_X(x)</span> に対して,</p>
<p><span class="math display">
\begin{aligned}
cP(\left|X\right|\geq c)&amp;=&amp;c\int^{\infty}_{c}f_X(x)dx \\
&amp;\leq&amp;\int^{\infty}_{c}\left|x\right|f_X(x)dx \\
&amp;\leq&amp;\int^c_0\left|x\right|f_X(x)dx+\int^\infty_c\left|x\right|f_X(x)dx \\
&amp;=&amp;\int^\infty_0\left|x\right|f_X(x)dx \\ 
&amp;=&amp;E[\left|X\right|]
\end{aligned}
</span></p>
<p><span class="math inline">\therefore P(\left|X\right|\geq c)\leq\dfrac{E[\left|X\right|]}{c}</span>. <span class="math inline">X</span> が離散型確率変数である場合は総計により同様にして求まる.</p>
</div>
</div>
<div class="m-thm">
<header class="m-thm-title">
<p>
<span id="ChebyshevInequality">チェビシェフの不等式</span>
</p>
</header>
<div class="m-thm-content">
<span class="math inline">E[Y]=\mu,V[Y]=\sigma^2</span> とするとき, <span class="math inline">^\forall a\gt 0</span> に対して, <span class="math display">P(\left|Y-\mu\right|\geq a\sigma)\leq\dfrac{1}{a^2}\Leftrightarrow P(\left|Y-\mu\right|\geq a)\leq\dfrac{\sigma^2}{a^2}</span>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
チェビシェフの不等式
</p>
</header>
<div class="m-proof-content">
<p><a href="/roki.log/2018/10/28/probabilityTerms/#MarkovsInequality">マルコフの不等式</a>より, <span class="math inline">X=(Y-\mu)^2,c=a^2\sigma^2</span> とすると</p>
<p><span class="math display">\begin{aligned}
P((Y-\mu)^2\geq a^2\sigma^2)&amp;\leq&amp;\dfrac{E\left[(Y-\mu)^2\right]}{a^2\sigma^2} \\
&amp;=&amp;\dfrac{\sigma^2}{a^2\sigma^2} \\
&amp;=&amp;\dfrac{1}{a^2}
\end{aligned}
</span></p>
<p><span class="math inline">\therefore P(\left|Y-\mu\right|\geq a\sigma)\leq\dfrac{1}{a^2}</span>. <span class="math inline">c=a^2</span> とすると, 同様にして <span class="math inline">P(\left|Y-\mu\right|\geq a)\leq\dfrac{\sigma^2}{a^2}</span>.</p>
</div>
</div>
<p>準備が整ったので, 以下<a href="/roki.log/2018/10/28/probabilityTerms/#lawOfLargeNumbers">大数の弱法則</a>を証明する.</p>
<div class="m-proof">
<header class="m-proof-title">
<p>
大数の弱法則
</p>
</header>
<div class="m-proof-content">
<p>確率変数 <span class="math inline">\overline{Y}</span> を <span class="math inline">\rm i.i.d</span> 標本平均 <span class="math inline">\displaystyle\dfrac{1}{n}\sum_{i=1}^{n}Y_i</span> とすると, 期待値の線型性より <span class="math inline">E\left[\overline{Y}\right]=\mu,V\left[\overline{Y}\right]=\dfrac{\sigma^2}{n}</span>. ここで, <a href="/roki.log/2018/10/28/probabilityTerms/#ChebyshevInequality">チェビシェフの不等式</a>より <span class="math inline">P(\left|\overline{Y}-\mu\right|\geq a)\leq\dfrac{\dfrac{\sigma^2}{n}}{a^2}</span> だから, <span class="math inline">n\to\infty</span> のとき, 右辺は <span class="math inline">0</span> に収束する.</p>
</div>
</div>
<h2 id="中心極限定理">中心極限定理</h2>
<p>中心極限定理は</p>
<div class="m-thm">
<header class="m-thm-title">
<p>
<span id="centralLimitTheorem">中心極限定理</span>
</p>
</header>
<div class="m-thm-content">
平均 <span class="math inline">\mu</span>, 分散 <span class="math inline">\sigma^2</span> の母集団から無作為抽出された標本平均 <span class="math inline">\overline{X}_n</span> は, 母集団の分布に無関係に, <span class="math inline">n</span> が十分に大きいとき, 近似的に平均 <span class="math inline">\mu</span>, 分散 <span class="math inline">\dfrac{\sigma^2}{n}</span>(標準偏差 <span class="math inline">\dfrac{\sigma}{\sqrt{n}}</span>) に従う. <span class="math inline">\Leftrightarrow \rm i.i.d</span> 標本 <span class="math inline">X_1,X_2,\cdots,X_n</span> があって, <span class="math inline">E\left[X_i\right]=\mu,V\left[X_i\right]=\sigma^2</span> で, <span class="math inline">n\to\infty</span> のとき, <span class="math inline">\overline{X}_n</span> の分布は <span class="math inline">N(\mu,\dfrac{\sigma^2}{n})</span> に近く.
</div>
</div>
<p>という定理である. <a href="/roki.log/2018/10/28/probabilityTerms/#lawOfLargeNumbers">大数の弱法則</a>とこの中心極限定理ともにサンプル平均 <span class="math inline">\overline{X}_n</span> の振る舞いに関する定理であるが, 後者においては, サンプル平均と, 真の平均との誤差について論ずる定理である点が異なる. つまり, <a href="/roki.log/2018/10/28/probabilityTerms/#lawOfLargeNumbers">大数の弱法則</a>より <span class="math inline">\overline{X}_n\approx\mu</span> であることはわかったが, その差 <span class="math inline">\overline{X}_n-\mu</span> はどのような挙動となるのか, また <span class="math inline">0</span> に近づいていくのはわかったが, どのように近づいていくのかについて論じているのが, <a href="/roki.log/2018/10/28/probabilityTerms/#centralLimitTheorem">中心極限定理</a>である<a href="/roki.log/2018/10/28/probabilityTerms/#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. 中心極限定理は, それが正規分布に近似するといっているので, 起きた事象の珍しさを測るための指標として用いることができ, これが統計における検定に役立つ. また, すべての平均と分散が定義できるような分布<a href="/roki.log/2018/10/28/probabilityTerms/#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>に対していえることから, 様々な事象が正規分布に従うことを正当化するための理論的根拠としてよく用いられる.</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>「<a href="http://www.math.kobe-u.ac.jp/HOME/higuchi/h23kogi/h23kouki/p1-11.pdf">第 2 章 独立確率変数列の極限定理</a>」 2018 年 10 月 29 日アクセス.</li>
<li>「<a href="https://shoichimidorikawa.github.io/Lec/ProbDistr/cauchy.pdf">コーシー分布</a>」 2018 年 10 月 29 日アクセス.</li>
<li>「<a href="https://mathtrain.jp/gaussdistribution">正規分布の基礎的な知識まとめ - 高校数学の美しい物語</a>」 2018 年 9 月 27 日アクセス.</li>
<li>「<a href="https://mathtrain.jp/centrallimit" name="ref1">大数の法則と中心極限定理の意味と関係 - 高校数学の美しい物語</a>」 2018 年 10 月 29 日アクセス.</li>
<li>「<a href="https://mathtrain.jp/condexpectation">条件付き期待値，分散の意味と有名公式 - 高校数学の美しい物語</a>」 2018 年 11 月 12 日アクセス.</li>
<li>「<a href="https://mcm-www.jwu.ac.jp/~konno/pdf/statha3.pdf">3.3 条件付き期待値</a>」 2018 年 11 月 12 日アクセス.</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><span class="math inline">\sigma</span>-加法族は, 完全加法族, 可算加法族, <span class="math inline">\sigma</span>-集合代数, <span class="math inline">\sigma</span>-集合体ともいわれる.<a href="/roki.log/2018/10/28/probabilityTerms/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote">簡単のため, 確率変数 <span class="math inline">X, Y</span> に対して <span class="math inline">E\left[X,Y\right]=E\left[X\right]+E\left[Y\right]</span> を示して証明とする. ここで, <span class="math inline">\sum_i:=\sum^n_{i=1},\sum_j:=\sum^n_{j=1}</span> とし, 確率変数 <span class="math inline">X</span> がその取り得る値 <span class="math inline">x_i</span> となる確率を <span class="math inline">P(x_i)</span>, 同様に <span class="math inline">Y</span> がその取り得る値 <span class="math inline">y_j</span> となる確率を <span class="math inline">P(y_j)</span> とする. また, そのどちらもが同時に発生する確率を <span class="math inline">P(x_i,y_j)</span> とする.
<p>連続的確率変数に対しても, 積分の線型性から同様. <span class="math inline">\square</span><a href="/roki.log/2018/10/28/probabilityTerms/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><span class="math inline">{\rm (iii)}</span> および<a href="/roki.log/2018/10/28/probabilityTerms/#LinearityExpectedValue">期待値の線形性</a>より
<p><span class="math inline">\square</span><a href="/roki.log/2018/10/28/probabilityTerms/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote">簡単のため, 連続型確率変数 <span class="math inline">X,Y</span> に対する <span class="math inline">E\left[Y\right]=E\left[E\left[Y|X\right]\right]</span> を示して証明とする. <span class="math inline">E\left[Y\right]</span> は条件付き期待値の定義から <span class="math display">E\left[Y\right]=\int^\infty_{-\infty}\int^\infty_{-\infty}yf(x,y)dxdy</span> ここで, <span class="math inline">f(x,y)</span> は <span class="math inline">X,Y</span> の同時確率密度関数である. 従って,
<p><span class="math inline">\square</span><a href="/roki.log/2018/10/28/probabilityTerms/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote">平均 <span class="math inline">\mu</span>, 分散 <span class="math inline">\sigma^2</span> の確率変数 <span class="math inline">X</span> を正則化した変数 <span class="math inline">Z=\dfrac{X-\mu}{\sigma}</span> の期待値と分散を確認してみると, 平均は <span class="math inline">,</span> より
分散は <span class="math inline">,</span> より
<p>となり標準正規分布に従うことがわかる.<a href="/roki.log/2018/10/28/probabilityTerms/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote">\(\) および<a href="/roki.log/2018/10/28/probabilityTerms/#LinearityExpectedValue">期待値の線形性</a>より
<p><span class="math inline">\square</span><a href="/roki.log/2018/10/28/probabilityTerms/#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>matplotlib 等で<a href="https://gist.github.com/falgon/63bfa6f2039ad25379d441831f4bb648">生成</a>. 標準偏差 <span class="math inline">\sigma</span> を <span class="math inline">[1,5]</span> としたとき.<a href="/roki.log/2018/10/28/probabilityTerms/#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><a href="/roki.log/2018/10/28/probabilityTerms/#ref1">参考文献</a>から一部引用: <i>ベーシックな大数の弱法則は中心極限定理から導出することができます。→<a href="http://www.dklevine.com/archive/strong-law.pdf">The Laws of Large Numbers Compared</a>(snip) しかし，より一般的な（仮定を弱めた）大数の弱法則は中心極限定理から導出することはできません。つまり「中心極限定理が大数の法則を包含している」と言うことはできないのです。</i><a href="/roki.log/2018/10/28/probabilityTerms/#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>平均, 分散が定義できない分布の例としてよく挙げられるものの 1 つ: コーシー分布.<a href="/roki.log/2018/10/28/probabilityTerms/#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>ヤコビアン</title>
    <link href="https://roki.dev/roki.log/2018/10/4/jacobian/index.html" />
    <id>https://roki.dev/roki.log/2018/10/4/jacobian/index.html</id>
    <published>2018-10-04T00:00:00Z</published>
    <updated>2018-10-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>以前のエントリ, <a href="/roki.log/posts/2018/%209/26/GaussianIntegral/">ガウス積分の公式とその証明</a>で, 暗に極座標での微小面積が <span class="math inline">rdrd\theta</span> であるとして書いていたので, その内容についても一応書いておこうというのと, 筆者自身の学習/再整理も兼ねて, ヤコビアンに関して書くこととした.</p>
<h2 id="極座標の微小面積">極座標の微小面積</h2>
<p>直交座標から極座標へ移行する際に, その微小面積はどうなるかについて考察する.</p>
<figure>
<img src="/roki.log/2018/10/4/jacobian/cube_and_cross_section.png" title="立方体とその断面" width="500" alt /><figcaption>立方体とその断面</figcaption>
</figure>
<p>上図<a href="/roki.log/2018/10/4/jacobian/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>は, <span class="math inline">1\times 1\times 1</span> の立方体があって, その断面をそれぞれ極座標と直交座標で示しているだけであるが, この断面図のマスの広がり方を見るだけで, 少なくとも極座標における微小面積が <span class="math inline">drd\theta</span> とはならないことに納得できる. 単に <span class="math inline">drd\theta</span> としてしまうと, <span class="math inline">r</span> が大きくなればなるほど微小面積も伸びて大きくなっていってしまうだろうという想像がつく.</p>
<!--more-->
<p>ここで微小面積を導出するために, <span class="math inline">r,\theta</span> をともに少しだけ動かして, その幅をそれぞれ <span class="math inline">\Delta r,\Delta \theta</span> で表した, 次のような配置を考える<a href="/roki.log/2018/10/4/jacobian/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<figure>
<img src="/roki.log/2018/10/4/jacobian/smallarea.png" title="微小面積の導出" alt /><figcaption>微小面積の導出</figcaption>
</figure>
<p><span class="math inline">r</span> の距離と <span class="math inline">\theta</span> の角度で構成された面積, つまり上図の <span class="math inline">\Delta s</span> が微小面積に対応することがわかる. <span class="math inline">\Delta s</span> の面積は, 単に全体の扇形の面積から, <span class="math inline">r</span> と <span class="math inline">\Delta\theta</span> で構成された扇形の面積を引けばよいので,</p>
<p><span class="math display">\Delta s=\dfrac{1}{2}(r+\Delta r)^2\Delta\theta-\dfrac{1}{2}r^2\Delta\theta
=r\Delta r\Delta\theta+\dfrac{1}{2}(\Delta r)^2\Delta\theta</span></p>
<p><span class="math inline">\displaystyle\lim_{\Delta\theta,\Delta r\to 0}</span> を考えれば, 微小量 <span class="math inline">\Delta r\Delta\theta</span> の高次の項を無視してよい. よってこれを微小増分に書き換えれば, <span class="math inline">\Delta s</span> は <span class="math inline">rdrd\theta</span> となることがいえる.</p>
<p>…というように, ここまでは幾何学的なイメージを用いて, 直交座標と極座標間における微小面積の遷移について考察したが, 異なる座標系への変換をしようとする度にいちいち図などを用いて考察するのは面倒であり, 従って, より機械的/一般的にこれを実行する手法について考えることは自然な流れと言える. よって, 以降はそれを主題として話を進めていく.</p>
<p>ところで微積分では, 今もそうして行ったように, 極限の概念を多大に用いるので, ここで本題に入る前にその定義に関して触れておくこととする.</p>
<h2 id="epsilon-delta-論法"><span class="math inline">\epsilon-\delta</span> 論法</h2>
<p><span class="math inline">\epsilon-\delta</span> 論法とは簡単にいえば, 無限小, 無限大といった実数の範囲では定義できない曖昧な概念を, 実数値のみを用いて議論する方法で, 同論法上で極限の式との同値関係を示した定義が次のとおりである.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="epsilonDelta-definitionOfLimit"><span class="math inline">\epsilon-\delta</span> 論文の定義する極限の式との同値関係</span>
</p>
</header>
<div class="m-def-content">
<span class="math inline">f</span> を実数の部分集合 <span class="math inline">D</span> で定義された実数値関数, <span class="math inline">c</span> を <span class="math inline">D</span> の極限点, <span class="math inline">L</span> を実数としたとき, <span class="math display">\displaystyle
  \lim_{x\to c}f(x)=L\Leftrightarrow(^\forall\epsilon\gt 0,^\exists\delta\gt 0,^\forall x\in D,0\lt\left|x-c\right|\lt\delta\Rightarrow\left|f(x)-L\right|\lt\epsilon)</span>
</div>
</div>
<p><span class="math inline">D=[a,b]</span> または <span class="math inline">D=\mathbb{R}</span> ならば, 閉じた実区間と実数直線は完全集合となり, <span class="math inline">c</span> は自動的に極限点であるという条件が満たされるので, 簡単のためにこれを <span class="math inline">D=\mathbb{R}</span> として書き直すと, <span class="math inline">\epsilon-\delta</span> 論法は</p>
<p><span class="math display">^\forall\epsilon\gt 0,^\exists\delta\gt 0,\ {\rm s.t.}\ ^\forall x\in\mathbb{R}, \left|x-c\right|\lt\delta\Rightarrow\left|f(x)-L\right|\lt\epsilon</span></p>
<p>となる. 日本語で記述すると「任意の実数 <span class="math inline">^\forall x\in\mathbb{R}</span> に対して, <span class="math inline">\left|x-c\right|\lt\delta</span> を満たすならば, すべての正の実数 <span class="math inline">\epsilon</span> に対して <span class="math inline">\left|f(x)-L\right|\lt\epsilon</span> を満たすような <span class="math inline">\delta</span> が存在する.」となる. つまりこの言葉で, 関数 <span class="math inline">f(x)</span> が <span class="math inline">x=c</span> で連続であることの定義をいうことができるのである. これをグラフで表すと, 次のように描けるだろう. 関数 <span class="math inline">y=f(x)</span> のとる値を赤の線として, <span class="math inline">x=c</span> のときの Y 座標の値を <span class="math inline">L</span> とし, いま <span class="math inline">\epsilon</span> を適当に取ってきて, <span class="math inline">c</span> からの幅 <span class="math inline">\delta</span> を <span class="math inline">L</span> との幅よりも小さくなるようにとると, 次のようになる.</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/d/d1/L%C3%ADmite_01.svg" title="c からの幅 delta を L との幅よりも小さくなるようにとったときの視覚的イメージ" width="300" alt /><figcaption><span class="math inline">c</span> からの幅 <span class="math inline">\delta</span> を <span class="math inline">L</span> との幅よりも小さくなるようにとったときの視覚的イメージ</figcaption>
</figure>
<p>これは, さきに書いた論理式を満たすことがわかる. 上図の <span class="math inline">\epsilon</span> を見ると, この値はそこそこの大きさがあるように見えるが, これをさらに小さい値で取ったとしても, <span class="math inline">\delta</span> をそれよりもさらに小さい幅で取ることができる(=上の論理式が満たされる). 従って, 上で描いた関数 <span class="math inline">f(x)</span> は <span class="math inline">x=c</span> で連続であると言える. 逆に, <span class="math inline">\delta</span> をそれよりもさらに小さい幅で取ることができないのならば, それは連続でないといえることもわかる. いまこれらを言うのに, 極限の概念を用いることはなかった. このようにして, 表向きに極限を用いずとも, 関数の連続性の定義ができたということが, <span class="math inline">\epsilon-\delta</span> 論法の主要な存在意義の 1 つである<a href="/roki.log/2018/10/4/jacobian/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>ところで, この「任意の実数 <span class="math inline">^\forall x\in\mathbb{R}</span> に対して, <span class="math inline">\left|x-c\right|\lt\delta</span> を満たすならば, すべての正の実数 <span class="math inline">\epsilon</span> に対して <span class="math inline">\left|f(x)-L\right|\lt\epsilon</span> を満たすような <span class="math inline">\delta</span> が存在する.」というのは, <span class="math inline">x</span> を <span class="math inline">c</span> に近づけていくとき, <span class="math inline">f(x)</span> 自体が <span class="math inline">L</span> と同じであろうがなかろうが, <span class="math inline">L</span> でない他のどのような値と比べても, より <span class="math inline">L</span> に近づいていくものであるともいえる. そのようにより近づいていく値を, その値そのものと同値であるとみなすことが, <span class="math inline">\epsilon-\delta</span> 論法における極限であるともいえるのである. つまり, <span class="math inline">\epsilon-\delta</span> 論法は, <strong>どんなに小さな任意の <span class="math inline">\epsilon</span> を考えても, <span class="math inline">\left|x-c\right|\lt\delta</span> であるとき, <span class="math inline">\left|f(x)-L\right|\lt\epsilon</span> になるような <span class="math inline">\delta</span> があるならば, 関数 <span class="math inline">f(x)</span> の <span class="math inline">x\to c</span> の極限値 <span class="math inline">\displaystyle\lim_{x\to c}f(x)</span> を <span class="math inline">L</span> と同値とみなす</strong>.</p>
<h2 id="より一般的な変数変換">より一般的な変数変換</h2>
<p>極限に関して厳密な定義ができたところで, 本題に入るが, 問題そのものを的確に把握することは, 問題を解く上で最も重要な過程であるので, 異なる座標系への移行という行為が一体どういうことなのかについてここで整理しておく.</p>
<h3 id="異なる座標系への移行とは何か">異なる座標系への移行とは何か</h3>
<p>唐突であるが, <span class="math inline">D</span> を <span class="math inline">x,y</span> 平面の閉領域として, <span class="math display">
\int\int_{D}(x-y)e^{x+y}dxdy, D={(x,y)|0\leq x+y\leq 2, 0\leq x-y\leq 2}
</span> の積分値を計算せよと言われたら, どのように解けば良いのだろうか. そのまま計算するよりも, <span class="math inline">u=x+y,v=x-y</span> とおくと楽なので, いま<span class="math inline">D</span> に変わる新しい領域 <span class="math inline">E</span> を <span class="math inline">u,v</span> 平面の閉領域として <span class="math display">
\int\int_{E}ve^ududv, E={(u,v)|0\leq u\leq 2,0\leq v\leq 2}
</span> と書きたくなるが, この積分値は元の領域と等しくない<a href="/roki.log/2018/10/4/jacobian/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. 1 次元のときの変数変換を思い出せば, 例えば <span class="math inline">x=\phi(t)</span> と変数変換したときに, <span class="math display">\displaystyle\int_{x_1}^{x_2}f(x)dx\not =\int_{t_1}^{t^2}f(\phi(t))dt</span> で <span class="math display">\displaystyle\int_{x_1}^{x_2}f(x)dx =\int_{t_1}^{t^2}f(\phi(t))\phi'(t)dt</span> だったのと同様, 変数変換における双方の対応関係から成る比率で, 埋めあわせをしなければならなかった. 2 重積分においてこの比率は, 元の領域との<strong>面積比</strong>に相当することになる. つまり, その一般解を得ることで, 異なる座標系間での移行が可能となるのである.</p>
<h3 id="幾何学的なアプローチ">幾何学的なアプローチ</h3>
<p>微積分学的な言葉を使ったアプローチを行う前に, 図形的意味を重視してまず書くこととする.</p>
<p>そもそも重積分というのは, ある座標系における微小面積と, ある関数 <span class="math inline">f</span> との値の積の総和の極限を取ることであった. <span class="math inline">u,v</span> 座標系というものがあれば, その座標系/定義域における微小面積で, 今述べた操作を行うのである. というわけで, まず直交座標から一般の座標系への写像となる関数を, <span class="math inline">x=\phi(u,v), y=\psi(u,v)</span> として考察することとする.</p>
<p>早速であるが, <span class="math inline">u</span> とそこから少し動いた <span class="math inline">u+\Delta u</span>, <span class="math inline">v</span> とそこから少し動いた <span class="math inline">v+\Delta v</span> から成る四角形について考える. これが, <span class="math inline">u,v</span> 座標系における微小面積である. この四角形のそれぞれの頂点は, 直交座標の言葉で(<span class="math inline">\phi, \psi</span> 関数を使って),</p>
<p><span class="math display">
\begin{array}{l}
O(\phi(u,v),\psi(u,v)) \\
A(\phi(u+\Delta u, v), \psi(u+\Delta u,v)) \\
B(\phi(u,v+\Delta v), \psi(u,v+\Delta v)) \\
C(\phi(u+\Delta u,v+\Delta v), \psi(u+\Delta,v+\Delta v))
\end{array}</span></p>
<p>などと書き表わせる(頂点それぞれに, 適当に記号を割り振った. また, わかり易さのために頂点 <span class="math inline">C</span> を書いたが, 今回これは使わない).</p>
<p>さて, これらの頂点から成る四角形は, 極限の基で近似的に平行四辺形となるということを予めここで言ってしまおう. 従って, その平行四辺形の面積 <span class="math inline">S</span> を求めるために, <span class="math inline">(\overrightarrow{OA}, \overrightarrow{OB})</span> の行列式を求めることとする<a href="/roki.log/2018/10/4/jacobian/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. まず, <span class="math inline">\overrightarrow{OA}</span> について考える. これは単に, <span class="math inline">A</span> の座標から <span class="math inline">O</span> の座標を引けば良いが, これは<a href="/roki.log/2018/10/4/jacobian/#PartialDerivative">偏微分</a>そのもので, 線形近似により,</p>
<p><span class="math display">
\begin{aligned}
\phi(u+\Delta u, v)-\phi(u,v)&amp;\approx&amp;\dfrac{\partial \phi}{\partial u}\Delta u \\
\psi(u+\Delta u, v)-\psi(u,v)&amp;\approx&amp;\dfrac{\partial \psi}{\partial u}\Delta u
\end{aligned}
</span></p>
<p>と書ける. 従って, <span class="math inline">\overrightarrow{OB}</span> についても同様に,</p>
<p><span class="math display">
\begin{aligned}
\overrightarrow{OA}&amp;\approx&amp;\left(\dfrac{\partial \phi}{\partial u}\Delta u,\dfrac{\partial \psi}{\partial u}\Delta u\right) \\
\overrightarrow{OB}&amp;\approx&amp;\left(\dfrac{\partial \phi}{\partial v}\Delta v,\dfrac{\partial \psi}{\partial v}\Delta v\right)
\end{aligned}
</span></p>
<p>と書ける. あとは, これらから成る行列の行列式の絶対値を求めれば良いから,</p>
<p><span class="math display">
\begin{aligned}
S&amp;\approx&amp;\left|{\rm det}\left(
\begin{array}{cc}
\dfrac{\partial \phi}{\partial u}\Delta u&amp;\dfrac{\partial \phi}{\partial v}\Delta v \\
\dfrac{\partial \psi}{\partial u}\Delta u&amp;\dfrac{\partial \psi}{\partial v}\Delta v
\end{array}
\right)\right| \\
&amp;\approx&amp;\left|{\rm det}\left(
\begin{array}{cc}
\dfrac{\partial \phi}{\partial u}&amp;\dfrac{\partial \phi}{\partial v} \\
\dfrac{\partial \psi}{\partial u}&amp;\dfrac{\partial \psi}{\partial v}
\end{array}
\right)\right|\Delta u\Delta v
\end{aligned}
</span></p>
<p><span class="math inline">\Delta u, \Delta v</span> の無限小の極限をとり, 微小増分の式に書き換えれば,</p>
<p><span class="math display">
\begin{aligned}
&amp;\approx&amp;\left|{\rm det}\left(
\begin{array}{cc}
\dfrac{\partial \phi}{\partial u}&amp;\dfrac{\partial \phi}{\partial v} \\
\dfrac{\partial \psi}{\partial u}&amp;\dfrac{\partial \psi}{\partial v}
\end{array}
\right)\right|dudv\tag{1}
\end{aligned}
</span></p>
<p><span class="math inline">(1)</span> の行列式の絶対値がヤコビアンである. いま求めた式 <span class="math inline">(1)</span> は, 後に述べている全微分といわれる操作に相当している.</p>
<h3 id="全微分">全微分</h3>
<p>全微分は, 偏微分に関してもう一度考えることで納得できる. (先に線形代数的アプローチで, 偏微分は自明なものとして使ってしまったが)そもそも偏微分はなんだったかといえば, 多変数関数の特定の変数以外を定数と捉えて微分することであった.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="PartialDerivative">偏微分</span>
</p>
</header>
<div class="m-def-content">
<span class="math inline">U</span> を <span class="math inline">R^n</span> の開部分集合とし, 函数 <span class="math inline">f:U\to R</span> に対して, <span class="math inline">{\bf x}=(x_1, \cdots, x_n) \in U</span> の <span class="math inline">i</span> 番目の変数 <span class="math inline">x_i</span> における <span class="math inline">f</span> の偏微分は <span class="math display">\displaystyle
\dfrac{\partial}{\partial x_i}f({\bf x}) := \lim_{\Delta x_i\to 0}\dfrac{f(x_1,\cdots,x_i+\Delta x_i,\cdots,x_n)-f(x_1,\cdots,x_i,\cdots,x_n)}{\Delta x_i}</span>
</div>
</div>
<p>要するに, <span class="math inline">f</span> が 2 変数関数であれば,</p>
<p><span class="math display">
\begin{aligned}
\frac{\partial f(x, y)}{\partial x} &amp;:=&amp; \lim_{\Delta \to 0} \frac{f(x + \Delta, y) - f(x, y)}{\Delta}\\
\frac{\partial f(x, y)}{\partial y} &amp;:=&amp; \lim_{\Delta \to 0} \frac{f(x, y + \Delta) - f(x, y)}{\Delta}
\end{aligned}
</span></p>
<p>である. これを踏まえて, 2 変数関数における全微分を導出することを考える. 簡単に言ってしまえば, 偏微分が 2 変数以上の関数のただ 1 つを変数とみなして, その微小変化に対する変化量を求めることであったのに対し, 全微分は, 全ての変数の微小変化に対する変化量を求めることである. まず変数 <span class="math inline">x, y</span> が各々で微小量 <span class="math inline">\Delta x,\Delta y</span> だけ変化するとき, その全体の変化量 <span class="math inline">\Delta f</span> を次のように表せる.</p>
<p><span class="math display">
\begin{aligned}
\Delta f&amp;=&amp;f(x+\Delta x, y+\Delta y)-f(x,y) \\
&amp;=&amp;f(x+\Delta x, y+\Delta y)-f(x,y+\Delta y)+f(x,y+\Delta y)-f(x,y) \tag{2}
\end{aligned}
</span></p>
<p>式 \(\) の改行位置を変えるとわかりやすいが,</p>
<p><span class="math display">
\Delta f=f(x+\Delta x, y+\Delta y)-f(x,y+\Delta y)
+f(x,y+\Delta y)-f(x,y) \tag{3}
</span></p>
<p>いま, それぞれの部分に着目すると, <span class="math inline">f(x+\Delta x, y+\Delta y)-f(x,y+\Delta y)</span> 部分は <span class="math inline">x</span> のみを変化させたときの <span class="math inline">f</span> の変化量で, <span class="math inline">f(x,y+\Delta y)-f(x,y)</span> 部分は <span class="math inline">y</span> のみを変化させたときの <span class="math inline">f</span> の変化量となっていることがわかる. この式 <span class="math inline">(2)</span> をさらに変形させると,</p>
<p><span class="math display">\begin{aligned}
\displaystyle
\Delta f&amp;=&amp;\dfrac{f(x+\Delta x, y+\Delta y)-f(x,y+\Delta y)}{\Delta x}\Delta x \\
&amp;+&amp;\dfrac{f(x,y+\Delta y)-f(x,y)}{\Delta y}\Delta y
\end{aligned}
</span></p>
<p>この式が微分の定義式と酷似していることに気づけば, <span class="math inline">\Delta x,\Delta y</span> の無限小の極限をとり, 微小増分の式に書き換えて,</p>
<p><span class="math display">
\displaystyle
df=\lim_{dx,dy\to 0}\dfrac{f(x+dx, y+dy)-f(x,y+dy)}{dx}dx+
\lim_{dx,dy\to 0}\dfrac{f(x,y+dy)-f(x,y)}{dy}dy \tag{4}
</span></p>
<p><span class="math inline">\displaystyle\lim_{dx,dy\to 0}</span> を考えると, <span class="math inline">\lim_{dx,dy\to 0}\dfrac{f(x+dx, y+dy)-f(x,y+dy)}{dx}dx</span> 部分はもはや <span class="math inline">\displaystyle\lim_{dx,dy\to 0}\dfrac{f(x+dx, y)-f(x,y)}{dx}</span> と同然であるので, すべての値 <span class="math inline">(4)</span> が, 特定以外の変数を変化させない微分となっていることがわかる. ここで, 記号 <span class="math inline">\partial</span> を導入して, いまの式を <span class="math display">df=\dfrac{\partial f}{\partial x}dx+\dfrac{\partial f}{\partial y}dy\tag{5}</span> と書くと, これが全微分/完全微分の定義になる. 多変数関数 <span class="math inline">f</span> の無限小変化を式 <span class="math inline">(5)</span> のように表せるとき, 多変数関数 <span class="math inline">f</span> はその変数において全微分可能であるという.</p>
<h3 id="全積分とヤコビアン">全積分とヤコビアン</h3>
<p>先に <span class="math inline">x=\phi(u,v), y=\psi(u,v)</span> としていたので, <span class="math inline">x,y</span> の全微分は</p>
<p><span class="math display">
\begin{aligned}
dx&amp;=&amp;\dfrac{\partial\phi}{\partial u}du+\dfrac{\partial\phi}{\partial v}dv \\
dy&amp;=&amp;\dfrac{\partial\psi}{\partial u}du+\dfrac{\partial\psi}{\partial v}dv
\end{aligned}
</span></p>
<p>となる. いまこれを行列で表すと,</p>
<p><span class="math display">
\begin{aligned}
\begin{pmatrix}
dx \\
dy
\end{pmatrix}=
\begin{pmatrix}
\dfrac{\partial\phi}{\partial u}&amp;\dfrac{\partial\phi}{\partial u} \\
\dfrac{\partial\psi}{\partial v}&amp;\dfrac{\partial\psi}{\partial v}
\end{pmatrix}
\begin{pmatrix}
du \\
dv
\end{pmatrix}
\end{aligned}
</span></p>
<p>となる. この行列の行列式</p>
<p><span class="math display">
\begin{aligned}
{\rm det}
\left(
\begin{array}{cc}
\dfrac{\partial\phi}{\partial u}&amp;\dfrac{\partial\phi}{\partial v} \\
\dfrac{\partial\psi}{\partial u}&amp;\dfrac{\partial\psi}{\partial v}
\end{array}
\right)
\end{aligned}
</span> はヤコビアンといわれ(\(\) と同じ), <span class="math inline">\dfrac{\partial(\phi,\psi)}{\partial{u,v}}</span>, また <span class="math inline">{\rm J}(u, v)</span> と表される. 一般に,</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="Jacobian">ヤコビアン</span>
</p>
</header>
<div class="m-def-content">
<p><span class="math inline">n</span> 変数関数の全微分を行列で表した式 <span class="math display">
\begin{aligned}
\begin{pmatrix}
f_1 \\
\vdots \\
f_n
\end{pmatrix}=
\begin{pmatrix}
\dfrac{\partial f_1}{\partial x_1}&amp;\cdots&amp;\dfrac{\partial f_1}{\partial x_n} \\
\vdots&amp;\ddots&amp;\vdots \\
\dfrac{\partial f_n}{\partial x_1}&amp;\cdots&amp;\dfrac{\partial f_n}{\partial x_n}
\end{pmatrix}
\begin{pmatrix}
dx_1 \\
\vdots \\
dx_n
\end{pmatrix}
\end{aligned}
</span> の行列の行列式 <span class="math display">
\begin{aligned}
{\rm det}\left(
\begin{array}{ccc}
\dfrac{\partial f_1}{\partial x_1}&amp;\cdots&amp;\dfrac{\partial f_1}{\partial x_n} \\
\vdots&amp;\ddots&amp;\vdots \\
\dfrac{\partial f_n}{\partial x_1}&amp;\cdots&amp;\dfrac{\partial f_n}{\partial x_n}
\end{array}\right)
\end{aligned}
</span> を <span class="math inline">\dfrac{\partial(f_1,\cdots,f_n)}{\partial(x_1,\cdots,x_n)}</span> また <span class="math inline">{\rm J}(x_1,\cdots,x_n)</span> と書く.</p>
</div>
</div>
<p>冒頭で述べた直交座標から極座標への変換をこのヤコビアンを使って導くならば, まず二次元直交座標系から二次元極座標系への対応関係は,</p>
<p><span class="math display">
\begin{aligned}
\begin{pmatrix}
x \\ y
\end{pmatrix}= 
\begin{pmatrix}
r \cos\theta \\  r \sin\theta
\end{pmatrix}
\end{aligned}
</span></p>
<p>で, 二次元極座標の変数は <span class="math inline">r, \theta</span> なのでこれをヤコビアンに与えて,</p>
<p><span class="math display">
\begin{aligned}
J(r,\theta)={\rm det}\left(\begin{array}{cc}
\cos\theta &amp; -r\sin\theta \\
\sin\theta &amp; r\cos\theta
\end{array}\right)=r
\end{aligned}
</span></p>
<p>一般の 2 重積分は</p>
<p><span class="math display">\int\int_D f(x,y)dxdy=\int\int_E f(\phi(u,v),\psi(u,v))J(u,v)dudv</span> なので, 極座標における全体の微小面積は <span class="math inline">rdrd\theta</span> となり, 冒頭で行った図形的解釈のもとに導き出した解と一致することがわかる. 「異なる座標系への移行とは何か」の冒頭で挙げた例題</p>
<p><span class="math display">\int\int_{D}(x-y)e^{x+y}dxdy, D={(x,y)|0\leq x+y\leq 2, 0\leq x-y\leq 2}</span></p>
<p>も, <span class="math inline">u=x+y, v=x-y</span> とおいてヤコビアンに与えれば,</p>
<p><span class="math display">
\begin{aligned}
{\rm J}(u,v)&amp;=&amp;{\rm det}\left(\begin{array}{rr} \dfrac{1}{2}&amp;\dfrac{1}{2} \\
\dfrac{1}{2}&amp;-\dfrac{1}{2}\end{array}\right)&amp;=&amp;-\dfrac{1}{2}
\end{aligned}
</span></p>
<p>絶対値を考えれば良いので,</p>
<p><span class="math display">
\begin{aligned}
&amp;=&amp;\left|{\rm det}\left(\begin{array}{rr} \dfrac{1}{2}&amp;\dfrac{1}{2} \\ \dfrac{1}{2}&amp;-\dfrac{1}{2}\end{array}\right)\right|&amp;=&amp;\dfrac{1}{2}
\end{aligned}
</span></p>
<p><span class="math display">
\begin{aligned}
\therefore\int\int_D(x-y)e^{x+y}dxdy&amp;=&amp;\int^2_0\int^2_0ve^u\dfrac{1}{2}dudv \\
&amp;=&amp;\dfrac{1}{2}\int^2_0\left[ve^u\right]^2_0dv \\
&amp;=&amp;\dfrac{1}{2}\int^2_0(ve^2-v)dv \\
&amp;=&amp;\dfrac{1}{2}\left[\dfrac{e^2}{2}v^2-\dfrac{1}{2}v^2\right]^2_0 \\
&amp;=&amp;e^2-1
\end{aligned}
</span></p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>
“<a href="http://mathforum.org/library/drmath/view/74707.html">Why Does dxdy = rdrd(theta)? Why Not Just drd(theta)?</a>” 2018 年 10 月 4 日アクセス.
</li>
<li>
「<a href="http://simanezumi1989.hatenablog.com/entry/2015/06/22/133411">GeoGebraを使ってε-δ論法を可視化してみた</a>」 2018 年 10 月 4 日アクセス.
</li>
<li>
「<a href="https://jsciencer.com/unimath/bisekibun/3611/" id="ref1">微分の順序</a>」 2018 年 10 月 4 日アクセス.
<li>
「<a href="http://eman-physics.net/analytic/total_dif.html">全微分</a>」 2018 年 10 月 4 日アクセス.
<li>
“<a href="https://euler.genepeer.com/determinants">The Jacobian &amp; Determinants - Euler, Erdős</a>” 2018 年 10 月 4 日アクセス.
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>図は matplotlib 等で<a href="https://gist.github.com/falgon/e867c610ebdf957a827e2d26bd2ea451">生成</a>.<a href="/roki.log/2018/10/4/jacobian/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>図は <a href="https://www.draw.io/">draw.io</a> で作成.<a href="/roki.log/2018/10/4/jacobian/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote">完全に蛇足であるが, 連続性の定義は, 他の様々な前提のための重要な要素となりうる. 例えば, いま, <span class="math inline">f_x:=\dfrac{\partial f}{\partial x}, f_y:=\dfrac{\partial f}{\partial y}</span> という記法を導入すると, 関数 <span class="math inline">f(x,y)</span> の偏導関数 <span class="math inline">f_{x}(x,y), f_{y}(x,y)</span> がそれぞれ偏微分可能であるとき, 4 つの 2 次偏導関数,
<p>を考えることができるが, <span class="math inline">f</span> にこの <span class="math inline">f_{xy}, f_{yx}</span> が存在して, ともに連続であるといえれば, 偏微分の順序交換法則(<span class="math inline">f_{xy}=f_{yx}</span>) が成り立つことを示せる. この証明は, <a href="https://ja.wikipedia.org/wiki/%E5%B9%B3%E5%9D%87%E5%80%A4%E3%81%AE%E5%AE%9A%E7%90%86">平均値の定理</a>を補題として証明した上で行わなければならなく大変だが, <a href="/roki.log/2018/10/4/jacobian/#ref1">参考文献</a>にわかりやすい証明がされている.<a href="/roki.log/2018/10/4/jacobian/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>正しい解答は末尾にて.<a href="/roki.log/2018/10/4/jacobian/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>補足: 2 つの二次元ベクトル <span class="math inline">a_1, a_2</span> から成る 2 次正方行列の行列式の絶対値は, <span class="math inline">a_1,a_2</span> が定める平行四辺形の面積に等しいのであった.<a href="/roki.log/2018/10/4/jacobian/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>ガウス積分の公式とその証明</title>
    <link href="https://roki.dev/roki.log/2018/09/26/GaussianIntegral/index.html" />
    <id>https://roki.dev/roki.log/2018/09/26/GaussianIntegral/index.html</id>
    <published>2018-09-26T00:00:00Z</published>
    <updated>2018-09-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>当ブログ内でガウス積分(オイラー＝ポアソン積分)の公式を用いる際に self-contained でリファレンスを張るためと, 個人的な学習の記録として, 本エントリにてガウス積分の公式とその証明について書く<a href="/roki.log/2018/09/26/GaussianIntegral/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a><span class="math inline">.</span> 筆者自身にとっての分かりやすさを優先しているため, 若干冗長的な記述があるかもしれない点に注意.</p>
<div class="m-thm">
<header class="m-thm-title">
<p>
<span id="GaussianIntegral">ガウス積分の公式</span>
</p>
</header>
<div class="m-thm-content">
<span class="math inline">x\in\mathbb{R}</span> のとき <span class="math display">\displaystyle\int_{-\infty}^{\infty}e^{-x^2}dx=\sqrt{\pi}</span>
</div>
</div>
<!--more-->
<div class="m-proof">
<header class="m-proof-title">
<p>
ガウス積分の公式
</p>
</header>
<div class="m-proof-content">
<p><span class="math display">I=\displaystyle\int_{-\infty}^{\infty}e^{-x^2}dx</span> とおく. ここで, 最終的に <span class="math inline">\pi</span> を出現させるために, 直交座標系から極座標系への移行を行いたい. そのために, まず二乗して</p>
<p><span class="math display">I^2=\displaystyle(\int_{-\infty}^{\infty}e^{-x^2}dx)^2=
(\int_{-\infty}^{\infty}e^{-x^2}dx)\cdot(\int_{-\infty}^{\infty}e^{-x^2}dx)
</span></p>
<p>文字を変えても積分値に変わりはないから</p>
<p><span class="math display">I^2=(\int_{-\infty}^{\infty}e^{-x^2}dx)\cdot(\int_{-\infty}^{\infty}e^{-y^2}dy)=
\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}e^{-(x^2+y^2)}dxdy</span></p>
<p><span class="math inline">x=r\cos\theta,\ y=r\sin\theta, dx\ dy=rdrd\theta</span> とし<a href="/roki.log/2018/09/26/GaussianIntegral/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p><span class="math display">\begin{aligned}
I^2&amp;=&amp;\int_{0}^{2\pi}\int_{0}^{\infty}e^{-r^2}rdrd\theta \\
&amp;=&amp;\int_{0}^{2\pi}d\theta\int_{0}^{\infty}re^{-r^2}dr \\
&amp;=&amp;2\pi\left[\dfrac{1}{2}e^{-r^2}\right]^{\infty}_{0} \\
&amp;=&amp;\pi
\end{aligned}</span> もともと <span class="math inline">I</span> は被積分関数の関数形であり, 定義域は <span class="math inline">I &gt; 0</span> だから, <span class="math inline">I=\sqrt{\pi}</span>.</p>
</div>
</div>
<p>2 乗して <span class="math inline">x^2+y^2=r^2</span><a href="/roki.log/2018/09/26/GaussianIntegral/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> を出現させ, 極座標での表現を開始する流れは, 胸熱であった. さて, 以下はガウス積分の公式に関連した, いくつかの等式について示すこととする.</p>
<div class="m-thm">
<header class="m-thm-title">
<p>
<span id="SimilarGaussianIntegral1">ガウス積分の類似形 1</span>
</p>
</header>
<div class="m-thm-content">
<span class="math inline">x\in\mathbb{R}, a\in\mathbb{R}^{+}</span> のとき, <span class="math display">\displaystyle\int_{-\infty}^{\infty}e^{-ax^2}dx=\sqrt{\dfrac{\pi}{a}}</span>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
ガウス積分の類似形 1
</p>
</header>
<div class="m-proof-content">
<p><span class="math inline">y=\sqrt{a}x, dy=\sqrt{a}dx</span> とし,</p>
<p><span class="math display">\int_{-\infty}^{\infty}e^{-ax^2}dx=\int_{-\infty}^{\infty}e^{-y^2}\cdot\dfrac{1}{\sqrt{a}}dy=\dfrac{1}{\sqrt{a}}\int_{-\infty}^{\infty}e^{-y^2}dy\tag{1}</span> \(\) の最右辺をみると<a href="/roki.log/2018/09/26/GaussianIntegral/#GaussianIntegral">ガウス積分の公式</a>と全く同じなので, <span class="math inline">=\sqrt{\dfrac{\pi}{a}}</span>.</p>
</div>
</div>
<div class="m-thm">
<header class="m-thm-title">
<p>
<span id="SimilarGaussianIntegral2">ガウス積分の類似形 2</span>
</p>
</header>
<div class="m-thm-content">
<span class="math inline">x\in\mathbb{R}, a\in\mathbb{R}^{+}</span> のとき, <span class="math display">\displaystyle\int_{0}^{\infty}e^{-ax^2}dx=\dfrac{1}{2}\sqrt{\dfrac{\pi}{a}}</span>
</div>
</div>
<div class="m-proof">
<header class="m-proof-title">
<p>
ガウス積分の類似形 2
</p>
</header>
<div class="m-proof-content">
<p>単に<a href="/roki.log/2018/09/26/GaussianIntegral/#SimilarGaussianIntegral1">ガウス積分の類似形 1</a>の半分の領域となるだけなので, <span class="math inline">\displaystyle\int_{0}^{\infty}e^{-ax^2}dx=\dfrac{1}{2}\sqrt{\dfrac{\pi}{a}}</span>.</p>
</div>
</div>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>
「<a id="ref1" href="https://mathtrain.jp/gauss">ガウス積分の公式の 2 通りの証明</a>」 2018 年 9 月 26 日アクセス.
</li>
<li>
「<a href="http://www.chem.tsukuba.ac.jp/kazuya/kazuya/AppC.pdf">C. 極座標</a>」 2018 年 9 月 26 日アクセス.
</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>証明内では, <a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%83%93%E3%83%8B%E3%81%AE%E5%AE%9A%E7%90%86">フビニの定理</a>を暗黙に使っている. 恥ずかしながら, 筆者は測度論について全くの素人であるので, これを暗に用いることはあまりよくないと思うのだが, これが<a href="/roki.log/2018/09/26/GaussianIntegral/#ref1"><i>シグマの二重和が分解できることの一般形</i></a>であると理解して, 今回はこれを用いた.<a href="/roki.log/2018/09/26/GaussianIntegral/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>補足: 極座標系において, <span class="math inline">\theta</span> の変域は <span class="math inline">[0,2\pi]</span>, <span class="math inline">r</span> の変域は <span class="math inline">[0,\infty]</span> である. また, 極座標での微小面積は <span class="math inline">drd\theta</span> ではなく <span class="math inline">rdrd\theta</span> であることに注意. これについては, 後日のエントリ, <a href="/roki.log/posts/2018/10/4/jacobian/">ヤコビアン</a>にて取り扱っている.<a href="/roki.log/2018/09/26/GaussianIntegral/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>一応書いておくと, この裏付けは三平方の定理より <span class="math inline">\cos^2+\sin^2=1</span>.<a href="/roki.log/2018/09/26/GaussianIntegral/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Haskell でリンクレイヤーにおける ICMP パケットの構築, 送受信および解析による ping の実装</title>
    <link href="https://roki.dev/roki.log/2018/09/15/scratchPacket/index.html" />
    <id>https://roki.dev/roki.log/2018/09/15/scratchPacket/index.html</id>
    <published>2018-09-15T00:00:00Z</published>
    <updated>2018-09-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Haskell で低レイヤーのネットワークプログラミングをそういえばしたことがなかったので, 何か実装してみたかったのだが特別ネタも思いつかないので, とりあえずイーサヘッダ, IP ヘッダ等を含む, 生の ICMP Echo/Reply パケットを扱ってみることとした.</p>
<p>ICMP パケットは IP パケットであるので, 通常は ICMP パケット部分のみを構築して<code>PF_INET</code>等で開いたソケットに送りつけたり, <code>recv</code> 等すれば送受信においては必要十分であるが, これではあまり面白みがないので, リンクレイヤーから扱うこととした.</p>
<p>生の ICMP パケットを扱うということは, ICMP データの自作はもちろん, イーサヘッダ, IP ヘッダの自作が必要となる. またイーサヘッダを自作するということは, MAC アドレスを解決しなければならないので, 最低限 ARP パケットの送受信および解析機能の自作が必要となることを意味する. ARP パケットの自作を要するということは, デフォルトゲートウェイやサブネット環境などを取得する機能も必要である. これらを自作してみた.</p>
<!--more-->
<h2 id="環境">環境</h2>
<p>環境は, 本エントリ末尾に記載のリポジトリ内にある <a href="https://github.com/falgon/network-basal/blob/8ba27abae4fa69652756ef7941f6377d46b54eff/testenv/Vagrantfile">Vagrantfile</a> の通りで, ごく普通の Ubuntu 18.04 仮想マシンである. テスト用途として, 同一プライベートネットワーク上にもう 1 つ同 OS のノードを用意している.</p>
<h2 id="arp">ARP</h2>
<p>まずは冒頭で述べた理由より, ARP パケットの作成, 送受信および解析の機能を実装する必要がある. ARP に関しては, RFC 826 を再確認しつつ実装した. これは<a href="/roki.log/2018/05/01/detectPromiscuous/">以前 C++ で実装した</a>ことがあったので, とくに困ることはなかったが, Haskell では, とくにリンクレイヤにおいては, その肝心なパケットの送受信の手段があまり充実していないようで, それには少々戸惑った. たとえば, 本エントリ執筆時点で, 同レイヤーのパケット送受信を <a href="http://hackage.Haskell.org/package/network-2.8.0.0">Network.Socket</a> モジュール等で実行することは不可能である.</p>
<p>当初は単に<code>PF_PACKET</code>, <code>SOCK_RAW</code>等で開いたソケットに書き込もうと思っていたので, これは FFI で呼び出すしかないかと思ったが, ふと libpcap の Haskell ラッパーである <a href="http://hackage.Haskell.org/package/pcap">pcap</a> モジュールの存在を知り, これを利用させて頂くこととした.</p>
<p>今回簡単のため, ARP キャッシュを単に /proc/net/arp を読むことで済ませており, この点で手抜き仕様となっているので, 今後自前で ARP キャッシュを実装するか, /proc/net/arp との共和の良い方法を検討するかしたい.</p>
<p>この実装による副産物として, 同一ネットワーク上の IP アドレスを指定すると, その MAC アドレスが得られる arp-exe という小さなアプリケーションができた.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="/roki.log/2018/09/15/scratchPacket/#cb1-1" aria-hidden="true"></a>$ <span class="fu">sudo</span> stack --allow-different-user exec arp-exe -- eth2 192.168.33.12 <span class="co"># リポジトリ内記載の vagrant 環境上で</span></span>
<span id="cb1-2"><a href="/roki.log/2018/09/15/scratchPacket/#cb1-2" aria-hidden="true"></a><span class="ex">Just</span> 08:00:27:8b:b4:ae</span></code></pre></div>
<h2 id="サブネットの判定とデフォルトゲートウェイの取得">サブネットの判定とデフォルトゲートウェイの取得</h2>
<p>目的対象ノードの MAC アドレスを取得する必要性は先に述べた通りで, いまそれが同一ネットワーク上にあるならば, 単にそのノードを指定して ARP を送出すればよいのであるが, そうでない場合, デフォルトゲートウェイに委託しなければならない<a href="/roki.log/2018/09/15/scratchPacket/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. よって, まず実行ホストの NIC に対応するデフォルトゲートウェイをルーティングテーブル等から知る必要がある. 今回は Linux 上での動作を前提としているので, /proc/net/route を読めばよい.</p>
<p>次に, 目的対象ノードが到達範囲内にあるかどうかを判定するために, 自身のサブネットを取得する必要がある. Linux 上でこれを行う方法としては, <code>getifaddrs</code>等を呼び出すことが考えられるが, 既存のモジュール等でこれを自由に扱う手立てはどうにもないようであった. これは仕方がないので, FFI を利用して<code>getifaddrs</code>を呼び出し, 取得することとした.</p>
<h2 id="その他">その他</h2>
<p>その他はざっくりいえば, IP ヘッダ, ICMP データをそれぞれ RFC に記述のとおり並べたり, 読んだりすればよい. 結局, 詳細は下記リポジトリを参照されたい.</p>
<h2 id="実装">実装</h2>
<p>実装は, 次のリポジトリで管理している. 冒頭でも述べた通り, リポジトリ内にある Vagrantfile の環境上で動作を確認している.</p>
<div class="box has-text-centered is-shadowless">
<p><i class="fab fa-github" style="font-size: large; margin-right: 5px;"></i> <a href="https://github.com/falgon/network-basal">falgon/network-basal - Low layer network packet utilities</a></p>
</div>
<p>これには先に述べた arp-exe のほかに, 実行可能なアプリケーションとして, ping-exe と ping-exe2 が含まれている. ping-exe2 が本エントリで述べたように, イーサネットフレームを丸々扱い, ICMP Echo の送出および ICMP Echo Reply の受信を行う.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="/roki.log/2018/09/15/scratchPacket/#cb2-1" aria-hidden="true"></a>$ <span class="fu">sudo</span> stack --allow-different-user exec ping-exe2 -- --help</span>
<span id="cb2-2"><a href="/roki.log/2018/09/15/scratchPacket/#cb2-2" aria-hidden="true"></a><span class="ex">usage</span>: ping-exe [-c count] [-t timeout] [-i wait] host</span>
<span id="cb2-3"><a href="/roki.log/2018/09/15/scratchPacket/#cb2-3" aria-hidden="true"></a>$ <span class="fu">sudo</span> stack --allow-different-user exec ping-exe2 -- -c 1 8.8.8.8</span>
<span id="cb2-4"><a href="/roki.log/2018/09/15/scratchPacket/#cb2-4" aria-hidden="true"></a><span class="ex">PING</span> 8.8.8.8: 56 data bytes</span>
<span id="cb2-5"><a href="/roki.log/2018/09/15/scratchPacket/#cb2-5" aria-hidden="true"></a><span class="ex">64</span> bytes from google-public-dns-a.google.com: icmp_seq=1 ttl=63 time=11.432482s</span>
<span id="cb2-6"><a href="/roki.log/2018/09/15/scratchPacket/#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="/roki.log/2018/09/15/scratchPacket/#cb2-7" aria-hidden="true"></a><span class="ex">---</span> ping statics ---</span>
<span id="cb2-8"><a href="/roki.log/2018/09/15/scratchPacket/#cb2-8" aria-hidden="true"></a><span class="ex">1</span> packets transmitted, 1 received, 0% packet loss</span></code></pre></div>
<p>一方, ping-exe は<code>PF_INET</code>で開いたソケットを利用して, つまり ICMP データのみを構築して ICMP Echo の送出および ICMP Echo Reply の受信を行う. 冒頭で述べたような立場からすれば, これの実装に対しては特に意味はないのであるが, 一応, 同様にして動くということをみるために作ってみた.</p>
<h2 id="感想">感想</h2>
<p>Haskell でまとまったプログラムを書いたことは, 今回と<a href="/roki.log/2018/07/13/elgamalEncryption/">エルガマル暗号の実装</a>以外ではあまりなかったため, 学びがあった. ネットワークに関しても, やはり実装することでかなり整理がついたように思える. リンクレイヤーも慣れてきた感じがあるので, 気が向き次第, 今度はルーターとかを作れればよいな等と思っている.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>これに関するコンパクトで的を得た回答: <a href="https://networkengineering.stackexchange.com/a/6854">ARP request outside of LAN; Target machine or router response? - Stack Exchange</a> 2018 年 9 月 3 日アクセス.<a href="/roki.log/2018/09/15/scratchPacket/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>三角関数の公式の導出</title>
    <link href="https://roki.dev/roki.log/2018/09/6/The_definition_of_Trigonometric_function/index.html" />
    <id>https://roki.dev/roki.log/2018/09/6/The_definition_of_Trigonometric_function/index.html</id>
    <published>2018-09-06T00:00:00Z</published>
    <updated>2018-09-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="/roki.log/2018/09/6/The_definition_of_Trigonometric_function/#ref1">参考文献 1</a> では, 高木貞治氏の書いた<a href="/roki.log/2018/09/6/The_definition_of_Trigonometric_function/#ref2">解析概論</a>の緒言として示されている三角関数の古典的な導入法の問題点と, それに対する合理的な導入, 定義に関する記述があり, 興味深かったので読んでいたのだが, ふと高校数学 Ⅲ の「普通な」加法定理や積和, 和積の公式, 導関数の導出などが頭から抜けていたので, 復習がてら書くことにした. 一応, このエントリで言う三角関数 <span class="math inline">\cos\theta,\sin\theta</span> の定義は高校数学の範囲で言われる定義と同様であり, 次のとおりである.</p>
<div class="m-def">
<header class="m-def-title">
<p>
<span id="euclidean">高校数学における <span class="math inline">\cos\theta, \sin\theta</span></span>
</p>
</header>
<div class="m-def-content">
<p>直行座標平面上の原点 <span class="math inline">O(0,0)</span> を中心とする半径 <span class="math inline">1</span> の円 <span class="math inline">C</span> の <span class="math inline">x\geq 0,y\geq 0</span> の部分を <span class="math inline">C_{+}</span> としたとき, 弧度法によると, 点 <span class="math inline">A(1,0)</span>, <span class="math inline">C_{+}</span> 上の点 <span class="math inline">P(x,y)</span> を角 <span class="math inline">A O P</span> が <span class="math inline">\theta\ (0\lt\theta\leq\frac{\pi}{2})</span> となるようにとれば, 孤 <span class="math inline">A P</span> の長さは 角 <span class="math inline">A O P</span> そのもの, すなわち <span class="math inline">\theta</span> である. このとき <span class="math inline">x=\cos\theta,y=\sin\theta</span> である.</p>
</div>
</div>
<p>よくよく考えてみれば, <a href="/roki.log/2018/09/6/The_definition_of_Trigonometric_function/#hs_trignometric">この定義</a>では, 孤 <span class="math inline">A P</span> の長さおよび実数 <span class="math inline">0\lt\theta\leq\frac{\pi}{2}</span> に対し孤 <span class="math inline">A P</span> の長さが <span class="math inline">\theta</span> となる <span class="math inline">C_{+}</span> 上の点 <span class="math inline">P</span> が存在することについて, 特に説明しておらず, 定義としては不十分な点があることが考えられる. <a href="/roki.log/2018/09/6/The_definition_of_Trigonometric_function/#ref1">参考文献 1</a> にはこの問題に対する考察が綴られており, 読みやすい文体で書かれているので興味があれば読んでみることを勧める. 本エントリはそのような意味で, 特に面白みもなくただ単に高校数学 Ⅲ までの三角関数の内容を復習しているだけのものとなっているので, その点は悪しからず.</p>
<!--more-->
<h2 id="加法定理">加法定理</h2>
<p>この間で余弦定理を暗に認めたものとして利用する.</p>
<div style="text-align:center;">
<p><a title="三村周平 [CC BY-SA 3.0 (https://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:%E5%8A%A0%E6%B3%95%E5%AE%9A%E7%90%86.png"><img width="330" alt="加法定理" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/07/%E5%8A%A0%E6%B3%95%E5%AE%9A%E7%90%86.png/512px-%E5%8A%A0%E6%B3%95%E5%AE%9A%E7%90%86.png"></a></p>
</div>
<p>単位円上の二点 <span class="math inline">P(\cos p,\sin p),Q(\cos q,\sin q)</span> がある. 上図のように, 原点 <span class="math inline">O</span> に対し, <span class="math inline">O P</span> と <span class="math inline">x</span> 軸の成す角を <span class="math inline">p</span>, <span class="math inline">O Q</span> と <span class="math inline">x</span> 軸の成す角を <span class="math inline">q</span> とする. 線分 <span class="math inline">P Q</span> の長さを座標成分で表すと,</p>
<p><span class="math display">\begin{aligned}
P Q^2&amp;=&amp;(\cos q-\cos p)^2+(\sin q-\sin p)^2\\
&amp;=&amp;\cos^2 q-2\cos q\cos p+\cos^2 p+\sin^2 q-2\sin q\sin p+\sin^2 p\\
&amp;=&amp;(\sin^2 p+\cos^2 p)+(\sin^2 q+\cos^2 q)-2\cos q\cos p-2\sin q\sin p\\
&amp;=&amp;2-2(\sin p\sin q+\cos p\cos q)\tag{1}
\end{aligned}</span></p>
<p>また, 余弦定理より</p>
<p><span class="math display">\begin{aligned}
P Q^2&amp;=&amp;O P^2+O Q^2-2 O P\cdot O Q\cos(p-q)\\
&amp;=&amp;1^2+1^2-2\cdot 1\cdot 1\cdot \cos(p-q)\\
&amp;=&amp;2-2\cos(p-q)\tag{2}
\end{aligned}</span></p>
<p><span class="math inline">(1),(2)</span> より <span class="math display">2-2\cos(p-q)=2-2(\cos p\cos q+\sin p\sin q)\leftrightarrow 
\cos(p-q)=\cos p\cos q+\sin p\sin q\tag{3}</span></p>
<p>ここで, <span class="math inline">(3)</span> の <span class="math inline">q</span> を <span class="math inline">q+\frac{\pi}{2}</span> とすると, 三角関数の定義より</p>
<p><span class="math display">
\cos{p-(q+\frac{\pi}{2})}=\cos p\cos(q+\frac{\pi}{2})+\sin p\sin(q+\frac{\pi}{2})\leftrightarrow\sin(p-q)=\sin p\cos q-\cos p\sin q
</span></p>
<p><span class="math inline">q=-q</span> とおくと <span class="math display">\sin(p+q)=\sin p\cos q+\cos p\sin q\tag{4}</span></p>
<h3 id="三角関数の導関数">三角関数の導関数</h3>
<p>まず <span class="math inline">f(x)=\sin x</span> の導関数 <span class="math inline">f'(x)</span> について, 導関数の定義より</p>
<p><span class="math display">\begin{aligned}
f'(x)&amp;=&amp;\lim_{h\to 0}\frac{f(x+h)-f(x)}{h}\\
&amp;=&amp;\lim_{h\to 0}\frac{\sin(x+h)-\sin x}{h}\\
&amp;=&amp;\lim_{h\to 0}\frac{\sin x\cos h+\cos x\sin h-\sin x}{h}\ \because{\rm 加法定理}\ (4)\ {\rm より}\tag{5}
\end{aligned}
</span></p>
<p><span class="math display">
\begin{aligned}
(5)&amp;=&amp;\lim_{h\to 0}\frac{\sin x(\cos h-1)+\cos x\sin h}{h}\\
&amp;=&amp;\lim_{h\to 0}\left\{\frac{\sin x(\cos h-1)}{h}+\frac{\cos x\sin h}{h}\right\}\\ 
&amp;=&amp;\lim_{h\to 0}(\sin x\underbrace{\frac{\cos h - 1}{h}}_{A}+\cos x\frac{\sin h}{h})\tag{6}
\end{aligned}
</span></p>
<p>項 <span class="math inline">A</span> について</p>
<p><span class="math display">
\begin{aligned}
\frac{\cos h-1}{h}\cdot\frac{\cos h+1}{\cos h+1}&amp;=&amp;\frac{\cos^2h-1}{h(\cos h+1)}\\
&amp;=&amp;\frac{-\sin^2 h}{h(\cos h+1)}\ \because\sin^2+\cos^2=1\\
&amp;=&amp;\frac{-\sin h\cdot\sin h}{h(\cos h+1)}\cdot\frac{h}{h}\\
&amp;=&amp;-\frac{\sin h}{h}\cdot\frac{\sin h}{h}\cdot\frac{h}{\cos h+1}
\end{aligned}
</span></p>
<p>ここで, <span class="math inline">\displaystyle\lim_{h\to 0}-\frac{\sin h}{h}\cdot\frac{\sin h}{h}\cdot\frac{h}{\cos h+1}=0</span> だから, <span class="math inline">(6)</span> より <span class="math display">f'(x)=\sin x\cdot 0+\cos x\cdot 1=\cos x\tag{7}</span> 次に <span class="math inline">f(x)=\cos x</span> の導関数 <span class="math inline">f'(x)</span> について, 導関数の定義より</p>
<p><span class="math display">
\begin{aligned}
f'(x)&amp;=&amp;\lim_{h\to 0}\frac{f(x+h)-f(x)}{h}\\
&amp;=&amp;\lim_{h\to 0}\frac{\cos(x+h)-\cos x}{h}\\
&amp;=&amp;\lim_{h\to 0}\frac{\cos x\cos h-\sin x\sin h-\cos x}{h}\ \because{\rm 加法定理}\ (3)\ {\rm より}\tag{8}\end{aligned}</span></p>
<p><span class="math display">
\begin{aligned}
(8)&amp;=&amp;\lim_{h\to 0}\frac{\cos x(\cos h-1)-\sin x\sin h}{h}\\
&amp;=&amp;\lim_{h\to 0}\left\{\frac{\cos x(\cos h-1)}{h}-\frac{\sin x\sin h}{h}\right\}\\ 
&amp;=&amp;\lim_{h\to 0}(\cos x\frac{\cos h - 1}{h}-\sin x\frac{\sin h}{h})\\
&amp;=&amp;\cos x\cdot 0-\sin x\cdot 1\\
&amp;=&amp;-\sin x\tag{9}
\end{aligned}
</span></p>
<p>次に <span class="math inline">f(x)=\tan x</span> の導関数 <span class="math inline">f'(x)</span> について, これは <span class="math inline">f'(x)=(\tan x)'=(\frac{\sin x}{\cos x})'</span> だから</p>
<p><span class="math display">
\begin{aligned}
f'(x)&amp;=&amp;(\frac{\sin x}{\cos x})'\\
&amp;=&amp;\frac{(\sin x)'\cos x-\sin x(\cos x)'}{\cos^2 x}\\
&amp;=&amp;\frac{\cos x\cos x-\sin x(-\sin x)}{\cos^2 x}\ \because (7),(9)\ {\rm より}\\
&amp;=&amp;\frac{\cos^2 x+\sin^2 x}{\cos^2 x}\\
&amp;=&amp;\frac{1}{\cos^2 x}
\end{aligned}
</span></p>
<p>最後に <span class="math inline">f(x)=\frac{1}{\tan x}</span> の導関数 <span class="math inline">f'(x)</span> について, これは <span class="math inline">f'(x)=\frac{1}{\tan x}=(\frac{\cos x}{\sin x})'</span> だから</p>
<p><span class="math display">
\begin{aligned}
f'(x)&amp;=&amp;(\frac{\cos x}{\sin x})'\\
&amp;=&amp;\frac{(\cos x)'\sin x-\cos x(\sin x)'}{\sin^2 x}\\
&amp;=&amp;\frac{-\sin x\sin x-\cos x\cos x}{\sin^2 x}\ \because (7),(9)\ {\rm より}\\
&amp;=&amp;-\frac{\sin^2x+\cos^2x}{\sin^2x}\\
&amp;=&amp;-\frac{1}{\sin^2x}
\end{aligned}
</span></p>
<h2 id="和積の公式を用いた方法">和積の公式を用いた方法</h2>
<p><span class="math inline">(5),(8)</span> の部分では加法定理を用いたが, 加法定理より導出できる和積の公式を用いても同様にして導出できる. <span class="math inline">(4)</span> より</p>
<p><span class="math display">
\sin(p+q)=\sin p\sin q+\cos p\sin q\tag{10}
</span> <span class="math display">
\sin(p-q)=\sin p\sin q-\cos p\sin q\tag{11}
</span></p>
<p><span class="math inline">(10)+(11)</span> より <span class="math display">\sin(p+q)+\sin(p-q)=2\sin p\cos q\leftrightarrow 
\sin p\cos q=\frac{\sin(p+q)+\sin(p-q)}{2}\tag{12}</span> また, <span class="math inline">(3)</span> より</p>
<p><span class="math display">
\cos(p+q)=\cos p\cos q-\sin p\sin q\tag{13}
</span> <span class="math display">
\cos(p-q)=\cos p\cos q+\sin p\sin q\tag{14}
</span></p>
<p><span class="math inline">(13)-(14)</span> より <span class="math display">\cos(p+q)-\cos(p-q)=-2\sin p\sin q\leftrightarrow 
\sin p\sin q=-\frac{\cos(p+q)-\cos(p-q)}{2}\tag{15}</span></p>
<p><span class="math inline">(12),(15)</span> は積和の公式といわれる (あともう 1 つ積和の公式と言われるものがあるが, 今回は利用しないので省略). ここで, <span class="math inline">(12)</span> に対し <span class="math inline">p=\frac{x-y}{2},q=\frac{x+y}{2}</span> とすると,</p>
<p><span class="math display">\begin{aligned}
\sin\frac{x-y}{2}\cos\frac{x+y}{2}&amp;=&amp;\frac{\sin(\frac{x-y}{2}+\frac{x+y}{2})+\sin(\frac{x-y}{2}-\frac{x+y}{2})}{2}\\
&amp;=&amp;\frac{\sin x-\sin y}{2}
\end{aligned}
</span></p>
<p>ゆえに <span class="math display">\sin x-\sin y=2\cos\frac{x+y}{2}\sin\frac{x-y}{2}\tag{16}</span> また \(\) に対し <span class="math inline">p=\frac{x+y}{2},q=\frac{x-y}{2}</span> とすると,</p>
<p><span class="math display">
\begin{aligned}
\sin\frac{x+y}{2}\sin\frac{x-y}{2}&amp;=&amp;-\frac{\cos(\frac{x+y}{2}+\frac{x-y}{2})-\cos(\frac{x+y}{2}-\frac{x-y}{2})}{2}\\
&amp;=&amp;-\frac{\cos x-\cos y}{2}
\end{aligned}
</span></p>
<p>ゆえに</p>
<p><span class="math display">\cos x-\cos y=-2\sin\frac{x+y}{2}\sin\frac{x-y}{2}\tag{17}</span> <span class="math inline">(16),(17)</span> が和積の公式である (あともう 2 つ和積の公式と言われるものがあるが, 今回は利用しないので省略). <span class="math inline">(16)</span> をつかって <span class="math inline">\displaystyle f'(x)=\lim_{h\to 0}\frac{\sin(x+h)-\sin x}{h}</span> を変形すると,</p>
<p><span class="math display">\begin{aligned}
f'(x)&amp;=&amp;\lim_{h\to 0}\frac{\sin(x+h)-\sin x}{h}\\
&amp;=&amp;\lim_{h\to 0}\frac{2\cos(\frac{2x+h}{2})\sin\frac{h}{2}}{h}\ \because (16)\\
&amp;=&amp;\lim_{h\to 0}\frac{\cos(\frac{2x+h}{2})\sin\frac{h}{2}}{\frac{h}{2}}\\
&amp;=&amp;\cos(\frac{2x}{2})\\
&amp;=&amp;\cos x
\end{aligned}</span></p>
<p>と <span class="math inline">(7)</span> と同様の結果が得られる. また, <span class="math inline">(17)</span> をつかって <span class="math inline">\displaystyle f'(x)=\lim_{h\to 0}\frac{\cos(x+h)-\cos x}{h}</span> を変形すると,</p>
<p><span class="math display">\begin{aligned}
f'(x)&amp;=&amp;\lim_{h\to 0}\frac{\cos(x+h)-\cos x}{h}\\
&amp;=&amp;\lim_{h\to 0}\frac{-2\sin(\frac{2x+h}{2})\sin\frac{h}{2}}{h}\ \because (17)\\
&amp;=&amp;\lim_{h\to 0}-\frac{\sin(\frac{2x+h}{2})\sin\frac{h}{2}}{\frac{h}{2}}\\
&amp;=&amp;-\sin(\frac{2x}{2})\\
&amp;=&amp;-\sin x
\end{aligned}
</span></p>
<p>と <span class="math inline">(9)</span> と同様の結果が得られる.</p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li>『<a id="ref1" href="http://www.ms.u-tokyo.ac.jp/~t-saito/jd/%E4%B8%89%E8%A7%92%E9%96%A2%E6%95%B0.pdf">三角関数とは何か</a>』2018 年 9 月 6 日アクセス.</li>
<li><a id="ref2" class="disabled">高木貞治 (1983) 『解析概論』岩波書店</a></li>
</ol>]]></summary>
</entry>
<entry>
    <title>Haskell で D-Bus から systemd unit を制御する</title>
    <link href="https://roki.dev/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/index.html" />
    <id>https://roki.dev/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/index.html</id>
    <published>2018-08-17T00:00:00Z</published>
    <updated>2018-08-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>D-Bus とはメッセージバスシステムであり, アプリケーション間で互いにやりとりを行うためのプロセス間通信実装の 1 つである. システムデーモン(新しいハードウェアデバイスの追加やプリンタキューの変更などのイベント等)と, ユーザー単位のログインセッションデーモン(ユーザーアプリケーション間の一般的なIPC)を提供する<a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>現代的な Linux カーネルの init プロセスにて起動される systemd デーモンおよびその補助デーモンは, D-Bus にいくつかの API を公開している. 私の観測範囲内において, C や Python, Go 等でこれらを利用する例はそこそこ見たことがあるのだが, Haskell での取り組みは一切見たことがなかったので, 少々これらで遊んで見た日記として本エントリに記す.</p>
<!--more-->
<h2 id="d-bus-api-の確認">D-Bus API の確認</h2>
<p>実行環境は, 次の通りである.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb1-1" aria-hidden="true"></a>$ <span class="fu">uname</span> -a</span>
<span id="cb1-2"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb1-2" aria-hidden="true"></a><span class="ex">Linux</span> vagrant 4.15.0-20-generic #21-Ubuntu SMP Tue Apr 24 06:16:15 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span>
<span id="cb1-3"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb1-3" aria-hidden="true"></a>$ <span class="ex">systemd</span> --version</span>
<span id="cb1-4"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb1-4" aria-hidden="true"></a><span class="ex">systemd</span> 237</span>
<span id="cb1-5"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb1-5" aria-hidden="true"></a><span class="ex">+PAM</span> +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD -IDN2 +IDN -PCRE2 default-hierarchy=hybrid</span></code></pre></div>
<p>D-Bus に公開されている API を利用する際は, とくに高度なラッパーライブラリを用いないような場合においては, <code>dbus-send</code>あるいは<code>gdbus</code>等で全体の構造, インタフェース, メソッドおよびフィールドメンバーを確認するとよい.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-1" aria-hidden="true"></a>$ <span class="kw">function</span><span class="fu"> syst()</span><span class="kw">{</span> <span class="va">r=$(</span><span class="ex">gdbus</span> introspect --system --dest org.freedesktop.systemd1 --object-path /org/freedesktop/systemd1<span class="va">)</span>; <span class="bu">echo</span> <span class="va">${r}</span> <span class="kw">|</span> <span class="fu">head</span> -n <span class="va">$1</span> <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">&quot;More than&quot;</span> <span class="va">$(($(</span><span class="bu">echo</span> <span class="va">${r}</span> <span class="kw">|</span> <span class="fu">wc</span> -l<span class="va">)</span> - <span class="va">$1))</span> <span class="st">&quot;lines...&quot;</span><span class="kw">;</span> <span class="kw">}</span></span>
<span id="cb2-2"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-2" aria-hidden="true"></a>$ <span class="ex">syst</span> 10</span>
<span id="cb2-3"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-3" aria-hidden="true"></a><span class="ex">node</span> /org/freedesktop/systemd1 {</span>
<span id="cb2-4"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-4" aria-hidden="true"></a>  <span class="ex">interface</span> org.freedesktop.DBus.Peer {</span>
<span id="cb2-5"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-5" aria-hidden="true"></a>    <span class="ex">methods</span>:</span>
<span id="cb2-6"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-6" aria-hidden="true"></a>      <span class="fu">Ping()</span>;</span>
<span id="cb2-7"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-7" aria-hidden="true"></a>      <span class="ex">GetMachineId</span>(out s machine_uuid);</span>
<span id="cb2-8"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-8" aria-hidden="true"></a>    <span class="ex">signals</span>:</span>
<span id="cb2-9"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-9" aria-hidden="true"></a>    <span class="ex">properties</span>:</span>
<span id="cb2-10"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-10" aria-hidden="true"></a>  };</span>
<span id="cb2-11"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-11" aria-hidden="true"></a>  <span class="ex">interface</span> org.freedesktop.DBus.Introspectable {</span>
<span id="cb2-12"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-12" aria-hidden="true"></a>    <span class="ex">methods</span>:</span>
<span id="cb2-13"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb2-13" aria-hidden="true"></a><span class="ex">More</span> than 397 lines...</span></code></pre></div>
<p>このインタフェース表記の意味するところに関する詳細は, D-bus 仕様の Type System セクション<a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>に記載されている.</p>
<h2 id="d-bus-の-haskell-バインドの利用">D-Bus の Haskell バインドの利用</h2>
<p><a href="http://hackage.Haskell.org/package/dbus">dbus</a> が利用できる. 例えば, 以下に示す<code>StartUnit</code>, <code>StopUnit</code>は,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb3-1" aria-hidden="true"></a>$ <span class="ex">gdbus</span> introspect --system --dest org.freedesktop.systemd1 --object-path /org/freedesktop/systemd1 <span class="kw">|</span> <span class="fu">grep</span> -e StartUnit -e StopUnit -w -A 2</span>
<span id="cb3-2"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb3-2" aria-hidden="true"></a>      <span class="ex">StartUnit</span>(in  s arg_0,</span>
<span id="cb3-3"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb3-3" aria-hidden="true"></a>                <span class="kw">in</span>  <span class="ex">s</span> arg_1,</span>
<span id="cb3-4"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb3-4" aria-hidden="true"></a>                <span class="ex">out</span> o arg_2);</span>
<span id="cb3-5"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb3-5" aria-hidden="true"></a><span class="ex">--</span></span>
<span id="cb3-6"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb3-6" aria-hidden="true"></a>      <span class="ex">StopUnit</span>(in  s arg_0,</span>
<span id="cb3-7"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb3-7" aria-hidden="true"></a>               <span class="kw">in</span>  <span class="ex">s</span> arg_1,</span>
<span id="cb3-8"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb3-8" aria-hidden="true"></a>               <span class="ex">out</span> o arg_2);</span></code></pre></div>
<p>次のようにして呼び出せる.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb4-2"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">DBus</span></span>
<span id="cb4-4"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">DBus.Client</span></span>
<span id="cb4-5"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-5" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Int</span> (<span class="dt">Int32</span>)</span>
<span id="cb4-6"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-7" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Unit</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb4-8"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-8" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Mode</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb4-9"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-9" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">SignalNum</span> <span class="ot">=</span> <span class="dt">Int32</span></span>
<span id="cb4-10"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-10" aria-hidden="true"></a></span>
<span id="cb4-11"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-11" aria-hidden="true"></a><span class="ot">systemdObjectPath ::</span> <span class="dt">ObjectPath</span></span>
<span id="cb4-12"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-12" aria-hidden="true"></a>systemdObjectPath <span class="ot">=</span> objectPath_ <span class="st">&quot;/org/freedesktop/systemd1&quot;</span></span>
<span id="cb4-13"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-13" aria-hidden="true"></a></span>
<span id="cb4-14"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-14" aria-hidden="true"></a><span class="ot">systemdInterfaceName ::</span> <span class="dt">InterfaceName</span></span>
<span id="cb4-15"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-15" aria-hidden="true"></a>systemdInterfaceName <span class="ot">=</span> interfaceName_ <span class="st">&quot;org.freedesktop.systemd1.Manager&quot;</span></span>
<span id="cb4-16"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-16" aria-hidden="true"></a></span>
<span id="cb4-17"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-17" aria-hidden="true"></a><span class="ot">systemdDestination ::</span> <span class="dt">BusName</span></span>
<span id="cb4-18"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-18" aria-hidden="true"></a>systemdDestination <span class="ot">=</span> busName_ <span class="st">&quot;org.freedesktop.systemd1&quot;</span></span>
<span id="cb4-19"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-19" aria-hidden="true"></a></span>
<span id="cb4-20"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-20" aria-hidden="true"></a><span class="ot">methodSub ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MethodCall</span></span>
<span id="cb4-21"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-21" aria-hidden="true"></a>methodSub <span class="ot">=</span> methodCall systemdObjectPath systemdInterfaceName <span class="op">.</span> memberName_</span>
<span id="cb4-22"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-22" aria-hidden="true"></a></span>
<span id="cb4-23"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-23" aria-hidden="true"></a><span class="ot">systemdCall ::</span> <span class="dt">Client</span> <span class="ot">-&gt;</span> <span class="dt">MethodCall</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Variant</span>]</span>
<span id="cb4-24"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-24" aria-hidden="true"></a>systemdCall <span class="ot">=</span> (<span class="op">.</span>) (<span class="fu">fmap</span> methodReturnBody) <span class="op">.</span> call_</span>
<span id="cb4-25"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-25" aria-hidden="true"></a></span>
<span id="cb4-26"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-26" aria-hidden="true"></a><span class="ot">controlUnit ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Client</span> <span class="ot">-&gt;</span> <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Mode</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Variant</span>]</span>
<span id="cb4-27"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-27" aria-hidden="true"></a>controlUnit med cli unit mode <span class="ot">=</span> systemdCall cli (methodSub med) {</span>
<span id="cb4-28"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-28" aria-hidden="true"></a>    methodCallDestination <span class="ot">=</span> <span class="dt">Just</span> systemdDestination,</span>
<span id="cb4-29"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-29" aria-hidden="true"></a>    methodCallBody <span class="ot">=</span> <span class="fu">map</span> toVariant [unit, mode]</span>
<span id="cb4-30"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-30" aria-hidden="true"></a>}</span>
<span id="cb4-31"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-31" aria-hidden="true"></a></span>
<span id="cb4-32"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-32" aria-hidden="true"></a><span class="ot">startUnit ::</span> <span class="dt">Client</span> <span class="ot">-&gt;</span> <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Mode</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Variant</span>]</span>
<span id="cb4-33"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-33" aria-hidden="true"></a>startUnit <span class="ot">=</span> controlUnit <span class="st">&quot;StartUnit&quot;</span></span>
<span id="cb4-34"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-34" aria-hidden="true"></a></span>
<span id="cb4-35"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-35" aria-hidden="true"></a><span class="ot">stopUnit ::</span> <span class="dt">Client</span> <span class="ot">-&gt;</span> <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Mode</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Variant</span>]</span>
<span id="cb4-36"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb4-36" aria-hidden="true"></a>stopUnit <span class="ot">=</span> controlUnit <span class="st">&quot;StopUnit&quot;</span></span></code></pre></div>
<p>以下に示す<code>ListUnitsByNames</code><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>は,</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb5-1" aria-hidden="true"></a>$ <span class="ex">gdbus</span> introspect --system --dest org.freedesktop.systemd1 --object-path /org/freedesktop/systemd1 <span class="kw">|</span> <span class="fu">grep</span> ListUnitsByNames -w -A 1</span>
<span id="cb5-2"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb5-2" aria-hidden="true"></a>      <span class="ex">ListUnitsByNames</span>(in  as arg_0,</span>
<span id="cb5-3"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb5-3" aria-hidden="true"></a>                       <span class="ex">out</span> a(ssssssouso) <span class="ex">arg_1</span>);</span></code></pre></div>
<p>次のようにして呼び出せる.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb6-1" aria-hidden="true"></a><span class="ot">listUnitsByNames ::</span> <span class="dt">IsValue</span> a <span class="ot">=&gt;</span> <span class="dt">Client</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Variant</span>]</span>
<span id="cb6-2"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb6-2" aria-hidden="true"></a>listUnitsByNames cli var <span class="ot">=</span> systemdCall cli (methodSub <span class="st">&quot;ListUnitsByNames&quot;</span>) {</span>
<span id="cb6-3"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb6-3" aria-hidden="true"></a>    methodCallDestination <span class="ot">=</span> <span class="dt">Just</span> systemdDestination,</span>
<span id="cb6-4"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb6-4" aria-hidden="true"></a>    methodCallBody <span class="ot">=</span> [toVariant var]</span>
<span id="cb6-5"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb6-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>動作確認のためのユニットを適当に置いておく<a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-1" aria-hidden="true"></a>$ <span class="fu">mkdir</span> -p /opt/writehello/bin</span>
<span id="cb7-2"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-2" aria-hidden="true"></a>$ <span class="fu">sudo</span> sh -c <span class="st">&quot;echo </span><span class="dt">\&quot;</span><span class="st">#\!/bin/bash\nwhile :\ndo\n\tsleep 3\n\techo </span><span class="dt">\&quot;</span><span class="st">hello</span><span class="dt">\&quot;</span><span class="st">\ndone</span><span class="dt">\&quot;</span><span class="st">&quot;</span> <span class="op">&gt;</span> writehello.sh</span>
<span id="cb7-3"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-3" aria-hidden="true"></a>$ <span class="fu">sudo</span> chmod +x /opt/writehello/bin/writehello.sh</span>
<span id="cb7-4"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-4" aria-hidden="true"></a>$ <span class="fu">sudo</span> sh -c <span class="st">&quot;echo </span><span class="dt">\&quot;</span><span class="st">[Unit]\nDescription = hello daemon\nConditionPathExists = /opt/writehello/bin/writehello.sh\n\n[Service]\nExecStart = /opt/writehello/bin/writehello.sh\nRestart = always\nType = simple\n\n[Install]\nWantedBy = multi-user.target</span><span class="dt">\&quot;</span><span class="st">&quot;</span> <span class="op">&gt;</span> /etc/systemd/system/writehello.service</span>
<span id="cb7-5"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-5" aria-hidden="true"></a>$ <span class="fu">sudo</span> chmod -x /etc/systemd/system/writehello.service</span>
<span id="cb7-6"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-6" aria-hidden="true"></a>$ <span class="fu">sudo</span> chmod o-w /etc/systemd/system/writehello.service</span>
<span id="cb7-7"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-7" aria-hidden="true"></a>$ <span class="fu">sudo</span> systemd-analyze verify /etc/systemd/system/writehello.service</span>
<span id="cb7-8"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-8" aria-hidden="true"></a><span class="ex">Attempted</span> to remove disk file system, and we can<span class="st">'t allow that.</span></span>
<span id="cb7-9"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-9" aria-hidden="true"></a><span class="st">$ sudo systemctl daemon-reload</span></span>
<span id="cb7-10"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-10" aria-hidden="true"></a><span class="st">$ sudo systemctl start writehello.service &amp;&amp; journalctl -f -u writehello.service &amp; sleep 10 &amp;&amp; sudo kill $! &amp;&amp; sudo systemctl stop writehello.service</span></span>
<span id="cb7-11"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-11" aria-hidden="true"></a><span class="st">[1] 2001</span></span>
<span id="cb7-12"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-12" aria-hidden="true"></a><span class="st">-- Logs begin at Fri 2018-08-17 16:19:05 UTC. --</span></span>
<span id="cb7-13"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-13" aria-hidden="true"></a><span class="st">Aug 17 16:19:13 vagrant systemd[1]: Started hello daemon.</span></span>
<span id="cb7-14"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-14" aria-hidden="true"></a><span class="st">Aug 17 16:19:16 vagrant writehello.sh[1989]: hello</span></span>
<span id="cb7-15"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-15" aria-hidden="true"></a><span class="st">Aug 17 16:19:19 vagrant writehello.sh[1989]: hello</span></span>
<span id="cb7-16"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb7-16" aria-hidden="true"></a><span class="st">Aug 17 16:19:22 vagrant writehello.sh[1989]: hello</span></span></code></pre></div>
<p>先の関数らから writehello.service ユニットを制御する.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">DBus.Client</span> (connectSystem)</span>
<span id="cb8-4"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</span>
<span id="cb8-5"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-5" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (mapM_, (&lt;=&lt;))</span>
<span id="cb8-6"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-7" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-8"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-8" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-9"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-9" aria-hidden="true"></a>    client <span class="ot">&lt;-</span> connectSystem</span>
<span id="cb8-10"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-10" aria-hidden="true"></a>    args <span class="ot">&lt;-</span> getArgs</span>
<span id="cb8-11"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-11" aria-hidden="true"></a>    <span class="fu">mapM_</span> (<span class="fu">print</span> <span class="op">&lt;=&lt;</span> <span class="fu">flip</span> (startUnit client) <span class="st">&quot;replace&quot;</span>) args</span>
<span id="cb8-12"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb8-12" aria-hidden="true"></a>    <span class="fu">print</span> <span class="op">=&lt;&lt;</span> listUnitsByNames client args</span></code></pre></div>
<p>引数に writehello.service を指定してスーパーユーザで実行すると, 次のような出力が得られる.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb9-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb9-1" aria-hidden="true"></a>[<span class="ex">Variant</span> (ObjectPath <span class="st">&quot;/org/freedesktop/systemd1/job/1053&quot;</span>)]</span>
<span id="cb9-2"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb9-2" aria-hidden="true"></a>[<span class="ex">Variant</span> [(<span class="st">&quot;writehello.service&quot;</span>, <span class="st">&quot;hello daemon&quot;</span>, <span class="st">&quot;loaded&quot;</span>, <span class="st">&quot;active&quot;</span>, <span class="st">&quot;running&quot;</span>, <span class="st">&quot;&quot;</span>, ObjectPath <span class="st">&quot;/org/freedesktop/systemd1/unit/writehello_2eservice&quot;</span>, 0, <span class="st">&quot;&quot;</span>, ObjectPath <span class="st">&quot;/&quot;</span>)]]</span></code></pre></div>
<p>停止も忘れずに.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#cb10-1" aria-hidden="true"></a><span class="fu">mapM_</span> (<span class="fu">print</span> <span class="op">&lt;=&lt;</span> <span class="fu">flip</span> (stopUnit client) <span class="st">&quot;replace&quot;</span>) args </span></code></pre></div>
<p>なお, 本エントリにおける一連の実装とその他の systemd D-Bus API を利用したいくつかの snippets を下記リポジトリにて管理している.</p>
<div class="box has-text-centered is-shadowless">
<p><i class="fab fa-github mr-2"></i> <a href="https://bitbucket.org/r0ki/systemdplhs/src/master/">r0ki/systemdplhs - Snippets collection that controls systemd from D-Bus with Haskell.</a></p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>説明は<a href="https://www.freedesktop.org/wiki/Software/dbus/#index1h1">公式ページ</a>から.<a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>“D-Bus Specification”, <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#type-system" class="uri">https://dbus.freedesktop.org/doc/dbus-specification.html#type-system</a> 2018 年 8 月 17 日アクセス.<a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Note: <code>ListUnitsByName</code> は systemd v230 以上を要する.<a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><code>systemd-analyze verify</code>の結果で, <code>Attempted to remove disk file system, and we can't allow that.</code>というメッセージが出力されているが, これは systemd 237-4 および 238 でのバグ(<a href="https://github.com/systemd/systemd/issues/8592">#8592</a>)との報告がある.<a href="/roki.log/2018/08/17/controlSystemdByDBusAndHaskell/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>AWS EC2 の各種環境を自動構築して distcc による分散コンパイルを実行する</title>
    <link href="https://roki.dev/roki.log/2018/08/15/aws_ec2_distcc/index.html" />
    <id>https://roki.dev/roki.log/2018/08/15/aws_ec2_distcc/index.html</id>
    <published>2018-08-15T00:00:00Z</published>
    <updated>2018-08-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>クラウド上でなにか作れというような大学の課題で, 入力パラメータに応じて AWS EC2 インスタンス及びネットワーク周辺と distcc の環境構築を実行して, その上で分散コンパイルをして S3 へアップロードできれば, そこそこクラウドでやった意味があるといえるのかななどと思いつき, 軽い気持ちで作ってみた記録.</p>
<!--more-->
<h2 id="構成">構成</h2>
<p>構成そのものはかなり単純だと思う. はじめに, いくつかのパラメータを指定する. 数は多いが, AWS EC2 の環境構築に最低限必要となるような要素に限られているはず.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fedcc%2Fblob%2F5f4cd53830691275e5c250ef2051adca9d1162d6%2FREADME.md%23L11-L44&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>ここで指定したパラメータに応じて, 環境を構築する. その際, AWS のユーザーデータ<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>機能を使って, distcc とコンパイラ<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>のセットアップ, ホストインスタンス(実際にコンパイルを実行するインスタンス)の決定, 各インスタンスの環境構築における進捗の同期等を行い, ビルドスクリプトを実行する.</p>
<p>一応, ここに酷いアクティビティ図がある.</p>
<div style="text-align:center; height: 400px; overflow-y: scroll;">
<p><img width="700" src="https://raw.githubusercontent.com/falgon/edcc/4a052baece667b6baf6d3e41ff3f0741faee5bed/assets/fig.png" alt="ugly activity diagram"></p>
</div>
<h2 id="実装">実装</h2>
<p>実装は, 次のリポジトリで管理している.</p>
<div class="box has-text-centered is-shadowless">
<p><i class="fab fa-github mr-2"></i> <a href="https://github.com/falgon/edcc">falgon/edcc - Simple and tiny comprehensive management tool for distributed compilation using distcc on AWS EC2.</a></p>
</div>
<p>まず, 起動したインスタンスのすべてに必要となるパッケージのインストールやセットアップを実行する必要があるが, これは構成にて述べたように, AWS EC2 の機能のうちの 1 つである, ユーザーデータ<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>を利用して実行することとした.</p>
<p>予め使用言語に対する指定として, Go で実装することを定められていたので, 今回の実装を Go で行ったことに対する深い意味合いは特別ないが, とりあえずそこまで深く考えず Go の便利な標準パッケージ, <code>text/template</code>を利用して, 一程度の情報伝達を行うこととした. <code>text/template</code>は, かなりお手軽に<a href="/roki.log/2018/07/23/ec2failover/">設定ファイルの生成</a>のほか, トークンの衝突さえなければ, コードに直接埋め込むことができるので, それを元にコードの生成をすることもでき, 大変良い.</p>
<p>ビルドスクリプトおよびセットアップスクリプトは, それぞれ, ビルド実行のスクリプト<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>と, ユーザーデータとして渡される, 必要パッケージのセットアップスクリプト<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>のことを示している. ビルドスクリプトは, 以下に示す変数を利用して任意に記述してもらう<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>ものとして, セットアップスクリプトは, 殆どの場合, 中身を弄る必要はないと思われる. 今のところ, 各スクリプトは bash スクリプトとして記述する必要がある. それぞれで利用できる変数は, 次の通りである.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fedcc%2Fblob%2F5f4cd53830691275e5c250ef2051adca9d1162d6%2FREADME.md%23L47-L63&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<p>大体各変数の予測はつくだろうし, 説明にもあるとおりなのだが, 一点, 必ずビルドスクリプト内に記述しなければならないのは, <code>{{.build_success}}</code>または<code>{{.build_failed}}</code>である. これは, <code>{{.Include_WriteStatus}}</code>を予め記述しておくことで利用できるようになる. それぞれビルドの成功, また失敗といった結果を通知するための命令(内部はただの bash 関数)であるが, このどちらをも指定しなかった場合, ビルドはまだ終わっていないと認識して, 永遠に停止することはない(マネジメントコンソールや awscli などで自分でクリーンナップを行う必要がある.).</p>
<p>この仕様は, Travis CI を利用しているときに, ステータスコードが 0 以外の場合においても, 処理を続行したいときが個人的には何度かあったことに由来している.</p>
<p>また, セットアップの進捗をインスタンス間でどのように同期するかであるが, EC2 においても各メタ情報を HTTP リクエストで取得できることを真似て, 各インスタンスで nginx による HTTP サーバ<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>を稼働させ, そのトップページに自身の状態の JSON を出力しておき, それを curl で得るということにした.</p>
<p>結局, そのほかの詳細はリポジトリ内の README を見てほしい. 実行例は次の通りである.</p>
<div class="mb-2 mt-2" style="max-height: 400px; overflow-y: scroll;">
<script src="https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Ffalgon%2Fedcc%2Fblob%2F5f4cd53830691275e5c250ef2051adca9d1162d6%2FREADME.md%23L69-L102&style=github&showLineNumbers=on&showFileMeta=on&fetchFromJsDelivr=on"></script>
</div>
<h2 id="感想">感想</h2>
<p>とにかく時間のない中であったので, 妥協してしまった点がいくらかあり, その点で個人的には悔しい部分があるが, 今回の実装で大分総合的に EC2 関係の IaaS やら SaaS 周りを活用できたかと思うので, 取り組めたこと自体には満足をしている.</p>
<p>別の話題だが, 講義内で利用する AWS リソースの支払いは, ありがたい事に大学側が持っていてくれていたのだが, これでもう講義が終わってしまうので, 犬が西向きゃ尾は東というものであるが, 続けて自分で本格的に取り組むのには, ある程度の出費が必要となる. 今のところ, まだ無料利用枠は残っているので, それを利用できることが救いであるが, 講義でよく使っていた t2.medium と無料利用枠対象の t2.micro とでは, やはり処理性能に若干の違いを感じる. なんだか今回のエントリには, やたらと諺が出てきて自分も奇怪に感じるが, まあこれは, 起きて半畳寝て一畳, 天下取っても二合半ということなのだろう.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>“Running Commands on Your Linux Instance at Launch” <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html" class="uri">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html</a> 2018 年 8 月 15 日アクセス.<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>デフォルト(<a href="https://github.com/falgon/edcc/blob/5f4cd53830691275e5c250ef2051adca9d1162d6/src/setup.sh">setup.sh</a>)では GCC 8.1.0<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>“Running Commands on Your Linux Instance at Launch” <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html" class="uri">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html</a> 2018 年 8 月 15 日アクセス.<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>例として, 厳密性を多いに省けば, Travis CI で実行される, <code>.travis.yml</code>の<code>script</code>セクションようなもの.<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>同じく, Travis CI で実行される, <code>.travis.yml</code>の<code>install</code>セクションのようなもの.<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><a href="https://github.com/falgon/edcc/tree/5f4cd53830691275e5c250ef2051adca9d1162d6/build_script_example">build_script_example/</a>にいくつかのサンプルがある.<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>このとき 80 番ポートを利用するが, デフォルトの設定では VPC を 10.0.0.0/16, サブネットを 10.0.0.0/24 とし, 80 番ポートのインバウンド設定を, セキュリティグループにより 10.0.0.0/24 と設定するので, 外部からの HTTP アクセスに対して応答することはない. よって, インスタンスの状態がインターネットに漏れてしまうといった懸念は必要ない. なお自動構築時, このサブネット中にすべてのインスタンスを設定するため, 自ずと分散コンパイルを行うインスタンスの最大数は 256 となる. それよりも増やしたいのであれば, 単にパラメータを変えればよいが, あまり台数を増やしても, 然程効果はないと思われる.<a href="/roki.log/2018/08/15/aws_ec2_distcc/#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>AWS SNS + S3 でバケット内の状態を即座に EC2 に反映するまで</title>
    <link href="https://roki.dev/roki.log/2018/08/1/aws_sns_s3_ec2/index.html" />
    <id>https://roki.dev/roki.log/2018/08/1/aws_sns_s3_ec2/index.html</id>
    <published>2018-08-01T00:00:00Z</published>
    <updated>2018-08-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>ウェブアプリケーションが EC2 上で動作していて, そのコンテンツ内容を S3 バケットによって管理しているシチュエーションにおいて, S3 バケットの状態を即座にそのウェブアプリケーションに反映させたいという事例はよくあると思う(ステージング云々は, 一旦置いておくとして). 本エントリは, AWS SNS による HTTP リクエストをトリガーに, S3 バケットの状態を EC2 上のコンテンツへ即座に反映するための構造と簡単な実装について取り上げる.</p>
<!--more-->
<h2 id="システムの全体構造">システムの全体構造</h2>
<p>上記の要件を達成する方法はいくつかあるだろうが, 今回は次のような構造を取ることとした.</p>
<figure>
<img src="/roki.log/2018/08/1/aws_sns_s3_ec2/UD.png" title="全体図" width="400" alt /><figcaption>全体図</figcaption>
</figure>
<p>今回 EC2 インスタンス上では, Nginx および Go で実装したウェブアプリケーションサーバを Fast-CGI で動かすこととした. S3 にコンテンツをアップロードしたり削除等の操作をすると, SNS トピックに対して通知を発行する. SNS はこれに対して, 設定したエンドポイント(今回は EC2 インスタンス) へ HTTP POST リクエストを発行し, EC2 インスタンスはこれに応じて, S3 バケットと同期を実行する. 至ってシンプルな構造である.</p>
<h2 id="実装">実装</h2>
<p>EC2 インスタンスで稼働するシンプルなウェブサーバの実装, および各種設定ファイルは, 次のリポジトリの通りである.</p>
<div class="box has-text-centered is-shadowless">
<p><i class="fab fa-github mr-2"></i> <a href="https://github.com/falgon/tinyGoWebServer">falgon/tinyGoWebServer - Tiny Go Web Server. AWS SNS + S3 + EC2 + Nginx Fast-CGI technology automatically synchronizes content on S3 bucket.</a></p>
</div>
<p>なお, S3 バケットとの同期処理が失敗した場合, 別の SNS トピックを用いて, 失敗の旨のメールを管理者に送信するようにしてある. リポジトリ内の README にも記してあるが, 同期を実行するスクリプト, およびウェブサーバの実行ファイルは, systemd で管理することを前提として, <a href="http://www.pathname.com/fhs/">Filesystem Hierarchy Standard</a> に従い, 配置することとした.</p>]]></summary>
</entry>
<entry>
    <title>ベイズの定理</title>
    <link href="https://roki.dev/roki.log/2018/07/26/bayestheorem/index.html" />
    <id>https://roki.dev/roki.log/2018/07/26/bayestheorem/index.html</id>
    <published>2018-07-26T00:32:00Z</published>
    <updated>2018-07-26T00:32:00Z</updated>
    <summary type="html"><![CDATA[<p>ベイズの定理の導出から, モンティ・ホール問題への応用まで.</p>
<h2 id="ベイズの定理の導出">ベイズの定理の導出</h2>
<p>事象 <span class="math inline">A</span> が発生する確率を「<span class="math inline">P(A) = A</span> が発生する確率 <span class="math inline">\div</span> すべての事象の数」と書くとき, ベイズの定理は</p>
<div class="m-thm">
<header class="m-thm-title">
<p>
<span id="baysestheorem">ベイズの定理</span>
</p>
</header>
<div class="m-thm-content">
事象 <span class="math inline">B</span> のもとで事象 <span class="math inline">A</span> が発生する確率 <span class="math display">P(A\mid B)=\dfrac{P(B\mid A)P(A)}{P(B)}\ (P(B)\gt 0)</span>
</div>
</div>
<p>と定義される. 以下ベイズの定理を導出する. 例として, 起こり得る全ての事象の数を <span class="math inline">200</span>, 事象 <span class="math inline">A</span>, 事象 <span class="math inline">B</span>(以下単に <span class="math inline">A</span>, <span class="math inline">B</span> と書く)が発生した回数をそれぞれ <span class="math inline">60,\ 40</span> とし, <span class="math inline">A</span> および <span class="math inline">B</span> が発生した確率を <span class="math inline">10</span> とする. 簡単のために, この事象関係を表すベン図を次に示す<a href="/roki.log/2018/07/26/bayestheorem/#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<figure>
<img src="/roki.log/2018/07/26/bayestheorem/bayes_venn.png" title="ある事象を表したベン図" alt /><figcaption>ある事象を表したベン図</figcaption>
</figure>
<!--more-->
<p>まず, <span class="math inline">A</span> および <span class="math inline">B</span> が発生する確率 <span class="math inline">P(A\cap B) = P(B\cap A)</span> を求める. <span class="math inline">A,\ B</span> がそれぞれ発生する確率は, <span class="math display">\begin{array}{lcl}
P(A)&amp;=&amp;\dfrac{60}{200}=\dfrac{3}{10}\\ P(B)&amp;=&amp;\dfrac{40}{200}=\dfrac{1}{5}
\end{array}</span> である<a href="/roki.log/2018/07/26/bayestheorem/#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. <span class="math inline">B</span> の下で <span class="math inline">A</span> が発生する確率と, <span class="math inline">A</span> の下で <span class="math inline">B</span> が発生する確率は,</p>
<p><span class="math display">\begin{array}{lclcl}
P(A\mid B)&amp;=&amp;\dfrac{10}{40}&amp;=&amp;\dfrac{1}{4}\\
P(B\mid A)&amp;=&amp;\dfrac{10}{60}&amp;=&amp;\dfrac{1}{6}
\end{array}
</span></p>
<p>である. そもそも, <span class="math inline">B</span> が発生しなければ, <span class="math inline">A</span> および <span class="math inline">B</span> が発生するということはないし, <span class="math inline">A</span> が発生しなければ, <span class="math inline">B</span> および <span class="math inline">A</span> が発生するということはないので,</p>
<p><span class="math display">\begin{array}{lclclcl}
P(A\cap B)&amp;=&amp;P(A\mid B)P(B)&amp;=&amp;\dfrac{1}{4}\cdot\dfrac{1}{5}&amp;=&amp;\dfrac{1}{20}\\
P(B\cap A)&amp;=&amp;P(B\mid A)P(A)&amp;=&amp;\dfrac{1}{6}\cdot\dfrac{3}{10}&amp;=&amp;\dfrac{1}{20}
\end{array}</span></p>
<p>である. あとは変形すれば良いだけで,</p>
<p><span class="math display">\begin{array}{lcl}
P(A\mid B)P(B)&amp;=&amp;P(A\cap B)\\
P(A\mid B)&amp;=&amp;\dfrac{P(A\cap B)}{P(B)}\\
P(A\mid B)&amp;=&amp;\dfrac{P(B\mid A)P(A)}{P(B)}
\end{array}</span></p>
<h2 id="モンティホール問題">モンティ・ホール問題</h2>
<p>確率論的な話となるとよく挙げられる有名な問題, モンティ・ホール問題をベイズの定理で解く. モンティ・ホール問題とは, 以下の通りである.</p>
<blockquote>
<p>(snip)プレーヤーの前に閉まった3つのドアがあって、1つのドアの後ろには景品の新車が、2つのドアの後ろには、はずれを意味するヤギがいる。プレーヤーは新車のドアを当てると新車がもらえる。プレーヤーが1つのドアを選択した後、司会のモンティが残りのドアのうちヤギがいるドアを開けてヤギを見せる。</p>
ここでプレーヤーは、最初に選んだドアを、残っている開けられていないドアに変更してもよいと言われる。プレーヤーはドアを変更すべきだろうか？(snip)<br> <strong>ゲームのルール:</strong>
<ol>
<li>
3つのドア (A, B, C) に（景品、ヤギ、ヤギ）がランダムに入っている。
</li>
<li>
プレーヤーはドアを1つ選ぶ。
</li>
<li>
モンティは残りのドアのうち1つを必ず開ける。
</li>
<li>
モンティの開けるドアは、必ずヤギの入っているドアである。
</li>
<li>
モンティはプレーヤーにドアを選びなおしてよいと必ず言う。
</li>
</ol>
– <a href="https://ja.wikipedia.org/w/index.php?title=%E3%83%A2%E3%83%B3%E3%83%86%E3%82%A3%E3%83%BB%E3%83%9B%E3%83%BC%E3%83%AB%E5%95%8F%E9%A1%8C&oldid=69027845"><i>モンティ・ホール問題 - wikipedia</i></a>
</blockquote>
<p>いま, この問題をモンティがヤギのドアを開けた後に, プレーヤーが景品のドアを開ける条件付き確率問題とし, プレーヤーが初手で <span class="math inline">A</span> を選択, それに対しモンティが <span class="math inline">B</span> を選択したとする<a href="/roki.log/2018/07/26/bayestheorem/#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. モンティが <span class="math inline">B</span> を選択したということは, 景品のドアは <span class="math inline">A</span> または <span class="math inline">C</span> である. すなわち, プレーヤーが <span class="math inline">A</span> を選択し, この選択を変えずに <span class="math inline">A</span> が景品のドアである確率は <span class="math inline">P(A\mid B)</span>, 選択を変え <span class="math inline">C</span> が景品のドアである確率は <span class="math inline">P(C\mid B)</span> と書ける. このそれぞれの条件付き確率を, 上で導出したベイズの定理の式に当てはめて求めればよい<a href="/roki.log/2018/07/26/bayestheorem/#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<ul>
<li>モンティは, プレーヤーが選択した <span class="math inline">2</span> つのドア以外のどちらかを選択するから, <span class="math inline">P(B)=\dfrac{1}{2}</span> である.</li>
<li>プレーヤーが初手で選ぶ段階では, 景品のドアを選ぶ確率は均等であるから, <span class="math inline">P(A)=P(C)=\dfrac{1}{3}</span> である.</li>
</ul>
<p>これらを基に, まず <span class="math inline">P(A\mid B)</span> について式にすると,</p>
<p><span class="math display">
\begin{array}{lclclcl}
P(A\mid B) &amp;=&amp; \dfrac{P(B\mid A)P(A)}{P(B)} &amp;=&amp; \dfrac{\dfrac{1}{2}\cdot\dfrac{1}{3}}{\dfrac{1}{2}}&amp;=&amp;\dfrac{1}{3}
\end{array}
</span></p>
<p><span class="math inline">P(A\mid B)</span> とは先も述べたように, <span class="math inline">A</span> が景品のドアであると踏んだときに, それが景品のドアである確率である. よって,</p>
<ul>
<li><span class="math inline">A</span> が景品のドアであれば, モンティは <span class="math inline">B</span> と <span class="math inline">C</span> どちらを選択しても良いことになるので, <span class="math inline">P(B\mid A)=\dfrac{1}{2}</span> である.</li>
</ul>
<p>から上式のようになる. 次に, <span class="math inline">P(C\mid B)</span> について式にすると,</p>
<p><span class="math display">
\begin{array}{lclclcl}
P(C\mid B) &amp;=&amp; \dfrac{P(B\mid C)P(C)}{P(B)}&amp;=&amp;\dfrac{1\cdot \dfrac{1}{3}}{\dfrac{1}{2}}&amp;=&amp;\dfrac{2}{3}
\end{array}
</span></p>
<p><span class="math inline">P(C\mid B)</span> とは先も述べたように, <span class="math inline">C</span> が景品のドアであると踏んだときに, それが景品のドアである確率である. よって,</p>
<ul>
<li><span class="math inline">C</span> が景品のドアであれば, モンティは <span class="math inline">B</span> しか選ぶことができないから, <span class="math inline">P(B\mid C)=1</span> である.</li>
</ul>
<p>から上式のようになる. よって, ドアの選択を変えるべきであるという解が導かれる. Wikipedia にも似たような図があるが, 折角なので, <span class="math inline">1000</span> 回モンティ・ホール問題を試行した場合において, 選択を変えて景品のドアを当てた回数と, 選択を変えずに景品のドアを当てた回数をプロットしてみた<a href="/roki.log/2018/07/26/bayestheorem/#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<figure>
<img src="/roki.log/2018/07/26/bayestheorem/montyhalll.png" title="モンティ・ホール問題の視覚化" alt /><figcaption>モンティ・ホール問題の視覚化</figcaption>
</figure>
<p>当たり前ではあるのだが, この図からも, <span class="math inline">C</span> に変えた方が当たる回数が多くなっていることを確認できる.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>図は matplotlib_venn 他で<a href="https://gist.github.com/falgon/d88e3c0d7d691ab9d97b453e2cec918b">生成</a>.<a href="/roki.log/2018/07/26/bayestheorem/#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>自明であるが, これを <span class="math inline">P(A)=P(A\mid\Omega), P(B)=P(B\mid\Omega)</span> と書くこともできる.<a href="/roki.log/2018/07/26/bayestheorem/#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>他のどのようなドアの組み合わせをとっても, プレーヤーが <span class="math inline">1</span> つドアを選択し, モンティが <span class="math inline">1</span> つヤギのドアを選択するという規則には影響しないから, この前提による一般性の欠如を懸念する必要はない.<a href="/roki.log/2018/07/26/bayestheorem/#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>注: 一応述べておくと, ベイズの定理で使われている変数 <span class="math inline">A, B, C</span> は, このドア <span class="math inline">A, B, C</span> とは無関係である.<a href="/roki.log/2018/07/26/bayestheorem/#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>図は matplotlib で<a href="https://gist.github.com/falgon/5deb211abce5ac715257f55402a22307">生成</a>.<a href="/roki.log/2018/07/26/bayestheorem/#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>

</feed>
